{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code_of_conduct/","title":"Code of conduct","text":"<p>../.github/CODE_OF_CONDUCT.md</p>"},{"location":"algebra/001_fundamentals/","title":"Fundamentals","text":"","tags":["Original"]},{"location":"algebra/002_prime_numbers/","title":"Prime Numbers","text":"","tags":["Original"]},{"location":"algebra/003_number_theoretic_functions/","title":"Number-Theoretic Functions","text":"","tags":["Original"]},{"location":"algebra/004_modular_arithmetic/","title":"Modular Arithmetic","text":"","tags":["Original"]},{"location":"algebra/005_number_systems/","title":"Number Systems","text":"","tags":["Original"]},{"location":"algebra/006_miscellaneous/","title":"Miscellaneous","text":"","tags":["Original"]},{"location":"algorithms/001_Two_Pointers/","title":"Two Pointers","text":"","tags":["Original"]},{"location":"algorithms/002_Binary_Search/","title":"Binary Search","text":"","tags":["Original"]},{"location":"algorithms/003_Binary_Search_Tree/","title":"Binary Search Tree","text":"","tags":["Original"]},{"location":"algorithms/004_Depth_First_Search/","title":"Depth First Search","text":"","tags":["Original"]},{"location":"algorithms/005_Breadth_First_Search/","title":"Breadth First Search","text":"","tags":["Original"]},{"location":"algorithms/006_Backtracking/","title":"Backtracking","text":"","tags":["Original"]},{"location":"algorithms/007_Dynamic_Programming/","title":"Dynamic Programming","text":"","tags":["Original"]},{"location":"algorithms/008_Recursion/","title":"Recursion","text":"","tags":["Original"]},{"location":"combinatorics/001_Permutations/","title":"Permutations","text":"","tags":["Original"]},{"location":"combinatorics/001_Permutations/#display-the-number-of-permutations-for-a-list-of-n-integers","title":"Display the number of permutations for a list of <code>n</code> integers.","text":"","tags":["Original"]},{"location":"combinatorics/001_Permutations/#problem-description","title":"Problem Description:","text":"<p>Display the number of permutations for a list of <code>n</code> integers.</p> <p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#solution-explanation","title":"Solution Explanation","text":"<p>The Python solution use Heap's Algorithm, an efficient method for generating permutations in-place. I'll explain how the algorithm works, and then break down the time and space complexity for each version.</p>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#heaps-algorithm-overview","title":"Heap's Algorithm Overview","text":"<p>Heap's Algorithm is an iterative method for generating permutations of a list in-place (without using additional space for the entire result). It works as follows: 1. Control Array (<code>c</code>): This array keeps track of how many times each element has been swapped in the current level of the algorithm. 2. Swapping: For each position <code>i</code>, the algorithm decides whether to swap the element at position <code>i</code> with the first element (for even <code>i</code>) or with the element at position <code>c[i]</code> (for odd <code>i</code>). 3. Permutation Generation: It generates a new permutation after each swap. The process continues until all permutations have been generated. 4. Termination: The algorithm terminates when the <code>c</code> array contains only zeros, indicating that all permutations have been generated.</p>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#explanation","title":"Explanation","text":"<ul> <li>Initial Setup: We start with a list <code>nums</code> that contains the numbers from 1 to 10 (or any other list). The control array <code>c</code> is initialized with zeros and has the same length as <code>nums</code>.</li> <li>Yielding the Initial Permutation: The first permutation (which is just the original list) is yielded immediately.</li> <li>Iterative Loop: The algorithm iterates through the list, swapping elements and generating new permutations.</li> <li>If <code>c[i] &lt; i</code>, it checks whether <code>i</code> is even or odd:<ul> <li>Even <code>i</code>: The element at position <code>i</code> is swapped with the first element.</li> <li>Odd <code>i</code>: The element at position <code>i</code> is swapped with the element at <code>c[i]</code>.</li> </ul> </li> <li>The new permutation is yielded after each swap.</li> <li>After a permutation is generated, <code>c[i]</code> is incremented, and the index <code>i</code> is reset to zero to continue the next round of swaps.</li> <li>Termination: The loop terminates when all permutations have been generated.</li> </ul>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#time-complexity","title":"Time Complexity","text":"<ul> <li>Swap Operations: For each permutation, the algorithm performs up to <code>n</code> swaps, where <code>n</code> is the length of the list (<code>n = 10</code> in this case).</li> <li>Permutations: There are <code>n!</code> permutations (for <code>n = 10</code>, this is <code>10! = 3,628,800</code>).</li> <li>Total Time Complexity: <code>O(n * n!)</code>, where <code>n</code> is the size of the list.</li> <li>Each permutation requires <code>O(n)</code> swaps.</li> <li>There are <code>n!</code> permutations to generate.</li> </ul>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#space-complexity","title":"Space Complexity","text":"<ul> <li>Control Array: The <code>c</code> array has size <code>n</code>, so it requires <code>O(n)</code> space.</li> <li>Current Permutation: The current list of length <code>n</code> requires <code>O(n)</code> space.</li> <li>Stack Memory: Since this solution uses <code>yield</code>, it doesn't store all permutations in memory at once, only one at a time.</li> <li>Total Space Complexity: <code>O(n)</code>, which is dominated by the <code>c</code> array and the current permutation.</li> </ul>","tags":["Original"]},{"location":"combinatorics/001_Permutations/#solutions","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List, Generator\n\ndef generate_permutations(nums: List[int]) -&gt; Generator[List[int], None, None]:\n    n = len(nums)\n    c = [0] * n  # Control array for the iterative process\n\n    yield nums[:]  # Yield the initial permutation\n\n    i = 0\n    while i &lt; n:\n        if c[i] &lt; i:\n            if i % 2 == 0:\n                nums[0], nums[i] = nums[i], nums[0]  # Swap for even i\n            else:\n                nums[c[i]], nums[i] = nums[i], nums[c[i]]  # Swap for odd i\n            yield nums[:]  # Yield the next permutation\n            c[i] += 1\n            i = 0\n        else:\n            c[i] = 0\n            i += 1\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n\n// Function to generate permutations using Heap's Algorithm\nstd::vector&lt;std::vector&lt;int&gt;&gt; generate_permutations(std::vector&lt;int&gt; nums) {\n    std::vector&lt;std::vector&lt;int&gt;&gt; permutations;\n    int n = nums.size();\n    std::vector&lt;int&gt; c(n, 0);  // Control array for the iterative process\n\n    // Add the initial permutation\n    permutations.push_back(nums);\n\n    int i = 0;\n    while (i &lt; n) {\n        if (c[i] &lt; i) {\n            if (i % 2 == 0) {\n                std::swap(nums[0], nums[i]);\n            } else {\n                std::swap(nums[c[i]], nums[i]);\n            }\n            permutations.push_back(nums);\n            c[i] += 1;\n            i = 0;\n        } else {\n            c[i] = 0;\n            i += 1;\n        }\n    }\n    return permutations;\n}\n\n// Main method to demonstrate the usage\nint main() {\n    std::vector&lt;int&gt; nums = {1, 2, 3};\n\n    auto permutations = generate_permutations(nums);\n\n    // Print all generated permutations\n    std::cout &lt;&lt; \"Generated permutations:\\n\";\n    for (const auto&amp; perm : permutations) {\n        for (int num : perm) {\n            std::cout &lt;&lt; num &lt;&lt; ' ';\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>fn generate_permutations(nums: Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = Vec&lt;i32&gt;&gt; {\n    let mut nums = nums.clone();\n    let n = nums.len();\n    let mut c = vec![0; n];\n    let mut i = 0;\n\n    std::iter::from_fn(move || {\n        if i == 0 {\n            i += 1;\n            return Some(nums.clone());\n        }\n\n        while i &lt; n {\n            if c[i] &lt; i {\n                if i % 2 == 0 {\n                    nums.swap(0, i);\n                } else {\n                    nums.swap(c[i], i);\n                }\n                c[i] += 1;\n                i = 0;\n                return Some(nums.clone());\n            } else {\n                c[i] = 0;\n                i += 1;\n            }\n        }\n        None\n    })\n}\n</code></pre> <pre><code>using System.Collections.Generic;\n\npublic class Permutations {\n    public static IEnumerable&lt;List&lt;int&gt;&gt; GeneratePermutations(List&lt;int&gt; nums) {\n        int n = nums.Count;\n        var c = new int[n];\n        yield return new List&lt;int&gt;(nums);\n\n        int i = 0;\n        while (i &lt; n) {\n            if (c[i] &lt; i) {\n                if (i % 2 == 0) {\n                    (nums[0], nums[i]) = (nums[i], nums[0]);\n                } else {\n                    (nums[c[i]], nums[i]) = (nums[i], nums[c[i]]);\n                }\n                yield return new List&lt;int&gt;(nums);\n                c[i]++;\n                i = 0;\n            } else {\n                c[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Permutations {\n    public static Iterable&lt;List&lt;Integer&gt;&gt; generatePermutations(List&lt;Integer&gt; nums) {\n        return () -&gt; new Iterator&lt;&gt;() {\n            private final int[] c = new int[nums.size()];\n            private int i = 0;\n            private final List&lt;Integer&gt; current = new ArrayList&lt;&gt;(nums);\n            private boolean first = true;\n\n            @Override\n            public boolean hasNext() {\n                return first || i &lt; nums.size();\n            }\n\n            @Override\n            public List&lt;Integer&gt; next() {\n                if (first) {\n                    first = false;\n                    return new ArrayList&lt;&gt;(current);\n                }\n                while (i &lt; nums.size()) {\n                    if (c[i] &lt; i) {\n                        if (i % 2 == 0) {\n                            Collections.swap(current, 0, i);\n                        } else {\n                            Collections.swap(current, c[i], i);\n                        }\n                        c[i]++;\n                        i = 0;\n                        return new ArrayList&lt;&gt;(current);\n                    } else {\n                        c[i] = 0;\n                        i++;\n                    }\n                }\n                return null;\n            }\n        };\n    }\n}\n</code></pre> <pre><code>def generatePermutations(nums: List[Int]): Iterator[List[Int]] = {\n    val c = Array.fill(nums.size)(0)\n    var i = 0\n    var current = nums.toArray\n\n    Iterator.continually {\n        if (i == 0) {\n            Some(current.toList)\n        } else {\n            while (i &lt; current.length) {\n                if (c(i) &lt; i) {\n                    if (i % 2 == 0) {\n                        val tmp = current(0)\n                        current(0) = current(i)\n                        current(i) = tmp\n                    } else {\n                        val tmp = current(c(i))\n                        current(c(i)) = current(i)\n                        current(i) = tmp\n                    }\n                    c(i) += 1\n                    i = 0\n                    return Some(current.toList)\n                } else {\n                    c(i) = 0\n                    i += 1\n                }\n            }\n            None\n        }\n    }.flatten\n}\n</code></pre> <pre><code>fun generatePermutations(nums: MutableList&lt;Int&gt;): Sequence&lt;List&lt;Int&gt;&gt; = sequence {\n    val c = IntArray(nums.size)\n    yield(nums.toList())\n\n    var i = 0\n    while (i &lt; nums.size) {\n        if (c[i] &lt; i) {\n            if (i % 2 == 0) {\n                nums[0] = nums[i].also { nums[i] = nums[0] }\n            } else {\n                nums[c[i]] = nums[i].also { nums[i] = nums[c[i]] }\n            }\n            yield(nums.toList())\n            c[i]++\n            i = 0\n        } else {\n            c[i] = 0\n            i++\n        }\n    }\n}\n</code></pre> <pre><code>package main\n\nfunc generatePermutations(nums []int) [][]int {\n    n := len(nums)\n    result := [][]int{}\n    c := make([]int, n)\n\n    result = append(result, append([]int{}, nums...))\n\n    i := 0\n    for i &lt; n {\n        if c[i] &lt; i {\n            if i%2 == 0 {\n                nums[0], nums[i] = nums[i], nums[0]\n            } else {\n                nums[c[i]], nums[i] = nums[i], nums[c[i]]\n            }\n            result = append(result, append([]int{}, nums...))\n            c[i]++\n            i = 0\n        } else {\n            c[i] = 0\n            i++\n        }\n    }\n    return result\n}\n</code></pre> <pre><code>function* generatePermutations(nums: number[]): Generator&lt;number[]&gt; {\n    const n = nums.length;\n    const c = Array(n).fill(0);\n\n    yield [...nums];\n\n    let i = 0;\n    while (i &lt; n) {\n        if (c[i] &lt; i) {\n            if (i % 2 === 0) {\n                [nums[0], nums[i]] = [nums[i], nums[0]];\n            } else {\n                [nums[c[i]], nums[i]] = [nums[i], nums[c[i]]];\n            }\n            yield [...nums];\n            c[i]++;\n            i = 0;\n        } else {\n            c[i] = 0;\n            i++;\n        }\n    }\n}\n</code></pre> <pre><code>generate_permutations &lt;- function(nums) {\n    n &lt;- length(nums)\n    c &lt;- integer(n)\n    perms &lt;- list(nums)\n\n    i &lt;- 1\n    while (i &lt;= n) {\n        if (c[i] &lt; i) {\n            if (i %% 2 == 1) {\n                nums[c(i, 1)] &lt;- nums[c(1, i)]\n            } else {\n                nums[c(c[i] + 1, i)] &lt;- nums[c(i, c[i] + 1)]\n            }\n            perms &lt;- append(perms, list(nums))\n            c[i] &lt;- c[i] + 1\n            i &lt;- 1\n        } else {\n            c[i] &lt;- 0\n            i &lt;- i + 1\n        }\n    }\n    perms\n}\n</code></pre> <pre><code>function generate_permutations(nums::Vector{Int})\n    n = length(nums)\n    c = zeros(Int, n)\n    result = [copy(nums)]\n\n    i = 1\n    while i &lt;= n\n        if c[i] &lt; i\n            if iseven(i)\n                nums[1], nums[i+1] = nums[i+1], nums[1]\n            else\n                nums[c[i]+1], nums[i+1] = nums[i+1], nums[c[i]+1]\n            end\n            push!(result, copy(nums))\n            c[i] += 1\n            i = 1\n        else\n            c[i] = 0\n            i += 1\n        end\n    end\n    result\nend\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/","title":"Array","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#merge-two-sorted-lists","title":"Merge Two Sorted Lists","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-description","title":"Problem Description:","text":"<p>Merge two sorted lists.</p> <p>Bonus: Can you provide the in-place merge, improved space complexity solution.</p> <p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-explanation","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#solution-1-returning-a-new-list","title":"Solution 1: Returning a New List","text":"<p>Code Walkthrough: 1. Initialize Pointers and Result List:    You create an empty list <code>result</code> to store the merged output and use two pointers <code>i</code> and <code>j</code> initialized to <code>0</code>. These pointers will track the current elements in <code>list1</code> and <code>list2</code>, respectively.</p> <ol> <li>Merge Two Lists Using Pointers:</li> <li> <p>While both pointers haven't reached the end of their respective lists:</p> <ul> <li>If the current element of <code>list1</code> (<code>list1[i]</code>) is smaller, it's appended to <code>result</code>, and the pointer <code>i</code> is incremented.</li> <li>Otherwise, the current element from <code>list2</code> (<code>list2[j]</code>) is appended, and <code>j</code> is incremented.</li> </ul> </li> <li> <p>Appending Remaining Elements:</p> </li> <li> <p>After the loop, there may be leftover elements in <code>list1</code> or <code>list2</code>. These are added to <code>result</code> using the <code>extend</code> method.</p> </li> <li> <p>Return the Result List:    The merged list is returned.</p> </li> </ol>","tags":["Original"]},{"location":"data_structures/001_Array/#time-complexity","title":"Time Complexity:","text":"<ul> <li>Each element in both <code>list1</code> and <code>list2</code> is processed exactly once, so the time complexity is:</li> <li>O(n + m) where <code>n</code> is the length of <code>list1</code> and <code>m</code> is the length of <code>list2</code>.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#space-complexity","title":"Space Complexity:","text":"<ul> <li>Since you're creating a new list (<code>result</code>) to store the merged elements, the space complexity is:</li> <li>O(n + m) because the new list will hold <code>n + m</code> elements.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-2-in-place-merge","title":"Solution 2: In-Place Merge","text":"<p>Code Walkthrough: 1. Extend <code>list1</code>:    - You first extend <code>list1</code> to have enough space for the elements of <code>list2</code> by appending <code>n</code> zeros, where <code>n</code> is the length of <code>list2</code>.</p> <ol> <li>Initialize Indices for Reverse Traversal:</li> <li> <p>You set up three pointers:</p> <ul> <li><code>i</code>: Points to the last element of the original <code>list1</code>.</li> <li><code>j</code>: Points to the last element of <code>list2</code>.</li> <li><code>k</code>: Points to the last position of the newly extended <code>list1</code>.</li> </ul> </li> <li> <p>Merge in Reverse Order:</p> </li> <li>While both <code>i</code> and <code>j</code> are valid (i.e., not negative), compare the elements at <code>list1[i]</code> and <code>list2[j]</code>.</li> <li> <p>Place the larger element at position <code>k</code> in <code>list1</code> and move the corresponding pointer (<code>i</code> or <code>j</code>) and the pointer <code>k</code> backward.</p> </li> <li> <p>Handle Remaining Elements of <code>list2</code>:</p> </li> <li> <p>If there are any elements left in <code>list2</code> (i.e., if <code>j &gt;= 0</code>), copy them into <code>list1</code>.</p> </li> <li> <p>No Need to Return <code>list1</code>: </p> </li> <li>Since the merge happens in-place, <code>list1</code> is modified directly and no new list is returned.</li> </ol>","tags":["Original"]},{"location":"data_structures/001_Array/#time-complexity_1","title":"Time Complexity:","text":"<ul> <li>The time complexity is again O(n + m) because each element from <code>list1</code> and <code>list2</code> is compared and placed in the appropriate position.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#space-complexity_1","title":"Space Complexity:","text":"<ul> <li>The space complexity is O(n), where <code>n</code> is the size of <code>list2</code>, because the only additional memory used is for extending <code>list1</code> to fit the elements from <code>list2</code>. There is no need for an extra list to hold the merged result.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#summary-of-time-and-space-complexity","title":"Summary of Time and Space Complexity:","text":"Solution Time Complexity Space Complexity Solution 1 (New List) O(n + m) O(n + m) (new list) Solution 2 (In-Place Merge) O(n + m) O(n) (in-place) <ul> <li>Both solutions have the same time complexity of O(n + m), but the space complexity differs. Solution 1 creates a new list for the merged result, while Solution 2 does the merge in-place, thus saving space.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#solutions","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code># Solution-1 : Return New List\n# TC = O(n + m), SC = O(n + m)\n\nfrom typing import List\n\nclass Solution:\n    def merge_lists(list1: List[int], list2: List[int]) -&gt; List[int]:\n        result = []\n        i, j = 0, 0\n\n        while i &lt; len(list1) and j &lt; len(list2):\n            if list1[i] &lt; list2[j]:\n                result.append(list1[i])\n                i += 1\n            else:\n                result.append(list2[j])\n                j += 1\n\n        # Append remaining elements\n        result.extend(list1[i:])\n        result.extend(list2[j:])\n\n        return result\n\n    def merge_lists(list1: List[int], list2: List[int]) -&gt; None:\n        m, n = len(list1), len(list2)\n        list1.extend([0] * n)  # Extend list1 to accommodate elements from list2\n\n        i, j, k = m - 1, n - 1, m + n - 1\n\n        # Merge in reverse order\n        while i &gt;= 0 and j &gt;= 0:\n            if list1[i] &gt; list2[j]:\n                list1[k] = list1[i]\n                i -= 1\n            else:\n                list1[k] = list2[j]\n                j -= 1\n            k -= 1\n\n        # Copy remaining elements of list2, if any\n        while j &gt;= 0:\n            list1[k] = list2[j]\n            j -= 1\n            k -= 1\n\n\ndef main() -&gt; None:\n    list1: List[int] = [1, 2, 4]\n    list2: List[int] = [1, 3, 4]\n\n    list: List[int] = merge_lists(list1, list2)\n\n    print(f\"Merged List: {list}\")\n\n    list1 = [1, 2, 4]\n    list2 = [1, 3, 4]\n\n    merge_lists(list1, list2)\n\n    print(f\"Merged List: {list1}\")\n\nif __name__ == \"__main__\":\n    main()\n\n## Output:\n## Merged List: [1, 1, 2, 3, 4, 4]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Solution {\npublic:\n    // Solution 1: Return New List\n    std::vector&lt;int&gt; mergeLists(const std::vector&lt;int&gt;&amp; list1, const std::vector&lt;int&gt;&amp; list2) {\n        std::vector&lt;int&gt; result;\n        size_t i = 0, j = 0;\n\n        while (i &lt; list1.size() &amp;&amp; j &lt; list2.size()) {\n            if (list1[i] &lt; list2[j]) {\n                result.push_back(list1[i]);\n                ++i;\n            } else {\n                result.push_back(list2[j]);\n                ++j;\n            }\n        }\n        result.insert(result.end(), list1.begin() + i, list1.end());\n        result.insert(result.end(), list2.begin() + j, list2.end());\n\n        return result;\n    }\n\n    // Solution 2: In-place Merge\n    void mergeListsInPlace(std::vector&lt;int&gt;&amp; list1, std::vector&lt;int&gt;&amp; list2) {\n        size_t m = list1.size();\n        size_t n = list2.size();\n        list1.resize(m + n);\n\n        size_t i = m - 1, j = n - 1, k = m + n - 1;\n\n        while (i != SIZE_MAX &amp;&amp; j != SIZE_MAX) {\n            if (list1[i] &gt; list2[j]) {\n                list1[k--] = list1[i--];\n            } else {\n                list1[k--] = list2[j--];\n            }\n        }\n        while (j != SIZE_MAX) {\n            list1[k--] = list2[j--];\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Example for Solution 1\n    std::vector&lt;int&gt; list1 = {1, 2, 4};\n    std::vector&lt;int&gt; list2 = {1, 3, 4};\n    auto mergedList = solution.mergeLists(list1, list2);\n    std::cout &lt;&lt; \"Merged List (New List): \";\n    for (int num : mergedList) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Example for Solution 2\n    list1 = {1, 2, 4};\n    list2 = {1, 3, 4};\n    solution.mergeListsInPlace(list1, list2);\n    std::cout &lt;&lt; \"Merged List (In-place): \";\n    for (int num : list1) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    // Solution 1: Return New List\n    pub fn merge_lists(list1: &amp;[i32], list2: &amp;[i32]) -&gt; Vec&lt;i32&gt; {\n        let mut result = Vec::new();\n        let (mut i, mut j) = (0, 0);\n\n        while i &lt; list1.len() &amp;&amp; j &lt; list2.len() {\n            if list1[i] &lt; list2[j] {\n                result.push(list1[i]);\n                i += 1;\n            } else {\n                result.push(list2[j]);\n                j += 1;\n            }\n        }\n\n        result.extend_from_slice(&amp;list1[i..]);\n        result.extend_from_slice(&amp;list2[j..]);\n\n        result\n    }\n\n    // Solution 2: In-place Merge\n    pub fn merge_lists_in_place(list1: &amp;mut Vec&lt;i32&gt;, list2: &amp;[i32]) {\n        let m = list1.len();\n        let n = list2.len();\n        list1.extend(vec![0; n]);\n\n        let (mut i, mut j, mut k) = (m as isize - 1, n as isize - 1, (m + n) as isize - 1);\n\n        while i &gt;= 0 &amp;&amp; j &gt;= 0 {\n            if list1[i as usize] &gt; list2[j as usize] {\n                list1[k as usize] = list1[i as usize];\n                i -= 1;\n            } else {\n                list1[k as usize] = list2[j as usize];\n                j -= 1;\n            }\n            k -= 1;\n        }\n\n        while j &gt;= 0 {\n            list1[k as usize] = list2[j as usize];\n            j -= 1;\n            k -= 1;\n        }\n    }\n}\n\nfn main() {\n    let solution = Solution;\n\n    // Example for Solution 1\n    let list1 = vec![1, 2, 4];\n    let list2 = vec![1, 3, 4];\n    let merged_list = solution.merge_lists(&amp;list1, &amp;list2);\n    println!(\"Merged List (New List): {:?}\", merged_list);\n\n    // Example for Solution 2\n    let mut list1 = vec![1, 2, 4];\n    let list2 = vec![1, 3, 4];\n    solution.merge_lists_in_place(&amp;mut list1, &amp;list2);\n    println!(\"Merged List (In-place): {:?}\", list1);\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    // Solution 1: Return New List\n    public List&lt;int&gt; MergeLists(List&lt;int&gt; list1, List&lt;int&gt; list2) {\n        List&lt;int&gt; result = new List&lt;int&gt;();\n        int i = 0, j = 0;\n\n        while (i &lt; list1.Count &amp;&amp; j &lt; list2.Count) {\n            if (list1[i] &lt; list2[j]) {\n                result.Add(list1[i]);\n                i++;\n            } else {\n                result.Add(list2[j]);\n                j++;\n            }\n        }\n\n        result.AddRange(list1.GetRange(i, list1.Count - i));\n        result.AddRange(list2.GetRange(j, list2.Count - j));\n\n        return result;\n    }\n\n    // Solution 2: In-place Merge\n    public void MergeListsInPlace(List&lt;int&gt; list1, List&lt;int&gt; list2) {\n        int m = list1.Count;\n        int n = list2.Count;\n        list1.AddRange(new int[n]);\n\n        int i = m - 1, j = n - 1, k = m + n - 1;\n\n        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n            if (list1[i] &gt; list2[j]) {\n                list1[k] = list1[i];\n                i--;\n            } else {\n                list1[k] = list2[j];\n                j--;\n            }\n            k--;\n        }\n\n        while (j &gt;= 0) {\n            list1[k] = list2[j];\n            j--;\n            k--;\n        }\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        var solution = new Solution();\n\n        // Example for Solution 1\n        var list1 = new List&lt;int&gt; { 1, 2, 4 };\n        var list2 = new List&lt;int&gt; { 1, 3, 4 };\n        var mergedList = solution.MergeLists(list1, list2);\n        Console.WriteLine(\"Merged List (New List): \" + string.Join(\", \", mergedList));\n\n        // Example for Solution 2\n        list1 = new List&lt;int&gt; { 1, 2, 4 };\n        list2 = new List&lt;int&gt; { 1, 3, 4 };\n        solution.MergeListsInPlace(list1, list2);\n        Console.WriteLine(\"Merged List (In-place): \" + string.Join(\", \", list1));\n    }\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    // Solution 1: Return New List\n    public List&lt;Integer&gt; mergeLists(List&lt;Integer&gt; list1, List&lt;Integer&gt; list2) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        int i = 0, j = 0;\n\n        while (i &lt; list1.size() &amp;&amp; j &lt; list2.size()) {\n            if (list1.get(i) &lt; list2.get(j)) {\n                result.add(list1.get(i));\n                i++;\n            } else {\n                result.add(list2.get(j));\n                j++;\n            }\n        }\n        result.addAll(list1.subList(i, list1.size()));\n        result.addAll(list2.subList(j, list2.size()));\n\n        return result;\n    }\n\n    // Solution 2: In-place Merge\n    public void mergeListsInPlace(List&lt;Integer&gt; list1, List&lt;Integer&gt; list2) {\n        int m = list1.size();\n        int n = list2.size();\n        for (int k = 0; k &lt; n; k++) {\n            list1.add(0); // Extending list1 to accommodate list2\n        }\n\n        int i = m - 1, j = n - 1, k = m + n - 1;\n\n        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n            if (list1.get(i) &gt; list2.get(j)) {\n                list1.set(k--, list1.get(i--));\n            } else {\n                list1.set(k--, list2.get(j--));\n            }\n        }\n\n        while (j &gt;= 0) {\n            list1.set(k--, list2.get(j--));\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example for Solution 1\n        List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(List.of(1, 2, 4));\n        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(List.of(1, 3, 4));\n        List&lt;Integer&gt; mergedList = solution.mergeLists(list1, list2);\n        System.out.println(\"Merged List (New List): \" + mergedList);\n\n        // Example for Solution 2\n        list1 = new ArrayList&lt;&gt;(List.of(1, 2, 4));\n        list2 = new ArrayList&lt;&gt;(List.of(1, 3, 4));\n        solution.mergeListsInPlace(list1, list2);\n        System.out.println(\"Merged List (In-place): \" + list1);\n    }\n}\n</code></pre> <pre><code>object Solution {\n  // Solution 1: Return New List\n  def mergeLists(list1: List[Int], list2: List[Int]): List[Int] = {\n      (list1, list2) match {\n        case (Nil, _) =&gt; list2\n        case (_, Nil) =&gt; list1\n        case (h1 :: t1, h2 :: t2) =&gt;\n            if (h1 &lt; h2) h1 :: mergeLists(t1, list2)\n            else h2 :: mergeLists(list1, t2)\n      }\n  }\n\n  // Solution 2: In-place Merge\n  def mergeListsInPlace(list1: Array[Int], m: Int, list2: Array[Int], n: Int): Unit = {\n      var i = m - 1\n      var j = n - 1\n      var k = m + n - 1\n\n      while (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n        if (list1(i) &gt; list2(j)) {\n            list1(k) = list1(i)\n            i -= 1\n        } else {\n            list1(k) = list2(j)\n            j -= 1\n        }\n        k -= 1\n      }\n\n      while (j &gt;= 0) {\n        list1(k) = list2(j)\n        j -= 1\n        k -= 1\n      }\n  }\n\n  def main(args: Array[String]): Unit = {\n      // Example for Solution 1\n      val list1 = List(1, 2, 4)\n      val list2 = List(1, 3, 4)\n      val mergedList = mergeLists(list1, list2)\n      println(s\"Merged List (New List): $mergedList\")\n\n      // Example for Solution 2\n      val listArray1 = Array(1, 2, 4) ++ Array.fill(3)(0) // Allocating space for list2\n      val listArray2 = Array(1, 3, 4)\n      mergeListsInPlace(listArray1, 3, listArray2, 3)\n      println(s\"Merged List (In-place): ${listArray1.mkString(\", \")}\")\n  }\n}\n</code></pre> <pre><code>class Solution {\n    // Solution 1: Return New List\n    fun mergeLists(list1: List&lt;Int&gt;, list2: List&lt;Int&gt;): List&lt;Int&gt; {\n        val result = mutableListOf&lt;Int&gt;()\n        var i = 0\n        var j = 0\n\n        while (i &lt; list1.size &amp;&amp; j &lt; list2.size) {\n            if (list1[i] &lt; list2[j]) {\n                result.add(list1[i])\n                i++\n            } else {\n                result.add(list2[j])\n                j++\n            }\n        }\n\n        result.addAll(list1.subList(i, list1.size))\n        result.addAll(list2.subList(j, list2.size))\n\n        return result\n    }\n\n    // Solution 2: In-place Merge\n    fun mergeListsInPlace(list1: MutableList&lt;Int&gt;, list2: List&lt;Int&gt;) {\n        val m = list1.size\n        val n = list2.size\n        list1.addAll(MutableList(n) { 0 }) // Extend list1\n\n        var i = m - 1\n        var j = n - 1\n        var k = m + n - 1\n\n        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n            if (list1[i] &gt; list2[j]) {\n                list1[k--] = list1[i--]\n            } else {\n                list1[k--] = list2[j--]\n            }\n        }\n\n        while (j &gt;= 0) {\n            list1[k--] = list2[j--]\n        }\n    }\n}\n\nfun main() {\n    val solution = Solution()\n\n    // Example for Solution 1\n    val list1 = listOf(1, 2, 4)\n    val list2 = listOf(1, 3, 4)\n    val mergedList = solution.mergeLists(list1, list2)\n    println(\"Merged List (New List): $mergedList\")\n\n    // Example for Solution 2\n    val mutableList1 = mutableListOf(1, 2, 4)\n    val mutableList2 = listOf(1, 3, 4)\n    solution.mergeListsInPlace(mutableList1, mutableList2)\n    println(\"Merged List (In-place): $mutableList1\")\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\n// Solution 1: Return New List\nfunc (s *Solution) mergeLists(list1 []int, list2 []int) []int {\n    result := []int{}\n    i, j := 0, 0\n\n    for i &lt; len(list1) &amp;&amp; j &lt; len(list2) {\n        if list1[i] &lt; list2[j] {\n            result = append(result, list1[i])\n            i++\n        } else {\n            result = append(result, list2[j])\n            j++\n        }\n    }\n\n    result = append(result, list1[i:]...)\n    result = append(result, list2[j:]...)\n\n    return result\n}\n\n// Solution 2: In-place Merge\nfunc (s *Solution) mergeListsInPlace(list1 *[]int, list2 []int) {\n    m := len(*list1)\n    n := len(list2)\n    *list1 = append(*list1, make([]int, n)...)\n\n    i, j, k := m-1, n-1, m+n-1\n\n    for i &gt;= 0 &amp;&amp; j &gt;= 0 {\n        if (*list1)[i] &gt; list2[j] {\n            (*list1)[k] = (*list1)[i]\n            i--\n        } else {\n            (*list1)[k] = list2[j]\n            j--\n        }\n        k--\n    }\n\n    for j &gt;= 0 {\n        (*list1)[k] = list2[j]\n        j--\n        k--\n    }\n}\n\nfunc main() {\n    solution := Solution{}\n\n    // Example for Solution 1\n    list1 := []int{1, 2, 4}\n    list2 := []int{1, 3, 4}\n    mergedList := solution.mergeLists(list1, list2)\n    fmt.Println(\"Merged List (New List):\", mergedList)\n\n    // Example for Solution 2\n    list1 = []int{1, 2, 4}\n    list2 = []int{1, 3, 4}\n    solution.mergeListsInPlace(&amp;list1, list2)\n    fmt.Println(\"Merged List (In-place):\", list1)\n}\n</code></pre> <pre><code>class Solution {\n    // Solution 1: Return New List\n    mergeLists(list1: number[], list2: number[]): number[] {\n        const result: number[] = [];\n        let i = 0, j = 0;\n\n        while (i &lt; list1.length &amp;&amp; j &lt; list2.length) {\n            if (list1[i] &lt; list2[j]) {\n                result.push(list1[i]);\n                i++;\n            } else {\n                result.push(list2[j]);\n                j++;\n            }\n        }\n\n        result.push(...list1.slice(i));\n        result.push(...list2.slice(j));\n\n        return result;\n    }\n\n    // Solution 2: In-place Merge\n    mergeListsInPlace(list1: number[], list2: number[]): void {\n        const m = list1.length;\n        const n = list2.length;\n        list1.length += n; // Extend list1\n\n        let i = m - 1, j = n - 1, k = m + n - 1;\n\n        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n            if (list1[i] &gt; list2[j]) {\n                list1[k--] = list1[i--];\n            } else {\n                list1[k--] = list2[j--];\n            }\n        }\n\n        while (j &gt;= 0) {\n            list1[k--] = list2[j--];\n        }\n    }\n}\n\nfunction main() {\n    const solution = new Solution();\n\n    // Example for Solution 1\n    const list1 = [1, 2, 4];\n    const list2 = [1, 3, 4];\n    const mergedList = solution.mergeLists(list1, list2);\n    console.log(\"Merged List (New List):\", mergedList);\n\n    // Example for Solution 2\n    const listArray1 = [1, 2, 4];\n    const listArray2 = [1, 3, 4];\n    solution.mergeListsInPlace(listArray1, listArray2);\n    console.log(\"Merged List (In-place):\", listArray1);\n}\n\nmain();\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\n  \"Solution\",\n  fields = list(),\n\n  methods = list(\n    # Solution 1: Return New List\n    mergeLists = function(list1, list2) {\n      result &lt;- integer(0)\n      i &lt;- 1\n      j &lt;- 1\n\n      while (i &lt;= length(list1) &amp;&amp; j &lt;= length(list2)) {\n        if (list1[i] &lt; list2[j]) {\n          result &lt;- c(result, list1[i])\n          i &lt;- i + 1\n        } else {\n          result &lt;- c(result, list2[j])\n          j &lt;- j + 1\n        }\n      }\n\n      result &lt;- c(result, list1[i:length(list1)], list2[j:length(list2)])\n      return(result)\n    },\n\n    # Solution 2: In-place Merge\n    mergeListsInPlace = function(list1, list2) {\n      m &lt;- length(list1)\n      n &lt;- length(list2)\n      list1 &lt;- c(list1, rep(0, n)) # Extend list1\n\n      i &lt;- m\n      j &lt;- n\n      k &lt;- m + n\n\n      while (i &gt; 0 &amp;&amp; j &gt; 0) {\n        if (list1[i] &gt; list2[j]) {\n          list1[k] &lt;- list1[i]\n          i &lt;- i - 1\n        } else {\n          list1[k] &lt;- list2[j]\n          j &lt;- j - 1\n        }\n        k &lt;- k - 1\n      }\n\n      while (j &gt; 0) {\n        list1[k] &lt;- list2[j]\n        j &lt;- j - 1\n        k &lt;- k - 1\n      }\n\n      return(list1)\n    }\n  )\n)\n\nmain &lt;- function() {\n  solution &lt;- Solution$new()\n\n  # Example for Solution 1\n  list1 &lt;- c(1, 2, 4)\n  list2 &lt;- c(1, 3, 4)\n  mergedList &lt;- solution$mergeLists(list1, list2)\n  print(paste(\"Merged List (New List):\", toString(mergedList)))\n\n  # Example for Solution 2\n  list1 &lt;- c(1, 2, 4, 0, 0, 0) # Allocating space for list2\n  list2 &lt;- c(1, 3, 4)\n  mergedList &lt;- solution$mergeListsInPlace(list1, list2)\n  print(paste(\"Merged List (In-place):\", toString(mergedList)))\n}\n\nmain()\n</code></pre> <pre><code>struct Solution\nend\n\n# Solution 1: Return New List\nfunction mergeLists(list1::Vector{Int}, list2::Vector{Int})\n    result = Int[]\n    i, j = 1, 1\n\n    while i &lt;= length(list1) &amp;&amp; j &lt;= length(list2)\n        if list1[i] &lt; list2[j]\n            push!(result, list1[i])\n            i += 1\n        else\n            push!(result, list2[j])\n            j += 1\n        end\n    end\n\n    append!(result, list1[i:end])\n    append!(result, list2[j:end])\n    return result\nend\n\n# Solution 2: In-place Merge\nfunction mergeListsInPlace!(list1::Vector{Int}, list2::Vector{Int})\n    m = length(list1)\n    n = length(list2)\n    append!(list1, zeros(Int, n)) # Extend list1\n\n    i, j, k = m, n, m + n\n\n    while i &gt; 0 &amp;&amp; j &gt; 0\n        if list1[i] &gt; list2[j]\n            list1[k] = list1[i]\n            i -= 1\n        else\n            list1[k] = list2[j]\n            j -= 1\n        end\n        k -= 1\n    end\n\n    while j &gt; 0\n        list1[k] = list2[j]\n        j -= 1\n        k -= 1\n    end\nend\n\nfunction main()\n    solution = Solution()\n\n    # Example for Solution 1\n    list1 = [1, 2, 4]\n    list2 = [1, 3, 4]\n    mergedList = mergeLists(list1, list2)\n    println(\"Merged List (New List): \", mergedList)\n\n    # Example for Solution 2\n    list1 = [1, 2, 4, 0, 0, 0] # Allocating space for list2\n    list2 = [1, 3, 4]\n    mergeListsInPlace!(list1, list2)\n    println(\"Merged List (In-place): \", list1)\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#merge-k-sorted-lists","title":"Merge <code>k</code> Sorted Lists","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-description_1","title":"Problem Description:","text":"<p>Merge <code>k</code> Sorted Lists.</p> <p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-explanation_1","title":"Solution Explanation","text":"<p>Sure! Let's break down the provided C++ solution for merging <code>k</code> sorted arrays, along with an in-place merge solution, and analyze their time and space complexities.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#detailed-solution-explanation-for-the-priority-queue-method","title":"Detailed Solution Explanation for the Priority Queue Method","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-statement","title":"Problem Statement","text":"<p>You are given <code>k</code> sorted arrays (or vectors) and need to merge them into a single sorted array.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#approach","title":"Approach","text":"<p>The provided solution uses a priority queue (min-heap) to efficiently retrieve the smallest element across all <code>k</code> arrays. Here's a step-by-step breakdown of the approach:</p> <ol> <li>Data Structures:</li> <li>A priority queue is used to maintain the current smallest elements from each of the <code>k</code> arrays. Each element in the priority queue is a pair of iterators, pointing to the current position in each sorted array.</li> <li> <p>A result vector is used to store the merged output.</p> </li> <li> <p>Initialization:</p> </li> <li> <p>The priority queue is initialized with the beginning iterators of all non-empty arrays. The custom comparator ensures that the smallest element can be accessed efficiently.</p> </li> <li> <p>Merging Process:</p> </li> <li> <p>While the priority queue is not empty:</p> <ul> <li>The top element (smallest) is extracted, and its value is added to the result vector.</li> <li>The iterator for the extracted element is advanced. If the iterator hasn't reached the end of its corresponding array, the next element is pushed back into the priority queue.</li> </ul> </li> <li> <p>Result:</p> </li> <li>Once all elements have been processed, the result vector contains the merged sorted elements.</li> </ol>","tags":["Original"]},{"location":"data_structures/001_Array/#time-complexity_2","title":"Time Complexity","text":"<ul> <li>Pushing Elements: Inserting elements into the priority queue takes \\(O(\\log k)\\) time.</li> <li>Total Merges: Each of the \\(N\\) elements (where \\(N\\) is the total number of elements across all arrays) is processed once. Therefore, the overall complexity is:</li> </ul> <pre><code>O(N \\log k)\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#space-complexity_2","title":"Space Complexity","text":"<ul> <li>Priority Queue Storage: The priority queue holds at most <code>k</code> elements at any time, leading to a space complexity of \\(O(k)\\).</li> <li>Result Vector: The space used for the result vector is \\(O(N)\\) since it stores all merged elements.</li> </ul> <p>Overall, the space complexity is dominated by the result vector:</p> <pre><code>O(N + k)\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#in-place-merge-solution","title":"In-Place Merge Solution","text":"<p>An alternative in-place merge approach modifies one of the original arrays to accommodate the merged result, thereby not requiring an additional array for storing the merged result. Here\u2019s how you can implement this:</p>","tags":["Original"]},{"location":"data_structures/001_Array/#in-place-merge-function","title":"In-Place Merge Function","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nvoid mergeInPlace(vector&lt;vector&lt;char&gt;&gt;&amp; chunks) {\n    if (chunks.empty()) return;\n\n    // Create a vector to store all elements\n    vector&lt;char&gt; result;\n\n    // Collect all elements in the result vector\n    for (const auto&amp; chunk : chunks) {\n        result.insert(result.end(), chunk.begin(), chunk.end());\n    }\n\n    // Sort the result vector in-place\n    sort(result.begin(), result.end());\n\n    // Output the merged result\n    cout &lt;&lt; \"Merged Array: \";\n    for (char c : result) {\n        cout &lt;&lt; c &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    vector&lt;vector&lt;char&gt;&gt; chunks = {\n        {'a', 'c', 'e'},\n        {'b', 'd', 'f'},\n        {'g', 'h'}\n    };\n\n    mergeInPlace(chunks); // Merge the arrays in-place\n\n    return 0;\n}\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#explanation-of-in-place-merge-solution","title":"Explanation of In-Place Merge Solution","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#steps","title":"Steps","text":"<ol> <li>Collection: Iterate through each of the <code>k</code> arrays and append their elements to a single <code>result</code> vector.</li> <li>Sorting: Use the standard library's <code>sort()</code> function to sort the entire <code>result</code> vector in place.</li> </ol>","tags":["Original"]},{"location":"data_structures/001_Array/#time-complexity_3","title":"Time Complexity","text":"<ul> <li>Collecting Elements: Appending elements from all <code>k</code> arrays takes \\(O(N)\\).</li> <li>Sorting: The sorting operation takes \\(O(N \\log N)\\) in the worst case.</li> </ul> <p>Overall, the time complexity for this approach is:</p> <pre><code>O(N \\log N)\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#space-complexity_3","title":"Space Complexity","text":"<ul> <li>Result Vector: We store all elements in a new vector, which requires \\(O(N)\\) space.</li> </ul> <p>Thus, the space complexity is:</p> <pre><code>O(N)\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#summary-of-complexity-analysis","title":"Summary of Complexity Analysis","text":"<ul> <li>Priority Queue Method:</li> <li>Time Complexity: \\(O(N \\log k)\\)</li> <li> <p>Space Complexity: \\(O(N + k)\\)</p> </li> <li> <p>In-Place Merge Method:</p> </li> <li>Time Complexity: \\(O(N \\log N)\\)</li> <li>Space Complexity: \\(O(N)\\)</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#conclusion","title":"Conclusion","text":"<p>The priority queue method is generally more efficient for merging <code>k</code> sorted arrays, especially when \\(k\\) is much smaller than \\(N\\)$, as it takes advantage of the sorted nature of the input arrays. The in-place merge method, while simpler, incurs a higher time complexity due to the sorting step, making it less optimal for large datasets.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solutions_1","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List\n\nclass Solution:\n    def merge(self, chunks: List[List[str]]) -&gt; List[str]:\n        from heapq import heappop, heappush\n\n        # Define a pair type for iterators\n        heap = []\n\n        # Initialize the priority queue with the beginning and end of each vector\n        for i, v in enumerate(chunks):\n            if v:\n                heappush(heap, (v[0], i, 0))  # (value, chunk_index, value_index)\n\n        result = []\n        while heap:\n            value, chunk_index, value_index = heappop(heap)\n            result.append(value)\n            if value_index + 1 &lt; len(chunks[chunk_index]):\n                next_value = chunks[chunk_index][value_index + 1]\n                heappush(heap, (next_value, chunk_index, value_index + 1))\n\n        return result\n\n    def merge_in_place(self, chunks: List[List[str]]) -&gt; None:\n        if not chunks:\n            return\n\n        result = []\n        for chunk in chunks:\n            result.extend(chunk)\n\n        result.sort()\n        print(\"Merged Array:\", result)\n\n\ndef main() -&gt; None:\n    solution = Solution()\n    chunks = [['a', 'c', 'e'], ['b', 'd', 'f'], ['g', 'h']]\n    merged = solution.merge(chunks)\n    print(\"Merged Array:\", merged)\n\n    solution.merge_in_place(chunks)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;utility&gt; // For std::pair\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector&lt;char&gt; merge(vector&lt;vector&lt;char&gt;&gt;&amp; chunks) {\n        // Define a pair type for iterators\n        typedef pair&lt;vector&lt;char&gt;::iterator, vector&lt;char&gt;::iterator&gt; it_pair;\n\n        // Custom comparator for the priority queue\n        auto comp = [](const it_pair&amp; a, const it_pair&amp; b) {\n            return *a.first &gt; *b.first; // Min-heap based on the value pointed to by iterators\n        };\n\n        // Priority queue (min-heap) to hold the iterators\n        priority_queue&lt;it_pair, vector&lt;it_pair&gt;, decltype(comp)&gt; q(comp);\n\n        // Initialize the priority queue with the beginning and end of each vector\n        for (auto&amp; v : chunks) {\n            if (!v.empty()) { // Only push non-empty vectors\n                q.push({v.begin(), v.end()});\n            }\n        }\n\n        vector&lt;char&gt; res; // Result vector to store the merged result\n        while (!q.empty()) {\n            auto [it, end] = q.top(); // Get the smallest element iterator\n            q.pop();\n            res.push_back(*it); // Add the smallest element to the result\n            if (++it != end) { // Move the iterator forward\n                q.push({it, end}); // Push the next element of the same vector to the queue\n            }\n        }\n\n        return res; // Return the merged result\n    }\n\n    void mergeInPlace(vector&lt;vector&lt;char&gt;&gt;&amp; chunks) {\n        if (chunks.empty()) return;\n\n        // Create a vector to store all elements\n        vector&lt;char&gt; result;\n\n        // Collect all elements in the result vector\n        for (const auto&amp; chunk : chunks) {\n            result.insert(result.end(), chunk.begin(), chunk.end());\n        }\n\n        // Sort the result vector in-place\n        sort(result.begin(), result.end());\n\n        // Output the merged result\n        cout &lt;&lt; \"Merged Array: \";\n        for (char c : result) {\n            cout &lt;&lt; c &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n\nint main() {\n    Solution solution;\n    // Example input: k sorted arrays\n    vector&lt;vector&lt;char&gt;&gt; chunks = {\n        {'a', 'c', 'e'},\n        {'b', 'd', 'f'},\n        {'g', 'h'}\n    };\n\n    vector&lt;char&gt; merged = solution.merge(chunks); // Merge the arrays\n\n    // Output the merged result\n    cout &lt;&lt; \"Merged Array: \";\n    for (char c : merged) {\n        cout &lt;&lt; c &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    chunks = {\n        {'a', 'c', 'e'},\n        {'b', 'd', 'f'},\n        {'g', 'h'}\n    };\n\n    merged = solution.merge(chunks); // Merge the arrays\n\n    // Output the merged result\n    cout &lt;&lt; \"Merged Array: \";\n    for (char c : merged) {\n        cout &lt;&lt; c &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0; // Indicate successful completion\n}\n</code></pre> <pre><code>use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\nstruct Solution;\n\nimpl Solution {\n    pub fn merge(chunks: Vec&lt;Vec&lt;char&gt;&gt;) -&gt; Vec&lt;char&gt; {\n        let mut heap = BinaryHeap::new();\n        for (i, v) in chunks.iter().enumerate() {\n            if !v.is_empty() {\n                heap.push((v[0], i, 0)); // (value, chunk_index, value_index)\n            }\n        }\n\n        let mut result = Vec::new();\n        while let Some((value, chunk_index, value_index)) = heap.pop() {\n            result.push(value);\n            let next_index = value_index + 1;\n            if next_index &lt; chunks[chunk_index].len() {\n                heap.push((chunks[chunk_index][next_index], chunk_index, next_index));\n            }\n        }\n\n        result\n    }\n\n    pub fn merge_in_place(chunks: Vec&lt;Vec&lt;char&gt;&gt;) {\n        let mut result: Vec&lt;char&gt; = chunks.iter().flat_map(|chunk| chunk.iter()).cloned().collect();\n        result.sort();\n        println!(\"Merged Array: {:?}\", result);\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let chunks = vec![vec!['a', 'c', 'e'], vec!['b', 'd', 'f'], vec!['g', 'h']];\n    let merged = solution.merge(chunks.clone());\n    println!(\"Merged Array: {:?}\", merged);\n    solution.merge_in_place(chunks);\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution\n{\n    public List&lt;char&gt; Merge(List&lt;List&lt;char&gt;&gt; chunks)\n    {\n        var heap = new SortedSet&lt;(char value, int chunkIndex, int valueIndex)&gt;();\n        for (int i = 0; i &lt; chunks.Count; i++)\n        {\n            if (chunks[i].Count &gt; 0)\n                heap.Add((chunks[i][0], i, 0));\n        }\n\n        var result = new List&lt;char&gt;();\n        while (heap.Count &gt; 0)\n        {\n            var (value, chunkIndex, valueIndex) = heap.Min;\n            heap.Remove(heap.Min);\n            result.Add(value);\n            if (valueIndex + 1 &lt; chunks[chunkIndex].Count)\n            {\n                heap.Add((chunks[chunkIndex][valueIndex + 1], chunkIndex, valueIndex + 1));\n            }\n        }\n\n        return result;\n    }\n\n    public void MergeInPlace(List&lt;List&lt;char&gt;&gt; chunks)\n    {\n        if (chunks.Count == 0) return;\n\n        var result = new List&lt;char&gt;();\n        foreach (var chunk in chunks)\n        {\n            result.AddRange(chunk);\n        }\n\n        result.Sort();\n        Console.WriteLine(\"Merged Array: \" + string.Join(\" \", result));\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var solution = new Solution();\n        var chunks = new List&lt;List&lt;char&gt;&gt; {\n            new List&lt;char&gt; {'a', 'c', 'e'},\n            new List&lt;char&gt; {'b', 'd', 'f'},\n            new List&lt;char&gt; {'g', 'h'}\n        };\n\n        var merged = solution.Merge(chunks);\n        Console.WriteLine(\"Merged Array: \" + string.Join(\" \", merged));\n\n        solution.MergeInPlace(chunks);\n    }\n}\n</code></pre> <pre><code>import java.util.*;\n\nclass Solution {\n    public List&lt;Character&gt; merge(List&lt;List&lt;Character&gt;&gt; chunks) {\n        PriorityQueue&lt;Iterator&lt;Character&gt;&gt; heap = new PriorityQueue&lt;&gt;((a, b) -&gt; Character.compare(a.next(), b.next()));\n\n        for (List&lt;Character&gt; chunk : chunks) {\n            if (!chunk.isEmpty()) {\n                heap.offer(chunk.iterator());\n            }\n        }\n\n        List&lt;Character&gt; result = new ArrayList&lt;&gt;();\n        while (!heap.isEmpty()) {\n            Iterator&lt;Character&gt; it = heap.poll();\n            if (it.hasNext()) {\n                result.add(it.next());\n                if (it.hasNext()) {\n                    heap.offer(it);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public void mergeInPlace(List&lt;List&lt;Character&gt;&gt; chunks) {\n        if (chunks.isEmpty()) return;\n\n        List&lt;Character&gt; result = new ArrayList&lt;&gt;();\n        for (List&lt;Character&gt; chunk : chunks) {\n            result.addAll(chunk);\n        }\n        Collections.sort(result);\n        System.out.println(\"Merged Array: \" + result);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List&lt;List&lt;Character&gt;&gt; chunks = Arrays.asList(\n            Arrays.asList('a', 'c', 'e'),\n            Arrays.asList('b', 'd', 'f'),\n            Arrays.asList('g', 'h')\n        );\n\n        List&lt;Character&gt; merged = solution.merge(chunks);\n        System.out.println(\"Merged Array: \" + merged);\n\n        solution.mergeInPlace(chunks);\n    }\n}\n</code></pre> <pre><code>import scala.collection.mutable\nimport scala.collection.mutable.ListBuffer\n\nclass Solution {\n  def merge(chunks: List[List[Char]]): List[Char] = {\n    val heap = mutable.PriorityQueue.empty[(Char, Int, Int)](Ordering.by[(Char, Int, Int), Char](_._1).reverse)\n\n    for (i &lt;- chunks.indices if chunks(i).nonEmpty) {\n      heap.enqueue((chunks(i)(0), i, 0))\n    }\n\n    val result = ListBuffer[Char]()\n    while (heap.nonEmpty) {\n      val (value, chunkIndex, valueIndex) = heap.dequeue()\n      result += value\n      if (valueIndex + 1 &lt; chunks(chunkIndex).length) {\n        heap.enqueue((chunks(chunkIndex)(valueIndex + 1), chunkIndex, valueIndex + 1))\n      }\n    }\n\n    result.toList\n  }\n\n  def mergeInPlace(chunks: List[List[Char]]): Unit = {\n    if (chunks.isEmpty) return\n\n    val result = chunks.flatten.sorted\n    println(\"Merged Array: \" + result.mkString(\" \"))\n  }\n}\n\nobject Main extends App {\n  val solution = new Solution\n  val chunks = List(\n    List('a', 'c', 'e'),\n    List('b', 'd', 'f'),\n    List('g', 'h')\n  )\n\n  val merged = solution.merge(chunks)\n  println(\"Merged Array: \" + merged.mkString(\" \"))\n  solution.mergeInPlace(chunks)\n}\n</code></pre> <pre><code>class Solution {\n    fun merge(chunks: List&lt;List&lt;Char&gt;&gt;): List&lt;Char&gt; {\n        val heap = PriorityQueue&lt;Pair&lt;Char, Pair&lt;Int, Int&gt;&gt;&gt; { a, b -&gt; a.first.compareTo(b.first) }\n\n        for (i in chunks.indices) {\n            if (chunks[i].isNotEmpty()) {\n                heap.add(Pair(chunks[i][0], Pair(i, 0)))\n            }\n        }\n\n        val result = mutableListOf&lt;Char&gt;()\n        while (heap.isNotEmpty()) {\n            val (value, (chunkIndex, valueIndex)) = heap.poll()\n            result.add(value)\n            if (valueIndex + 1 &lt; chunks[chunkIndex].size) {\n                heap.add(Pair(chunks[chunkIndex][valueIndex + 1], Pair(chunkIndex, valueIndex + 1)))\n            }\n        }\n\n        return result\n    }\n\n    fun mergeInPlace(chunks: List&lt;List&lt;Char&gt;&gt;) {\n        if (chunks.isEmpty()) return\n\n        val result = chunks.flatten().sorted()\n        println(\"Merged Array: ${result.joinToString(\" \")}\")\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val chunks = listOf(\n        listOf('a', 'c', 'e'),\n        listOf('b', 'd', 'f'),\n        listOf('g', 'h')\n    )\n\n    val merged = solution.merge(chunks)\n    println(\"Merged Array: ${merged.joinToString(\" \")}\")\n    solution.mergeInPlace(chunks)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n    \"sort\"\n)\n\ntype Item struct {\n    value      rune\n    chunkIndex int\n    valueIndex int\n}\n\ntype MinHeap []Item\n\nfunc (h MinHeap) Len() int           { return len(h) }\nfunc (h MinHeap) Less(i, j int) bool { return h[i].value &lt; h[j].value }\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *MinHeap) Push(x interface{}) {\n    *h = append(*h, x.(Item))\n}\n\nfunc (h *MinHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\ntype Solution struct{}\n\nfunc (s *Solution) Merge(chunks [][]rune) []rune {\n    h := &amp;MinHeap{}\n    heap.Init(h)\n\n    for i, chunk := range chunks {\n        if len(chunk) &gt; 0 {\n            heap.Push(h, Item{value: chunk[0], chunkIndex: i, valueIndex: 0})\n        }\n    }\n\n    result := []rune{}\n    for h.Len() &gt; 0 {\n        item := heap.Pop(h).(Item)\n        result = append(result, item.value)\n        if item.valueIndex+1 &lt; len(chunks[item.chunkIndex]) {\n            nextItem := Item{value: chunks[item.chunkIndex][item.valueIndex+1], chunkIndex: item.chunkIndex, valueIndex: item.valueIndex + 1}\n            heap.Push(h, nextItem)\n        }\n    }\n\n    return result\n}\n\nfunc (s *Solution) MergeInPlace(chunks [][]rune) {\n    if len(chunks) == 0 {\n        return\n    }\n\n    result := []rune{}\n    for _, chunk := range chunks {\n        result = append(result, chunk...)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i] &lt; result[j]\n    })\n\n    fmt.Println(\"Merged Array:\", string(result))\n}\n\nfunc main() {\n    solution := Solution{}\n    chunks := [][]rune{\n        {'a', 'c', 'e'},\n        {'b', 'd', 'f'},\n        {'g', 'h'},\n    }\n\n    merged := solution.Merge(chunks)\n    fmt.Println(\"Merged Array:\", string(merged))\n    solution.MergeInPlace(chunks)\n}\n</code></pre> <pre><code>class Solution {\n    merge(chunks: Array&lt;Array&lt;string&gt;&gt;): Array&lt;string&gt; {\n        const heap: Array&lt;[string, number, number]&gt; = [];\n\n        for (let i = 0; i &lt; chunks.length; i++) {\n            if (chunks[i].length &gt; 0) {\n                heap.push([chunks[i][0], i, 0]);\n            }\n        }\n\n        heap.sort(([valueA], [valueB]) =&gt; valueA.localeCompare(valueB));\n\n        const result: string[] = [];\n        while (heap.length &gt; 0) {\n            const [value, chunkIndex, valueIndex] = heap.shift()!;\n            result.push(value);\n            if (valueIndex + 1 &lt; chunks[chunkIndex].length) {\n                heap.push([chunks[chunkIndex][valueIndex + 1], chunkIndex, valueIndex + 1]);\n            }\n            heap.sort(([valueA], [valueB]) =&gt; valueA.localeCompare(valueB));\n        }\n\n        return result;\n    }\n\n    mergeInPlace(chunks: Array&lt;Array&lt;string&gt;&gt;): void {\n        if (chunks.length === 0) return;\n\n        const result: string[] = [];\n        for (const chunk of chunks) {\n            result.push(...chunk);\n        }\n\n        result.sort();\n        console.log(\"Merged Array:\", result.join(\" \"));\n    }\n}\n\nfunction main() {\n    const solution = new Solution();\n    const chunks = [\n        ['a', 'c', 'e'],\n        ['b', 'd', 'f'],\n        ['g', 'h']\n    ];\n\n    const merged = solution.merge(chunks);\n    console.log(\"Merged Array:\", merged.join(\" \"));\n\n    solution.mergeInPlace(chunks);\n}\n\nmain();\n</code></pre> <pre><code>merge &lt;- function(chunks) {\n  heap &lt;- list()\n\n  for (i in seq_along(chunks)) {\n    if (length(chunks[[i]]) &gt; 0) {\n      heap[[length(heap) + 1]] &lt;- list(value = chunks[[i]][1], chunkIndex = i, valueIndex = 1)\n    }\n  }\n\n  result &lt;- character(0)\n\n  while (length(heap) &gt; 0) {\n    minIndex &lt;- which.min(sapply(heap, function(x) x$value))\n    minItem &lt;- heap[[minIndex]]\n    result &lt;- c(result, minItem$value)\n    heap &lt;- heap[-minIndex]\n\n    nextValueIndex &lt;- minItem$valueIndex + 1\n    if (nextValueIndex &lt;= length(chunks[[minItem$chunkIndex]])) {\n      heap[[length(heap) + 1]] &lt;- list(value = chunks[[minItem$chunkIndex]][nextValueIndex], chunkIndex = minItem$chunkIndex, valueIndex = nextValueIndex)\n    }\n  }\n\n  return(result)\n}\n\nmergeInPlace &lt;- function(chunks) {\n  if (length(chunks) == 0) return()\n\n  result &lt;- unlist(chunks)\n  result &lt;- sort(result)\n  cat(\"Merged Array:\", paste(result, collapse = \" \"), \"\\n\")\n}\n\nmain &lt;- function() {\n  chunks &lt;- list(\n    c('a', 'c', 'e'),\n    c('b', 'd', 'f'),\n    c('g', 'h')\n  )\n\n  merged &lt;- merge(chunks)\n  cat(\"Merged Array:\", paste(merged, collapse = \" \"), \"\\n\")\n\n  mergeInPlace(chunks)\n}\n\nmain()\n</code></pre> <pre><code>module Solution\n\nexport merge, merge_in_place\n\nfunction merge(chunks::Vector{Vector{Char}})::Vector{Char}\n    heap = PriorityQueue{Tuple{Char, Int, Int}}()\n\n    for (i, chunk) in enumerate(chunks)\n        if !isempty(chunk)\n            enqueue!(heap, (chunk[1], i, 1))\n        end\n    end\n\n    result = Char[]\n    while !isempty(heap)\n        value, chunkIndex, valueIndex = dequeue!(heap)\n        push!(result, value)\n        if valueIndex &lt; length(chunks[chunkIndex])\n            enqueue!(heap, (chunks[chunkIndex][valueIndex + 1], chunkIndex, valueIndex + 1))\n        end\n    end\n\n    return result\nend\n\nfunction merge_in_place(chunks::Vector{Vector{Char}})\n    if isempty(chunks)\n        return\n    end\n\n    result = reduce(vcat, chunks)\n    sort!(result)\n    println(\"Merged Array: \", result)\nend\n\nend\n\nusing .Solution\n\nfunction main()\n    chunks = [\n        ['a', 'c', 'e'],\n        ['b', 'd', 'f'],\n        ['g', 'h']\n    ]\n\n    merged = Solution.merge(chunks)\n    println(\"Merged Array: \", merged)\n\n    Solution.merge_in_place(chunks)\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#remove-duplicates-from-sorted-array","title":"Remove Duplicates from Sorted Array","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-description-leetcode-problem-26-remove-duplicates-from-sorted-array","title":"Problem Description: LeetCode - Problem 26 - Remove Duplicates from Sorted Array","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#intuition","title":"Intuition","text":"<p>The intuition is to use two pointers, <code>i</code> and <code>j</code>, to iterate through the array. The variable <code>j</code> is used to keep track of the current index where a unique element should be placed. The initial value of <code>j</code> is 1 since the first element in the array is always unique and doesn't need to be changed.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-explanation_2","title":"Solution Explanation","text":"<p>The code starts iterating from <code>i = 1</code> because we need to compare each element with its previous element to check for duplicates.</p> <p>The main logic is inside the for loop:</p> <ul> <li>If the current element <code>nums[i]</code> is not equal to the previous element <code>nums[i - 1]</code>, it means we have encountered a new unique element.</li> <li>In that case, we update <code>nums[j]</code> with the value of the unique element at <code>nums[i]</code>, and then increment <code>j</code> by <code>1</code> to mark the next position for a new unique element.</li> <li>By doing this, we effectively overwrite any duplicates in the array and only keep the unique elements.</li> </ul> <p>Once the loop finishes, the value of <code>j</code> represents the length of the resulting array with duplicates removed.</p> <p>Finally, we return <code>j</code> as the desired result.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time Complexity :</li> <li>Initialization: The variable assignment operation to initialize <code>j = 1</code> takes constant time <code>O(1)</code>.</li> <li>Loop: The loop runs through the <code>nums</code> list once, comparing elements and updating the <code>j</code> index. This loop iterates through the list of length <code>n</code> with <code>n-1</code> comparisons.<ul> <li>Each iteration does constant work (comparing array elements and updating a counter), leading to a time complexity of <code>O(n)</code>.</li> </ul> </li> <li> <p>Therefore, the overall time complexity of the <code>removeDuplicates</code> method is <code>O(n)</code>, where <code>n</code> is the length of the input list <code>nums</code>.</p> </li> <li> <p>Space Complexity :</p> </li> <li>The algorithm performs modifications in-place, updating the input list <code>nums</code> without using any extra data structures.</li> <li>The extra space used is only for a constant number of integer variables (<code>j</code>, <code>i</code>) and does not depend on the input size.</li> <li>Hence, the algorithm has a space complexity of <code>O(1)</code>, indicating constant space usage regardless of the size of the input list <code>nums</code>.</li> </ul> <p>In summary : - <code>n</code> being the length of the input list <code>nums</code>.   - Overall Time Complexity: <code>O(n)</code>   - Overall Space Complexity: <code>O(1)</code></p> <p>This solution effectively removes duplicates from the input list in linear time complexity while using only constant additional space, making it an efficient and space-saving approach for this problem.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solutions_2","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                j += 1\n        return j\n</code></pre> <pre><code>#include &lt;vector&gt;\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int j = 1;\n        for(int i = 1; i &lt; nums.size(); i++){\n            if(nums[i] != nums[i - 1]){\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        return j;\n    }\n};\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn remove_duplicates(nums: &amp;mut Vec&lt;i32&gt;) -&gt; usize {\n        let mut j = 1;\n        let len = nums.len();\n        for i in 1..len {\n            if nums[i] != nums[i - 1] {\n                nums[j] = nums[i];\n                j += 1;\n            }\n        }\n        j\n    }\n}\n\nfn main() {\n    let mut nums = vec![1, 1, 2];\n    let new_length = Solution::remove_duplicates(&amp;mut nums);\n    println!(\"New length: {}\", new_length);\n    println!(\"Modified array: {:?}\", &amp;nums[..new_length]);\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        if (nums.Length == 0) return 0;\n\n        int j = 1;\n        for (int i = 1; i &lt; nums.Length; i++) {\n            if (nums[i] != nums[i - 1]) {\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        return j;\n    }\n\n    public static void Main() {\n        var nums = new int[] { 1, 1, 2 };\n        var solution = new Solution();\n        int newLength = solution.RemoveDuplicates(nums);\n        Console.WriteLine(\"New length: \" + newLength);\n        Console.WriteLine(\"Modified array: \" + string.Join(\", \", nums[..newLength]));\n    }\n}\n</code></pre> <pre><code>class Solution {\n    public int removeDuplicates(int[] nums) {\n        int j = 1;\n        for (int i = 1; i &lt; nums.length; i++) {\n            if (nums[i] != nums[i - 1]) {\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        return j;\n    }\n}\n</code></pre> <pre><code>class Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        var j = 1\n        for (i &lt;- 1 until nums.length) {\n            if (nums(i) != nums(i - 1)) {\n                nums(j) = nums(i)\n                j += 1\n            }\n        }\n        j\n    }\n}\n\nobject Main extends App {\n    val solution = new Solution\n    val nums = Array(1, 1, 2)\n    val newLength = solution.removeDuplicates(nums)\n    println(s\"New length: $newLength\")\n    println(s\"Modified array: ${nums.take(newLength).mkString(\", \")}\")\n}\n</code></pre> <pre><code>class Solution {\n    fun removeDuplicates(nums: Array&lt;Int&gt;): Int {\n        var j = 1\n        for (i in 1 until nums.size) {\n            if (nums[i] != nums[i - 1]) {\n                nums[j] = nums[i]\n                j++\n            }\n        }\n        return j\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val nums = arrayOf(1, 1, 2, 2, 3, 4, 4, 5, 5)\n    val resultSize = solution.removeDuplicates(nums)\n\n    println(\"Modified Array Size: $resultSize\")\n    for (i in 0 until resultSize) {\n        print(\"${nums[i]} \")\n    }\n}\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Solution struct{}\n\nfunc (s Solution) RemoveDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    j := 1\n    for i := 1; i &lt; len(nums); i++ {\n        if nums[i] != nums[i - 1] {\n            nums[j] = nums[i]\n            j++\n        }\n    }\n    return j\n}\n\nfunc main() {\n    s := Solution{}\n    nums := []int{1, 1, 2}\n    newLength := s.RemoveDuplicates(nums)\n    fmt.Println(\"New length:\", newLength)\n    fmt.Println(\"Modified array:\", nums[:newLength])\n}\n</code></pre> <pre><code>class Solution {\n    removeDuplicates(nums: number[]): number {\n        let j = 1;\n        for (let i = 1; i &lt; nums.length; i++) {\n            if (nums[i] !== nums[i - 1]) {\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        return j;\n    }\n}\n\n// Example usage\nconst solution = new Solution();\nconst nums = [1, 1, 2];\nconst newLength = solution.removeDuplicates(nums);\nconsole.log(\"New length:\", newLength);\nconsole.log(\"Modified array:\", nums.slice(0, newLength));\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\"Solution\",\n    methods = list(\n        removeDuplicates = function(nums) {\n        if (length(nums) == 0) return(0)\n        j &lt;- 1\n        for (i in 2:length(nums)) {\n            if (nums[i] != nums[i - 1]) {\n            nums[j + 1] &lt;- nums[i]\n            j &lt;- j + 1\n            }\n        }\n        return(j)\n        }\n    )\n)\n\n# Example usage\nsolution &lt;- Solution$new()\nnums &lt;- c(1, 1, 2)\nnewLength &lt;- solution$removeDuplicates(nums)\ncat(\"New length:\", newLength, \"\\n\")\ncat(\"Modified array:\", nums[1:newLength], \"\\n\")\n</code></pre> <pre><code>struct Solution\nend\n\nfunction remove_duplicates(s::Solution, nums::Vector{Int})::Int\n    if isempty(nums)\n        return 0\n    end\n    j = 1\n    for i in 2:length(nums)\n        if nums[i] != nums[i - 1]\n            nums[j + 1] = nums[i]\n            j += 1\n        end\n    end\n    return j\nend\n\n# Example usage\ns = Solution()\nnums = [1, 1, 2]\nnewLength = remove_duplicates(s, nums)\nprintln(\"New length: \", newLength)\nprintln(\"Modified array: \", nums[1:newLength])\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#remove-element","title":"Remove Element","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-description-leetcode-problem-27-remove-element","title":"Problem Description: LeetCode - Problem 27 - Remove Element","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#intuition_1","title":"Intuition","text":"<p>The intuition behind this solution is to iterate through the array and keep track of two pointers: <code>index</code> and <code>i</code>. The index pointer represents the position where the next non-target element should be placed, while the i pointer iterates through the array elements. By overwriting the target elements with non-target elements, the solution effectively removes all occurrences of the target value from the array.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-explanation_3","title":"Solution Explanation","text":"<ul> <li>Initialize <code>index</code> to <code>0</code>, which represents the current position for the next non-target element.</li> <li>Iterate through each element of the input array using the <code>i</code> pointer.</li> <li>For each element <code>nums[i]</code>, check if it is equal to the target value.</li> <li>If <code>nums[i]</code> is not equal to <code>val</code>, it means it is a non-target element.</li> <li>Set <code>nums[index]</code> to <code>nums[i]</code> to store the non-target element at the current index position.</li> <li>Increment <code>index</code> by <code>1</code> to move to the next position for the next non-target element.</li> <li>Continue this process until all elements in the array have been processed.</li> <li>Finally, return the value of <code>index</code>, which represents the length of the modified array.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#complexity-analysis_1","title":"Complexity Analysis","text":"<ul> <li>Time Complexity :</li> <li>The algorithm iterates through the input list <code>nums</code> once, where the number of iterations is equal to the length of the list <code>len(nums) = n</code>.<ul> <li>Each iteration involves constant time operations: comparing elements, updating the index <code>index</code>, and potentially updating array elements.</li> </ul> </li> <li> <p>As each element in the array is processed once, the time complexity is <code>O(n)</code>, where <code>n</code> is the length of the input list <code>nums</code>.</p> </li> <li> <p>Space Complexity :</p> </li> <li>The additional space used in the algorithm is independent of the input size and primarily includes maintaining constant variables (<code>index</code>, <code>i</code>, <code>val</code>) to track the processing.</li> <li>The space complexity is <code>O(1)</code>, indicating that the space usage remains constant regardless of the input size, as the modifications are made in-place without utilizing any extra data structures.</li> </ul> <p>In summary : - <code>n</code> being the length of the input list <code>nums</code>.   - Overall Time Complexity: <code>O(n)</code>   - Overall Space Complexity: <code>O(1)</code></p> <p>The solution efficiently removes the specified element from the input array with a linear time complexity and constant space complexity, making it an optimal approach for this problem.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#solutions_3","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    def removeElement(self, nums: List[int], val: int) -&gt; int:\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[index] = nums[i]\n                index += 1\n        return index\n</code></pre> <pre><code>#include &lt;vector&gt;\n\nclass Solution {\npublic:\n    int removeElement(std::vector&lt;int&gt;&amp; nums, int val) {\n        int index = 0;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (nums[i] != val) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n};\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {\n        let mut index = 0;\n        for i in 0..nums.len() {\n            if nums[i] != val {\n                nums[index] = nums[i];\n                index += 1;\n            }\n        }\n        index as i32\n    }\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public int RemoveElement(List&lt;int&gt; nums, int val) {\n        int index = 0;\n        for (int i = 0; i &lt; nums.Count; i++) {\n            if (nums[i] != val) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}\n</code></pre> <pre><code>import java.util.List;\n\npublic class Solution {\n    public int removeElement(List&lt;Integer&gt; nums, int val) {\n        int index = 0;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (nums.get(i) != val) {\n                nums.set(index, nums.get(i));\n                index++;\n            }\n        }\n        return index;\n    }\n}\n</code></pre> <pre><code>class Solution {\n    def removeElement(nums: scala.collection.mutable.Seq[Int], value: Int): Int = {\n        var index = 0\n        for (i &lt;- nums.indices) {\n            if (nums(i) != value) {\n                nums(index) = nums(i)\n                index += 1\n            }\n        }\n        index\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun removeElement(nums: MutableList&lt;Int&gt;, value: Int): Int {\n        var index = 0\n        for (i in nums.indices) {\n            if (nums[i] != value) {\n                nums[index] = nums[i]\n                index++\n            }\n        }\n        return index\n    }\n}\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Solution struct{}\n\nfunc (s Solution) removeElement(nums []int, val int) int {\n    index := 0\n    for i := 0; i &lt; len(nums); i++ {\n        if nums[i] != val {\n            nums[index] = nums[i]\n            index++\n        }\n    }\n    return index\n}\n\nfunc main() {\n    nums := []int{3, 2, 2, 3}\n    sol := Solution{}\n    result := sol.removeElement(nums, 3)\n    fmt.Println(result)\n}\n</code></pre> <pre><code>class Solution {\n    removeElement(nums: number[], val: number): number {\n        let index = 0;\n        for (let i = 0; i &lt; nums.length; i++) {\n            if (nums[i] !== val) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\"Solution\", \n    methods = list(\n        removeElement = function(nums, val) {\n            index &lt;- 0\n            for (i in seq_along(nums)) {\n                if (nums[i] != val) {\n                nums[index + 1] &lt;- nums[i]\n                index &lt;- index + 1\n                }\n            }\n            return(index)\n        }\n    )\n)\n</code></pre> <pre><code>module SolutionModule\n\nmutable struct Solution\n    function removeElement(nums::Vector{Int}, val::Int)::Int\n        index = 0\n        for i in 1:length(nums)\n            if nums[i] != val\n                nums[index + 1] = nums[i]\n                index += 1\n            end\n        end\n        return index\n    end\nend\n\nend\n</code></pre>","tags":["Original"]},{"location":"data_structures/001_Array/#next-permutation","title":"Next Permutation","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#problem-description-leetcode-problem-31-next-permutation","title":"Problem Description: LeetCode - Problem 31 - Next Permutation","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/001_Array/#intuition_2","title":"Intuition","text":"<p>The problem requires finding the next lexicographical permutation of a given sequence of numbers. The next permutation is the next arrangement of numbers that's larger than the current sequence but in ascending order. If no such arrangement exists (i.e., the numbers are in descending order), the next permutation is simply the smallest possible arrangement (ascending order).</p>","tags":["Original"]},{"location":"data_structures/001_Array/#key-insights","title":"Key Insights","text":"<ul> <li>The next permutation problem boils down to rearranging the elements to find the smallest possible permutation that is larger than the given one.</li> <li>This involves finding the right elements to swap and then arranging the rest of the sequence in ascending order to get the smallest possible arrangement.</li> </ul>","tags":["Original"]},{"location":"data_structures/001_Array/#solution-explanation_4","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#complexity-analysis_2","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/001_Array/#solutions_4","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List\n\nclass Solution:\n    def reverse(self, nums: List[int], i: int, j: int) -&gt; None:\n        \"\"\"\n        Helper function to reverse the array segment between indices i and j.\n        \"\"\"\n        while i &lt;= j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    def nextPermutation(self, nums: List[int]) -&gt; None:\n        n = len(nums)  # Get the size of the array.\n        i, j = n - 1, n - 1\n\n        # Step 1: Find the first decreasing element when traversing from the end.\n        while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n            i -= 1\n        i -= 1  # i is now the index of the first decreasing element (nums[i] &lt; nums[i+1]).\n\n        # Step 2: If such an element was found, find the first element just larger than nums[i].\n        if i &gt;= 0:\n            while j &gt;= 0 and nums[i] &gt;= nums[j]:\n                j -= 1\n\n            # Step 3: Swap nums[i] with nums[j], which is the smallest larger element.\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # Step 4: Reverse the segment from i+1 to the end to get the smallest possible arrangement.\n        self.reverse(nums, i + 1, n - 1)\n\n# Example Usage\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [1, 2, 3]\n    solution.nextPermutation(nums)\n    print(nums)\n</code></pre> <pre><code>class Solution {\npublic:\n    // Helper function to reverse the array segment between indices i and j.\n    void reverse(vector&lt;int&gt; &amp;nums, int i, int j) {\n        // Reverse the segment in place using two pointers.\n        while(i &lt;= j) {\n            swap(nums[i++], nums[j--]);\n        }\n    }\n\n    // Function to find the next lexicographical permutation of the given array.\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(); // Get the size of the array.\n        int i = n - 1, j = n - 1;\n\n        // Step 1: Find the first decreasing element when traversing from the end.\n        while(i &gt; 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) {\n            --i;\n        }\n        --i; // Now, i is the index of the first decreasing element (nums[i] &lt; nums[i+1]).\n\n        // Step 2: If such an element was found, find the first element just larger than nums[i].\n        if(i &gt;= 0) {\n            while(j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) {\n                --j;\n            }\n            // Step 3: Swap nums[i] with nums[j], which is the smallest larger element.\n            swap(nums[i], nums[j]);\n        }\n\n        // Step 4: Reverse the segment from i+1 to the end to get the smallest possible arrangement.\n        reverse(nums, i + 1, n - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    std::vector&lt;int&gt; nums = {1, 2, 3};\n    solution.nextPermutation(nums);\n    for (int num : nums) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    fn reverse(nums: &amp;mut Vec&lt;i32&gt;, mut i: usize, mut j: usize) {\n        while i &lt;= j {\n            nums.swap(i, j);\n            i += 1;\n            j -= 1;\n        }\n    }\n\n    fn next_permutation(&amp;self, nums: &amp;mut Vec&lt;i32&gt;) {\n        let n = nums.len();\n        let (mut i, mut j) = (n - 1, n - 1);\n\n        while i &gt; 0 &amp;&amp; nums[i - 1] &gt;= nums[i] {\n            i -= 1;\n        }\n        if i &gt; 0 {\n            i -= 1;\n            while j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j] {\n                j -= 1;\n            }\n            nums.swap(i, j);\n        }\n\n        Solution::reverse(nums, i + 1, n - 1);\n    }\n}\n\nfn main() {\n    let mut nums = vec![1, 2, 3];\n    let solution = Solution;\n    solution.next_permutation(&amp;mut nums);\n    println!(\"{:?}\", nums);\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public void Reverse(List&lt;int&gt; nums, int i, int j) {\n        while (i &lt;= j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n            i++;\n            j--;\n        }\n    }\n\n    public void NextPermutation(List&lt;int&gt; nums) {\n        int n = nums.Count;\n        int i = n - 1, j = n - 1;\n\n        while (i &gt; 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) {\n            i--;\n        }\n        i--;\n\n        if (i &gt;= 0) {\n            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) {\n                j--;\n            }\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n\n        Reverse(nums, i + 1, n - 1);\n    }\n\n    public static void Main(string[] args) {\n        Solution solution = new Solution();\n        List&lt;int&gt; nums = new List&lt;int&gt; { 1, 2, 3 };\n        solution.NextPermutation(nums);\n        Console.WriteLine(string.Join(\" \", nums));\n    }\n}\n</code></pre> <pre><code>import java.util.*;\n\npublic class Solution {\n\n    public void reverse(List&lt;Integer&gt; nums, int i, int j) {\n        while (i &lt;= j) {\n            Collections.swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    public void nextPermutation(List&lt;Integer&gt; nums) {\n        int n = nums.size();\n        int i = n - 1, j = n - 1;\n\n        while (i &gt; 0 &amp;&amp; nums.get(i - 1) &gt;= nums.get(i)) {\n            i--;\n        }\n        i--;\n\n        if (i &gt;= 0) {\n            while (j &gt;= 0 &amp;&amp; nums.get(i) &gt;= nums.get(j)) {\n                j--;\n            }\n            Collections.swap(nums, i, j);\n        }\n\n        reverse(nums, i + 1, n - 1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));\n        solution.nextPermutation(nums);\n        System.out.println(nums);\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def reverse(nums: Array[Int], i: Int, j: Int): Unit = {\n        var l = i\n        var r = j\n        while (l &lt;= r) {\n            val temp = nums(l)\n            nums(l) = nums(r)\n            nums(r) = temp\n            l += 1\n            r -= 1\n        }\n    }\n\n    def nextPermutation(nums: Array[Int]): Unit = {\n        val n = nums.length\n        var i = n - 1\n        var j = n - 1\n\n        while (i &gt; 0 &amp;&amp; nums(i - 1) &gt;= nums(i)) i -= 1\n        i -= 1\n\n        if (i &gt;= 0) {\n            while (j &gt;= 0 &amp;&amp; nums(i) &gt;= nums(j)) j -= 1\n            val temp = nums(i)\n            nums(i) = nums(j)\n            nums(j) = temp\n        }\n\n        reverse(nums, i + 1, n - 1)\n    }\n\n    def main(args: Array[String]): Unit = {\n        val nums = Array(1, 2, 3)\n        nextPermutation(nums)\n        println(nums.mkString(\", \"))\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun reverse(nums: MutableList&lt;Int&gt;, i: Int, j: Int) {\n        var left = i\n        var right = j\n        while (left &lt;= right) {\n            nums[left] = nums[right].also { nums[right] = nums[left] }\n            left++\n            right--\n        }\n    }\n\n    fun nextPermutation(nums: MutableList&lt;Int&gt;) {\n        val n = nums.size\n        var i = n - 1\n        var j = n - 1\n\n        while (i &gt; 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) i--\n        i--\n\n        if (i &gt;= 0) {\n            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) j--\n            nums[i] = nums[j].also { nums[j] = nums[i] }\n        }\n\n        reverse(nums, i + 1, n - 1)\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val nums = mutableListOf(1, 2, 3)\n    solution.nextPermutation(nums)\n    println(nums)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s Solution) reverse(nums []int, i int, j int) {\n    for i &lt;= j {\n        nums[i], nums[j] = nums[j], nums[i]\n        i++\n        j--\n    }\n}\n\nfunc (s Solution) nextPermutation(nums []int) {\n    n := len(nums)\n    i, j := n-1, n-1\n\n    for i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i] {\n        i--\n    }\n    i--\n\n    if i &gt;= 0 {\n        for j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j] {\n            j--\n        }\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n\n    s.reverse(nums, i+1, n-1)\n}\n\nfunc main() {\n    solution := Solution{}\n    nums := []int{1, 2, 3}\n    solution.nextPermutation(nums)\n    fmt.Println(nums)\n}\n</code></pre> <pre><code>class Solution {\n    reverse(nums: number[], i: number, j: number): void {\n        while (i &lt;= j) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n            i++;\n            j--;\n        }\n    }\n\n    nextPermutation(nums: number[]): void {\n        const n = nums.length;\n        let i = n - 1;\n        let j = n - 1;\n\n        while (i &gt; 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) {\n            i--;\n        }\n        i--;\n\n        if (i &gt;= 0) {\n            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) {\n                j--;\n            }\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n        }\n\n        this.reverse(nums, i + 1, n - 1);\n    }\n}\n\nconst solution = new Solution();\nconst nums = [1, 2, 3];\nsolution.nextPermutation(nums);\nconsole.log(nums);\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\"Solution\", \n    methods = list(\n        reverse = function(nums, i, j) {\n            while (i &lt;= j) {\n                tmp &lt;- nums[i + 1]\n                nums[i + 1] &lt;- nums[j + 1]\n                nums[j + 1] &lt;- tmp\n                i &lt;- i + 1\n                j &lt;- j - 1\n            }\n            return(nums)\n        },\n\n        nextPermutation = function(nums) {\n            n &lt;- length(nums)\n            i &lt;- n\n            j &lt;- n\n\n            while (i &gt; 1 &amp;&amp; nums[i - 1] &gt;= nums[i]) {\n                i &lt;- i - 1\n            }\n            i &lt;- i - 1\n\n            if (i &gt;= 1) {\n                while (j &gt;= 1 &amp;&amp; nums[i] &gt;= nums[j]) {\n                j &lt;- j - 1\n                }\n                tmp &lt;- nums[i]\n                nums[i] &lt;- nums[j]\n                nums[j] &lt;- tmp\n            }\n\n            nums &lt;- reverse(nums, i + 1, n)\n            return(nums)\n        }\n    )\n)\n\nnums &lt;- c(1, 2, 3)\nsolution &lt;- Solution$new()\nnums &lt;- solution$nextPermutation(nums)\nprint(nums)\n</code></pre> <pre><code>mutable struct Solution\nend\n\nfunction reverse!(nums::Vector{Int}, i::Int, j::Int)\n    while i &lt;= j\n        nums[i], nums[j] = nums[j], nums[i]\n        i += 1\n        j -= 1\n    end\nend\n\nfunction nextPermutation!(nums::Vector{Int})\n    n = length(nums)\n    i, j = n, n\n\n    while i &gt; 1 &amp;&amp; nums[i - 1] &gt;= nums[i]\n        i -= 1\n    end\n    i -= 1\n\n    if i &gt;= 1\n        while j &gt;= 1 &amp;&amp; nums[i] &gt;= nums[j]\n            j -= 1\n        end\n        nums[i], nums[j] = nums[j], nums[i]\n    end\n\n    reverse!(nums, i + 1, n)\nend\n\nfunction main()\n    nums = [1, 2, 3]\n    nextPermutation!(nums)\n    println(nums)\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/","title":"String","text":"","tags":["Original"]},{"location":"data_structures/002_String/#longest-palindromic-substring-manachers-algorithm","title":"Longest Palindromic Substring - <code>Manacher's Algorithm</code>","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-5-longest-palindromic-substring","title":"Problem Description: LeetCode - Problem 5 - Longest Palindromic Substring","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation","title":"Solution Explanation","text":"<ol> <li>PreProcess Function:</li> <li>This function transforms the input string to handle even-length palindromes.</li> <li>It adds special characters '^' and '$' at the start and end, and '#' between each character.</li> <li> <p>Example: \"abc\" becomes \"^#a#b#c#$\"</p> </li> <li> <p>Main Algorithm:</p> </li> <li>Initialize array P to store palindrome lengths.</li> <li>Variables 'center' and 'right' keep track of the rightmost palindrome boundary.</li> <li>Iterate through the transformed string T:      a. If i is within the right boundary, use previously computed values to initialize P[i].      b. Expand palindrome around center i as far as possible.      c. Update 'center' and 'right' if a longer palindrome is found.</li> <li>Find the maximum value in P, which represents the longest palindrome.</li> <li>Calculate the start position in the original string and return the substring.</li> </ol>","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis","title":"Complexity Analysis","text":"<p>Time Complexity: <code>O(n)</code></p> <ul> <li> <p>PreProcess function: <code>O(n)</code></p> </li> <li> <p>Main loop: Although there's a nested while loop, each character is visited at most twice.</p> </li> <li> <p>The outer loop runs <code>n</code> times.</p> </li> <li> <p>The inner while loop can expand at most n times in total across all iterations of the outer loop.</p> </li> <li> <p>Finding the maximum in <code>P</code>: <code>O(n)</code></p> </li> <li> <p>Overall: <code>O(n) + O(n) + O(n) = O(n)</code></p> </li> </ul> <p>Space Complexity: <code>O(n)</code></p> <ul> <li> <p><code>T</code> (preprocessed string): <code>O(n)</code></p> </li> <li> <p><code>P</code> (palindrome length array): <code>O(n)</code></p> </li> <li> <p>Other variables use constant space</p> </li> <li> <p>Overall: <code>O(n)</code></p> </li> </ul>","tags":["Original"]},{"location":"data_structures/002_String/#key-points","title":"Key Points","text":"<ol> <li>Manacher's algorithm efficiently handles both odd and even-length palindromes by preprocessing the string.</li> <li>It reuses previously computed information to avoid unnecessary comparisons.</li> <li>The algorithm maintains a rightmost palindrome boundary to optimize expansions.</li> <li>Despite the nested loops, the linear time complexity is achieved because each character is processed at most twice.</li> </ol> <p>This algorithm significantly improves upon the naive <code>O(n^3)</code> or dynamic programming <code>O(n^2)</code> approaches, achieving linear time complexity for finding the longest palindromic substring.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solutions","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s: str) -&gt; str:\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in range(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right &gt; i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] &gt; right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in range(1, len(T) - 1):\n            if P[i] &gt; P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nclass Solution {\npublic:\n    std::string longestPalindrome(const std::string&amp; s) {\n        if (s.empty()) return \"\";\n\n        std::string T = preProcess(s);\n        std::vector&lt;int&gt; P(T.size(), 0);\n        int center = 0, right = 0;\n\n        for (int i = 1; i &lt; T.size() - 1; i++) {\n            int i_mirror = 2 * center - i;\n\n            if (right &gt; i)\n                P[i] = std::min(right - i, P[i_mirror]);\n\n            while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n                P[i]++;\n\n            if (i + P[i] &gt; right) {\n                center = i;\n                right = i + P[i];\n            }\n        }\n\n        int max_i = 0;\n        for (int i = 1; i &lt; T.size() - 1; i++) {\n            if (P[i] &gt; P[max_i])\n                max_i = i;\n        }\n\n        int start = (max_i - 1 - P[max_i]) / 2;\n        return s.substr(start, P[max_i]);\n    }\n\nprivate:\n    std::string preProcess(const std::string&amp; s) {\n        if (s.empty()) return \"^$\";\n        std::string T = \"^\";\n        for (char c : s) {\n            T += \"#\" + std::string(1, c);\n        }\n        T += \"#$\";\n        return T;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string input = \"babad\";\n    std::cout &lt;&lt; \"Longest Palindromic Substring: \" &lt;&lt; solution.longestPalindrome(input) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn longest_palindrome(&amp;self, s: &amp;str) -&gt; String {\n        let T = self.pre_process(s);\n        let mut P = vec![0; T.len()];\n        let (mut center, mut right) = (0, 0);\n\n        for i in 1..T.len() - 1 {\n            let i_mirror = 2 * center - i;\n            if right &gt; i {\n                P[i] = P[i_mirror].min(right - i);\n            }\n            while T.chars().nth(i + 1 + P[i]).unwrap() == T.chars().nth(i - 1 - P[i]).unwrap() {\n                P[i] += 1;\n            }\n            if i + P[i] &gt; right {\n                center = i;\n                right = i + P[i];\n            }\n        }\n\n        let mut max_i = 0;\n        for i in 1..T.len() - 1 {\n            if P[i] &gt; P[max_i] {\n                max_i = i;\n            }\n        }\n\n        let start = (max_i - 1 - P[max_i]) / 2;\n        s[start..start + P[max_i]].to_string()\n    }\n\n    fn pre_process(&amp;self, s: &amp;str) -&gt; String {\n        if s.is_empty() {\n            return \"^$\".to_string();\n        }\n        let mut T = String::from(\"^\");\n        for c in s.chars() {\n            T.push_str(&amp;format!(\"#{}\", c));\n        }\n        T.push_str(\"#$\");\n        T\n    }\n}\n\nfn main() {\n    let solution = Solution {};\n    let input = \"babad\";\n    println!(\"Longest Palindromic Substring: {}\", solution.longest_palindrome(input));\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public string LongestPalindrome(string s) {\n        if (string.IsNullOrEmpty(s)) return \"\";\n        string T = PreProcess(s);\n        int[] P = new int[T.Length];\n        int center = 0, right = 0;\n\n        for (int i = 1; i &lt; T.Length - 1; i++) {\n            int i_mirror = 2 * center - i;\n            if (right &gt; i) {\n                P[i] = Math.Min(right - i, P[i_mirror]);\n            }\n\n            while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {\n                P[i]++;\n            }\n\n            if (i + P[i] &gt; right) {\n                center = i;\n                right = i + P[i];\n            }\n        }\n\n        int max_i = 0;\n        for (int i = 1; i &lt; T.Length - 1; i++) {\n            if (P[i] &gt; P[max_i]) {\n                max_i = i;\n            }\n        }\n\n        int start = (max_i - 1 - P[max_i]) / 2;\n        return s.Substring(start, P[max_i]);\n    }\n\n    private string PreProcess(string s) {\n        if (string.IsNullOrEmpty(s)) return \"^$\";\n        var T = \"^\";\n        foreach (var c in s) {\n            T += \"#\" + c;\n        }\n        T += \"#$\";\n        return T;\n    }\n}\n\nclass Program {\n    static void Main() {\n        Solution solution = new Solution();\n        string input = \"babad\";\n        Console.WriteLine(\"Longest Palindromic Substring: \" + solution.LongestPalindrome(input));\n    }\n}\n</code></pre> <pre><code>public class Solution {\n\n    public String longestPalindrome(String s) {\n        if (s.isEmpty()) return \"\";\n        String T = preProcess(s);\n        int[] P = new int[T.length()];\n        int center = 0, right = 0;\n\n        for (int i = 1; i &lt; T.length() - 1; i++) {\n            int i_mirror = 2 * center - i;\n            if (right &gt; i) {\n                P[i] = Math.min(right - i, P[i_mirror]);\n            }\n\n            while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n                P[i]++;\n            }\n\n            if (i + P[i] &gt; right) {\n                center = i;\n                right = i + P[i];\n            }\n        }\n\n        int max_i = 0;\n        for (int i = 1; i &lt; T.length() - 1; i++) {\n            if (P[i] &gt; P[max_i]) {\n                max_i = i;\n            }\n        }\n\n        int start = (max_i - 1 - P[max_i]) / 2;\n        return s.substring(start, start + P[max_i]);\n    }\n\n    private String preProcess(String s) {\n        if (s.isEmpty()) return \"^$\";\n        StringBuilder T = new StringBuilder(\"^\");\n        for (char c : s.toCharArray()) {\n            T.append(\"#\").append(c);\n        }\n        T.append(\"#$\");\n        return T.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String input = \"babad\";\n        System.out.println(\"Longest Palindromic Substring: \" + solution.longestPalindrome(input));\n    }\n}\n</code></pre> <pre><code>class Solution {\n    def longestPalindrome(s: String): String = {\n        if (s.isEmpty) return \"\"\n        val T = preProcess(s)\n        val P = Array.fill(T.length)(0)\n        var center = 0\n        var right = 0\n\n        for (i &lt;- 1 until T.length - 1) {\n            val i_mirror = 2 * center - i\n            if (right &gt; i) {\n                P(i) = Math.min(right - i, P(i_mirror))\n            }\n\n            while (T(i + 1 + P(i)) == T(i - 1 - P(i))) {\n                P(i) += 1\n            }\n\n            if (i + P(i) &gt; right) {\n                center = i\n                right = i + P(i)\n            }\n        }\n\n        var max_i = 0\n        for (i &lt;- 1 until T.length - 1) {\n            if (P(i) &gt; P(max_i)) max_i = i\n        }\n\n        val start = (max_i - 1 - P(max_i)) / 2\n        s.substring(start, start + P(max_i))\n    }\n\n    private def preProcess(s: String): String = {\n        if (s.isEmpty) \"^$\"\n        else \"^\" + s.flatMap(c =&gt; \"#\" + c.toString) + \"#$\"\n    }\n}\n\nobject Main extends App {\n    val solution = new Solution()\n    val input = \"babad\"\n    println(s\"Longest Palindromic Substring: ${solution.longestPalindrome(input)}\")\n}\n</code></pre> <pre><code>class Solution {\n    fun longestPalindrome(s: String): String {\n        if (s.isEmpty()) return \"\"\n\n        val T = preProcess(s)\n        val P = IntArray(T.length)\n        var center = 0\n        var right = 0\n\n        for (i in 1 until T.length - 1) {\n            val iMirror = 2 * center - i\n            if (right &gt; i) {\n                P[i] = Math.min(right - i, P[iMirror])\n            } else {\n                P[i] = 0\n            }\n\n            // Attempt to expand palindrome centered at i\n            while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {\n                P[i]++\n            }\n\n            // If palindrome centered at i expands past right, adjust center based on expanded palindrome\n            if (i + P[i] &gt; right) {\n                center = i\n                right = i + P[i]\n            }\n        }\n\n        // Find the maximum element in P to locate the longest palindrome\n        var max_i = 0\n        for (i in 1 until T.length - 1) {\n            if (P[i] &gt; P[max_i]) {\n                max_i = i\n            }\n        }\n\n        val start = (max_i - 1 - P[max_i]) / 2\n        return s.substring(start, start + P[max_i])\n    }\n\n    private fun preProcess(s: String): String {\n        if (s.isEmpty()) return \"^$\"\n        val sb = StringBuilder(\"^\")\n        for (c in s) {\n            sb.append(\"#\").append(c)\n        }\n        sb.append(\"#$\")\n        return sb.toString()\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val input = \"babad\"\n    println(\"Longest Palindromic Substring: ${solution.longestPalindrome(input)}\")\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s Solution) longestPalindrome(str string) string {\n    if len(str) == 0 {\n        return \"\"\n    }\n\n    T := s.preProcess(str)\n    P := make([]int, len(T))\n    center, right := 0, 0\n\n    for i := 1; i &lt; len(T)-1; i++ {\n        i_mirror := 2*center - i\n        if right &gt; i {\n            P[i] = min(right-i, P[i_mirror])\n        }\n\n        for T[i+1+P[i]] == T[i-1-P[i]] {\n            P[i]++\n        }\n\n        if i+P[i] &gt; right {\n            center = i\n            right = i + P[i]\n        }\n    }\n\n    max_i := 0\n    for i := 1; i &lt; len(T)-1; i++ {\n        if P[i] &gt; P[max_i] {\n            max_i = i\n        }\n    }\n\n    start := (max_i - 1 - P[max_i]) / 2\n    return str[start : start+P[max_i]]\n}\n\nfunc (s Solution) preProcess(str string) string {\n    if len(str) == 0 {\n        return \"^$\"\n    }\n    T := \"^\"\n    for _, c := range str {\n        T += \"#\" + string(c)\n    }\n    T += \"#$\"\n    return T\n}\n\nfunc min(a, b int) int {\n    if a &lt; b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    solution := Solution{}\n    input := \"babad\"\n    fmt.Println(\"Longest Palindromic Substring:\", solution.longestPalindrome(input))\n}\n</code></pre> <pre><code>class Solution {\n    reverseList(list1: number[], list2: number[]): number[] {\n        let result: number[] = [];\n        let i = 0, j = 0;\n\n        while (i &lt; list1.length &amp;&amp; j &lt; list2.length) {\n            if (list1[i] &lt; list2[j]) {\n                result.push(list1[i]);\n                i++;\n            } else {\n                result.push(list2[j]);\n                j++;\n            }\n        }\n\n        result = result.concat(list1.slice(i));\n        result = result.concat(list2.slice(j));\n\n        return result;\n    }\n}\n\nconst main = (): void =&gt; {\n    const list1 = [1, 3, 5, 7];\n    const list2 = [2, 4, 6, 8];\n\n    const solution = new Solution();\n    console.log(\"Merged List:\", solution.reverseList(list1, list2));\n}\n\nmain();\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\n    \"Solution\",\n    methods = list(\n        reverseList = function(list1, list2) {\n            result &lt;- c()\n            i &lt;- 1\n            j &lt;- 1\n\n            while (i &lt;= length(list1) &amp;&amp; j &lt;= length(list2)) {\n                if (list1[i] &lt; list2[j]) {\n                    result &lt;- c(result, list1[i])\n                    i &lt;- i + 1\n                } else {\n                    result &lt;- c(result, list2[j])\n                    j &lt;- j + 1\n                }\n            }\n\n            result &lt;- c(result, list1[i:length(list1)], list2[j:length(list2)])\n            return(result)\n        }\n    )\n)\n\nmain &lt;- function() {\n    list1 &lt;- c(1, 3, 5, 7)\n    list2 &lt;- c(2, 4, 6, 8)\n\n    solution &lt;- Solution$new()\n    cat(\"Merged List:\", solution$reverseList(list1, list2), \"\\n\")\n}\n\nmain()\n</code></pre> <pre><code>module SolutionModule\n\nstruct Solution\nend\n\nfunction reverseList(::Solution, list1::Vector{Int}, list2::Vector{Int})::Vector{Int}\n    result = Int[]\n    i, j = 1, 1\n\n    while i &lt;= length(list1) &amp;&amp; j &lt;= length(list2)\n        if list1[i] &lt; list2[j]\n            push!(result, list1[i])\n            i += 1\n        else\n            push!(result, list2[j])\n            j += 1\n        end\n    end\n\n    append!(result, list1[i:end])\n    append!(result, list2[j:end])\n\n    result\nend\n\nfunction main()\n    list1 = [1, 3, 5, 7]\n    list2 = [2, 4, 6, 8]\n\n    solution = Solution()\n    println(\"Merged List: \", reverseList(solution, list1, list2))\nend\n\nend\n\nusing .SolutionModule\nSolutionModule.main()\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#zigzag-conversion","title":"Zigzag Conversion","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-6-zigzag-conversion","title":"Problem Description: LeetCode - Problem 6 - Zigzag Conversion","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_1","title":"Solution Explanation","text":"<p>This solution implements the zigzag pattern by iterating through each row and adding characters in the zigzag order.</p> <ol> <li>If there's only one row, return the string as is.</li> <li>Calculate the step size: 2 * numRows - 2. This represents the number of characters before the pattern repeats.</li> <li>Iterate through each row:    a. For the first and last rows, add characters at intervals of the step size.    b. For middle rows, add two characters: one from the current position, and another from (j + step - 2 * i).</li> <li>Return the constructed zigzag string.</li> </ol>","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_1","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code>, where <code>n</code> is the length of the input string. We iterate through each character once.</li> <li>Space Complexity: <code>O(n)</code> to store the result string.</li> </ul>","tags":["Original"]},{"location":"data_structures/002_String/#solutions_1","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        step, zigzag = 2 * numRows - 2, \"\"\n        for i in range(numRows):\n            for j in range(i, len(s), step):\n                zigzag += s[j]\n                if 0 &lt; i &lt; numRows - 1 and j + step - 2 * i &lt; len(s):\n                    zigzag += s[j + step - 2 * i]\n        return zigzag\n</code></pre> <pre><code>#include &lt;string&gt;\n\nclass Solution {\npublic:\n    std::string convert(const std::string &amp;s, int numRows) {\n        if (numRows == 1) return s;\n\n        std::string zigzag;\n        int step = 2 * numRows - 2;\n\n        for (int i = 0; i &lt; numRows; ++i) {\n            for (int j = i; j &lt; s.size(); j += step) {\n                zigzag += s[j];\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.size()) {\n                    zigzag += s[j + step - 2 * i];\n                }\n            }\n        }\n        return zigzag;\n    }\n};\n</code></pre> <pre><code>pub struct Solution;\n\nimpl Solution {\n    pub fn convert(s: String, numRows: i32) -&gt; String {\n        if numRows == 1 {\n            return s;\n        }\n\n        let mut zigzag = String::new();\n        let step = 2 * numRows - 2;\n\n        for i in 0..numRows {\n            let mut j = i;\n            while j &lt; s.len() as i32 {\n                zigzag.push(s.chars().nth(j as usize).unwrap());\n                if i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.len() as i32 {\n                    zigzag.push(s.chars().nth((j + step - 2 * i) as usize).unwrap());\n                }\n                j += step;\n            }\n        }\n        zigzag\n    }\n}\n</code></pre> <pre><code>public class Solution {\n    public string Convert(string s, int numRows) {\n        if (numRows == 1) return s;\n\n        string zigzag = \"\";\n        int step = 2 * numRows - 2;\n\n        for (int i = 0; i &lt; numRows; i++) {\n            for (int j = i; j &lt; s.Length; j += step) {\n                zigzag += s[j];\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.Length) {\n                    zigzag += s[j + step - 2 * i];\n                }\n            }\n        }\n        return zigzag;\n    }\n}\n</code></pre> <pre><code>class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1) return s;\n\n        StringBuilder zigzag = new StringBuilder();\n        int step = 2 * numRows - 2;\n\n        for (int i = 0; i &lt; numRows; i++) {\n            for (int j = i; j &lt; s.length(); j += step) {\n                zigzag.append(s.charAt(j));\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.length()) {\n                    zigzag.append(s.charAt(j + step - 2 * i));\n                }\n            }\n        }\n        return zigzag.toString();\n    }\n}\n</code></pre> <pre><code>class Solution {\n    def convert(s: String, numRows: Int): String = {\n        if (numRows == 1) return s\n\n        val zigzag = new StringBuilder()\n        val step = 2 * numRows - 2\n\n        for (i &lt;- 0 until numRows) {\n            for (j &lt;- i until s.length by step) {\n                zigzag.append(s(j))\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.length) {\n                    zigzag.append(s(j + step - 2 * i))\n                }\n            }\n        }\n        zigzag.toString()\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun convert(s: String, numRows: Int): String {\n        if (numRows == 1) return s\n\n        val zigzag = StringBuilder()\n        val step = 2 * numRows - 2\n\n        for (i in 0 until numRows) {\n            for (j in i until s.length step step) {\n                zigzag.append(s[j])\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.length) {\n                    zigzag.append(s[j + step - 2 * i])\n                }\n            }\n        }\n        return zigzag.toString()\n    }\n}\n</code></pre> <pre><code>package main\n\nimport \"strings\"\n\ntype Solution struct{}\n\nfunc (Solution) Convert(s string, numRows int) string {\n    if numRows == 1 {\n        return s\n    }\n\n    zigzag := strings.Builder{}\n    step := 2*numRows - 2\n\n    for i := 0; i &lt; numRows; i++ {\n        for j := i; j &lt; len(s); j += step {\n            zigzag.WriteByte(s[j])\n            if i &gt; 0 &amp;&amp; i &lt; numRows-1 &amp;&amp; j+step-2*i &lt; len(s) {\n                zigzag.WriteByte(s[j+step-2*i])\n            }\n        }\n    }\n    return zigzag.String()\n}\n</code></pre> <pre><code>class Solution {\n    convert(s: string, numRows: number): string {\n        if (numRows === 1) return s;\n\n        let zigzag = \"\";\n        const step = 2 * numRows - 2;\n\n        for (let i = 0; i &lt; numRows; i++) {\n            for (let j = i; j &lt; s.length; j += step) {\n                zigzag += s[j];\n                if (i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + step - 2 * i &lt; s.length) {\n                    zigzag += s[j + step - 2 * i];\n                }\n            }\n        }\n        return zigzag;\n    }\n}\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\n    \"Solution\",\n    methods = list(\n        convert = function(s, numRows) {\n            if (numRows == 1) return(s)\n\n            zigzag &lt;- \"\"\n            step &lt;- 2 * numRows - 2\n\n            for (i in seq_len(numRows)) {\n                for (j in seq(i, nchar(s), by = step)) {\n                    zigzag &lt;- paste0(zigzag, substr(s, j, j))\n                    if (i &gt; 1 &amp;&amp; i &lt; numRows &amp;&amp; j + step - 2 * i &lt;= nchar(s)) {\n                        zigzag &lt;- paste0(zigzag, substr(s, j + step - 2 * i, j + step - 2 * i))\n                    }\n                }\n            }\n            zigzag\n        }\n    )\n)\n</code></pre> <pre><code>module SolutionModule\n\nstruct Solution\nend\n\nfunction reverseList(::Solution, s::String, numRows::Int)::String\n    if numRows == 1\n        return s\n    end\n\n    zigzag = \"\"\n    step = 2 * numRows - 2\n\n    for i in 1:numRows\n        for j in i:step:length(s)\n            zigzag *= s[j]\n            if i &gt; 1 &amp;&amp; i &lt; numRows &amp;&amp; j + step - 2 * i &lt;= length(s)\n                zigzag *= s[j + step - 2 * i]\n            end\n        end\n    end\n    return zigzag\nend\n\nend\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#string-to-integer-atoi","title":"String to Integer (<code>atoi</code>)","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-8-string-to-integer-atoi","title":"Problem Description: LeetCode - Problem 8 - String to Integer (<code>atoi</code>)","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_2","title":"Solution Explanation","text":"<ol> <li>Skip leading whitespace.</li> <li>Check for a sign (+ or -).</li> <li>Iterate through digits, building the result:    a. Check for overflow before adding each digit.    b. If overflow would occur, return INT_MAX or INT_MIN based on the sign.</li> <li>Apply the sign to the result and return.</li> </ol>","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_2","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: <code>O(n)</code>, where <code>n</code> is the length of the input string. We iterate through the string once.</li> <li>Space Complexity: <code>O(1)</code>, as we only use a constant amount of extra space.</li> </ul>","tags":["Original"]},{"location":"data_structures/002_String/#solutions_2","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>import sys\n\nclass Solution:\n    def myAtoi(self, str: str) -&gt; int:\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        #INT_MAX =  2147483647\n        #INT_MIN = -2147483648\n        INT_MAX = sys.maxsize\n        INT_MIN = -sys.maxsize - 1\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i &lt; len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i &lt; len(str) and '0' &lt;= str[i] &lt;= '9':\n            if result &gt; (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign &gt; 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result\n</code></pre> <pre><code>#include &lt;string&gt;\n#include &lt;climits&gt;\n\nclass Solution {\npublic:\n    int myAtoi(const std::string &amp;s) {\n        int i = 0, sign = 1;\n        long result = 0;\n\n        // Skip whitespaces\n        while (i &lt; s.length() &amp;&amp; s[i] == ' ') i++;\n\n        // Check for optional sign\n        if (i &lt; s.length() &amp;&amp; (s[i] == '+' || s[i] == '-')) {\n            sign = (s[i] == '-') ? -1 : 1;\n            i++;\n        }\n\n        // Convert digits to integer\n        while (i &lt; s.length() &amp;&amp; isdigit(s[i])) {\n            result = result * 10 + (s[i++] - '0');\n            if (result * sign &gt;= INT_MAX) return INT_MAX;\n            if (result * sign &lt;= INT_MIN) return INT_MIN;\n        }\n\n        return result * sign;\n    }\n};\n</code></pre> <pre><code>pub struct Solution;\n\nimpl Solution {\n    pub fn my_atoi(s: String) -&gt; i32 {\n        let mut chars = s.chars().peekable();\n        let mut result: i64 = 0;\n        let mut sign = 1;\n        let mut started = false;\n\n        while let Some(&amp;ch) = chars.peek() {\n            if !started &amp;&amp; ch == ' ' {\n                chars.next();\n                continue;\n            }\n            if !started &amp;&amp; (ch == '-' || ch == '+') {\n                sign = if ch == '-' { -1 } else { 1 };\n                chars.next();\n                started = true;\n                continue;\n            }\n            if let Some(digit) = ch.to_digit(10) {\n                result = result * 10 + digit as i64;\n                if result * sign &gt; i32::MAX as i64 {\n                    return i32::MAX;\n                }\n                if result * sign &lt; i32::MIN as i64 {\n                    return i32::MIN;\n                }\n                chars.next();\n                started = true;\n            } else {\n                break;\n            }\n        }\n\n        (result * sign) as i32\n    }\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public int MyAtoi(string s) {\n        int i = 0, sign = 1;\n        long result = 0;\n\n        while (i &lt; s.Length &amp;&amp; s[i] == ' ') i++;\n\n        if (i &lt; s.Length &amp;&amp; (s[i] == '+' || s[i] == '-')) {\n            sign = (s[i] == '-') ? -1 : 1;\n            i++;\n        }\n\n        while (i &lt; s.Length &amp;&amp; Char.IsDigit(s[i])) {\n            result = result * 10 + (s[i++] - '0');\n            if (result * sign &gt;= int.MaxValue) return int.MaxValue;\n            if (result * sign &lt;= int.MinValue) return int.MinValue;\n        }\n\n        return (int)(result * sign);\n    }\n}\n</code></pre> <pre><code>class Solution {\n    public int myAtoi(String s) {\n        int i = 0, sign = 1;\n        long result = 0;\n\n        while (i &lt; s.length() &amp;&amp; s.charAt(i) == ' ') i++;\n\n        if (i &lt; s.length() &amp;&amp; (s.charAt(i) == '+' || s.charAt(i) == '-')) {\n            sign = (s.charAt(i) == '-') ? -1 : 1;\n            i++;\n        }\n\n        while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) {\n            result = result * 10 + (s.charAt(i++) - '0');\n            if (result * sign &gt;= Integer.MAX_VALUE) return Integer.MAX_VALUE;\n            if (result * sign &lt;= Integer.MIN_VALUE) return Integer.MIN_VALUE;\n        }\n\n        return (int)(result * sign);\n    }\n}\n</code></pre> <pre><code>class Solution {\n    def myAtoi(s: String): Int = {\n        var i = 0\n        var sign = 1\n        var result: Long = 0\n\n        while (i &lt; s.length &amp;&amp; s(i) == ' ') i += 1\n\n        if (i &lt; s.length &amp;&amp; (s(i) == '+' || s(i) == '-')) {\n            sign = if (s(i) == '-') -1 else 1\n            i += 1\n        }\n\n        while (i &lt; s.length &amp;&amp; s(i).isDigit) {\n            result = result * 10 + (s(i) - '0')\n            if (result * sign &gt;= Int.MaxValue) return Int.MaxValue\n            if (result * sign &lt;= Int.MinValue) return Int.MinValue\n            i += 1\n        }\n\n        (result * sign).toInt\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun myAtoi(s: String): Int {\n        var i = 0\n        var sign = 1\n        var result: Long = 0\n\n        while (i &lt; s.length &amp;&amp; s[i] == ' ') i++\n\n        if (i &lt; s.length &amp;&amp; (s[i] == '+' || s[i] == '-')) {\n            sign = if (s[i] == '-') -1 else 1\n            i++\n        }\n\n        while (i &lt; s.length &amp;&amp; s[i].isDigit()) {\n            result = result * 10 + (s[i++] - '0')\n            if (result * sign &gt;= Int.MAX_VALUE) return Int.MAX_VALUE\n            if (result * sign &lt;= Int.MIN_VALUE) return Int.MIN_VALUE\n        }\n\n        return (result * sign).toInt()\n    }\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"math\"\n    \"unicode\"\n)\n\ntype Solution struct{}\n\nfunc (Solution) MyAtoi(s string) int {\n    i, sign := 0, 1\n    var result int64 = 0\n\n    // Skip whitespaces\n    for i &lt; len(s) &amp;&amp; s[i] == ' ' {\n        i++\n    }\n\n    // Check for optional sign\n    if i &lt; len(s) &amp;&amp; (s[i] == '-' || s[i] == '+') {\n        if s[i] == '-' {\n            sign = -1\n        }\n        i++\n    }\n\n    // Convert digits to integer\n    for i &lt; len(s) &amp;&amp; unicode.IsDigit(rune(s[i])) {\n        result = result*10 + int64(s[i]-'0')\n        if result*int64(sign) &gt; math.MaxInt32 {\n            return math.MaxInt32\n        }\n        if result*int64(sign) &lt; math.MinInt32 {\n            return math.MinInt32\n        }\n        i++\n    }\n\n    return int(result * int64(sign))\n}\n</code></pre> <pre><code>class Solution {\n    myAtoi(s: string): number {\n        let i = 0;\n        let sign = 1;\n        let result = 0;\n\n        while (i &lt; s.length &amp;&amp; s[i] === ' ') i++;\n\n        if (i &lt; s.length &amp;&amp; (s[i] === '+' || s[i] === '-')) {\n            sign = s[i] === '-' ? -1 : 1;\n            i++;\n        }\n\n        while (i &lt; s.length &amp;&amp; /\\d/.test(s[i])) {\n            result = result * 10 + (s[i].charCodeAt(0) - '0'.charCodeAt(0));\n            if (result * sign &gt; 2 ** 31 - 1) return 2 ** 31 - 1;\n            if (result * sign &lt; -(2 ** 31)) return -(2 ** 31);\n            i++;\n        }\n\n        return result * sign;\n    }\n}\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\n    \"Solution\",\n    methods = list(\n        my_atoi = function(s) {\n            i &lt;- 1\n            sign &lt;- 1\n            result &lt;- 0\n\n            while (i &lt;= nchar(s) &amp;&amp; substr(s, i, i) == \" \") {\n                i &lt;- i + 1\n            }\n\n            if (i &lt;= nchar(s) &amp;&amp; (substr(s, i, i) == \"+\" || substr(s, i, i) == \"-\")) {\n                sign &lt;- ifelse(substr(s, i, i) == \"-\", -1, 1)\n                i &lt;- i + 1\n            }\n\n            while (i &lt;= nchar(s) &amp;&amp; grepl(\"[0-9]\", substr(s, i, i))) {\n                result &lt;- result * 10 + as.numeric(substr(s, i, i))\n                if (result * sign &gt;= .Machine$integer.max) return(.Machine$integer.max)\n                if (result * sign &lt;= -.Machine$integer.max) return(-.Machine$integer.max)\n                i &lt;- i + 1\n            }\n\n            result * sign\n        }\n    )\n)\n</code></pre> <pre><code>module SolutionModule\n\nstruct Solution\nend\n\nfunction my_atoi(::Solution, s::String)::Int\n    i = 1\n    sign = 1\n    result = 0\n\n    while i &lt;= length(s) &amp;&amp; s[i] == ' '\n        i += 1\n    end\n\n    if i &lt;= length(s) &amp;&amp; (s[i] == '+' || s[i] == '-')\n        sign = s[i] == '-' ? -1 : 1\n        i += 1\n    end\n\n    while i &lt;= length(s) &amp;&amp; isdigit(s[i])\n        result = result * 10 + (s[i] - '0')\n        if result * sign &gt;= typemax(Int32)\n            return typemax(Int32)\n        end\n        if result * sign &lt;= typemin(Int32)\n            return typemin(Int32)\n        end\n        i += 1\n    end\n\n    return result * sign\nend\n\nend\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#longest-common-prefix","title":"Longest Common Prefix","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-14-longest-common-prefix","title":"Problem Description: LeetCode - Problem 14 - Longest Common Prefix","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_3","title":"Solution Explanation","text":"<p>This solution finds the longest common prefix among an array of strings.</p> <ol> <li>If the array is empty, return an empty string.</li> <li>Iterate through characters of the first string:    a. Compare this character with the corresponding character in all other strings.    b. If a mismatch is found or we reach the end of any string, return the prefix up to this point.</li> <li>If we complete the loop, the entire first string is the common prefix.</li> </ol>","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_3","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: <code>O(S)</code>, where <code>S</code> is the sum of all characters in all strings. In the worst case, we compare every character of every string.</li> <li>Space Complexity: <code>O(1)</code>, as we only use a constant amount of extra space.</li> </ul>","tags":["Original"]},{"location":"data_structures/002_String/#solutions_3","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            for string in strs[1:]:\n                if i &gt;= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    std::string longestCommonPrefix(const std::vector&lt;std::string&gt;&amp; strs) {\n        if (strs.empty()) return \"\";\n        std::string prefix = strs[0];\n        for (int i = 1; i &lt; strs.size(); ++i) {\n            while (strs[i].find(prefix) != 0) {\n                prefix = prefix.substr(0, prefix.size() - 1);\n                if (prefix.empty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::vector&lt;std::string&gt; strs = {\"flower\", \"flow\", \"flight\"};\n    std::cout &lt;&lt; \"Longest Common Prefix: \" &lt;&lt; solution.longestCommonPrefix(strs) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn longest_common_prefix(strs: Vec&lt;String&gt;) -&gt; String {\n        if strs.is_empty() {\n            return \"\".to_string();\n        }\n        let mut prefix = strs[0].clone();\n        for s in &amp;strs[1..] {\n            while !s.starts_with(&amp;prefix) {\n                prefix.pop();\n                if prefix.is_empty() {\n                    return \"\".to_string();\n                }\n            }\n        }\n        prefix\n    }\n}\n\nfn main() {\n    let strs = vec![\"flower\".to_string(), \"flow\".to_string(), \"flight\".to_string()];\n    let result = Solution::longest_common_prefix(strs);\n    println!(\"Longest Common Prefix: {}\", result);\n}\n</code></pre> <pre><code>class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) return \"\";\n        String prefix = strs[0];\n        for (int i = 1; i &lt; strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] strs = {\"flower\", \"flow\", \"flight\"};\n        System.out.println(\"Longest Common Prefix: \" + solution.longestCommonPrefix(strs));\n    }\n}\n</code></pre> <pre><code>class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) return \"\";\n        String prefix = strs[0];\n        for (int i = 1; i &lt; strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] strs = {\"flower\", \"flow\", \"flight\"};\n        System.out.println(\"Longest Common Prefix: \" + solution.longestCommonPrefix(strs));\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def longestCommonPrefix(strs: Array[String]): String = {\n        if (strs.isEmpty) return \"\"\n        var prefix = strs(0)\n        for (s &lt;- strs.tail) {\n            while (!s.startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length - 1)\n                if (prefix.isEmpty) return \"\"\n            }\n        }\n        prefix\n    }\n\n    def main(args: Array[String]): Unit = {\n        val strs = Array(\"flower\", \"flow\", \"flight\")\n        println(s\"Longest Common Prefix: ${longestCommonPrefix(strs)}\")\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun longestCommonPrefix(strs: Array&lt;String&gt;): String {\n        if (strs.isEmpty()) return \"\"\n        var prefix = strs[0]\n        for (i in 1 until strs.size) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length - 1)\n                if (prefix.isEmpty()) return \"\"\n            }\n        }\n        return prefix\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val strs = arrayOf(\"flower\", \"flow\", \"flight\")\n    println(\"Longest Common Prefix: ${solution.longestCommonPrefix(strs)}\")\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype Solution struct{}\n\nfunc (s Solution) LongestCommonPrefix(strs []string) string {\n    if len(strs) == 0 {\n        return \"\"\n    }\n    prefix := strs[0]\n    for i := 1; i &lt; len(strs); i++ {\n        for !strings.HasPrefix(strs[i], prefix) {\n            prefix = prefix[:len(prefix)-1]\n            if len(prefix) == 0 {\n                return \"\"\n            }\n        }\n    }\n    return prefix\n}\n\nfunc main() {\n    solution := Solution{}\n    strs := []string{\"flower\", \"flow\", \"flight\"}\n    fmt.Println(\"Longest Common Prefix:\", solution.LongestCommonPrefix(strs))\n}\n</code></pre> <pre><code>class Solution {\n    longestCommonPrefix(strs: string[]): string {\n        if (strs.length === 0) return \"\";\n        let prefix = strs[0];\n        for (let i = 1; i &lt; strs.length; i++) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length - 1);\n                if (prefix === \"\") return \"\";\n            }\n        }\n        return prefix;\n    }\n}\n\nfunction main() {\n    const solution = new Solution();\n    const strs = [\"flower\", \"flow\", \"flight\"];\n    console.log(`Longest Common Prefix: ${solution.longestCommonPrefix(strs)}`);\n}\n\nmain();\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\"Solution\", methods = list(\n        longestCommonPrefix = function(strs) {\n            if (length(strs) == 0) return(\"\")\n            prefix &lt;- strs[1]\n            for (i in 2:length(strs)) {\n                while (substr(strs[i], 1, nchar(prefix)) != prefix) {\n                    prefix &lt;- substr(prefix, 1, nchar(prefix) - 1)\n                    if (prefix == \"\") return(\"\")\n                }\n            }\n            return(prefix)\n        }\n    )\n)\n\nmain &lt;- function() {\n    solution &lt;- Solution$new()\n    strs &lt;- c(\"flower\", \"flow\", \"flight\")\n    cat(\"Longest Common Prefix:\", solution$longestCommonPrefix(strs), \"\\n\")\n}\n\nmain()\n</code></pre> <pre><code>struct Solution\nend\n\nfunction longest_common_prefix(strs::Vector{String})::String\n    if isempty(strs)\n        return \"\"\n    end\n    prefix = strs[1]\n    for i in 2:length(strs)\n        while !startswith(strs[i], prefix)\n            prefix = prefix[1:end-1]\n            if isempty(prefix)\n                return \"\"\n            end\n        end\n    end\n    return prefix\nend\n\nfunction main()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    prefix = longest_common_prefix(strs)\n    println(\"Longest Common Prefix: \", prefix)\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#implement-strstr-knuth-morris-platt-kmp-algorithm","title":"Implement <code>strStr()</code> - <code>Knuth-Morris-Platt (KMP) Algorithm</code>","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-28-implement-strstr","title":"Problem Description: LeetCode - Problem 28 - Implement <code>strStr()</code>","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_4","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_4","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_4","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n\n        return self.KMP(haystack, needle)\n\n    def KMP(self, text: str, pattern: str) -&gt; int:\n        prefix = self.getPrefix(pattern)\n        j = -1\n        for i in range(len(text)):\n            while j &gt; -1 and pattern[j + 1] != text[i]:\n                j = prefix[j]\n            if pattern[j + 1] == text[i]:\n                j += 1\n            if j == len(pattern) - 1:\n                return i - j\n        return -1\n\n    def getPrefix(self, pattern: str) -&gt; List[int]:\n        prefix = [-1] * len(pattern)\n        j = -1\n        for i in range(1, len(pattern)):\n            while j &gt; -1 and pattern[j + 1] != pattern[i]:\n                j = prefix[j]\n            if pattern[j + 1] == pattern[i]:\n                j += 1\n            prefix[i] = j\n        return prefix\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    int strStr(const std::string&amp; haystack, const std::string&amp; needle) {\n        if (needle.empty()) return 0;\n        return KMP(haystack, needle);\n    }\n\nprivate:\n    int KMP(const std::string&amp; text, const std::string&amp; pattern) {\n        std::vector&lt;int&gt; prefix = getPrefix(pattern);\n        int j = -1;\n\n        for (size_t i = 0; i &lt; text.size(); ++i) {\n            while (j &gt; -1 &amp;&amp; pattern[j + 1] != text[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] == text[i]) {\n                j++;\n            }\n            if (j == static_cast&lt;int&gt;(pattern.size()) - 1) {\n                return i - j;\n            }\n        }\n        return -1;\n    }\n\n    std::vector&lt;int&gt; getPrefix(const std::string&amp; pattern) {\n        std::vector&lt;int&gt; prefix(pattern.size(), -1);\n        int j = -1;\n\n        for (size_t i = 1; i &lt; pattern.size(); ++i) {\n            while (j &gt; -1 &amp;&amp; pattern[j + 1] != pattern[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] == pattern[i]) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n        return prefix;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string haystack = \"hello\";\n    std::string needle = \"ll\";\n    int result = solution.strStr(haystack, needle);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result &lt;&lt; std::endl; // Output: 2\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn strStr(haystack: String, needle: String) -&gt; i32 {\n        if needle.is_empty() {\n            return 0;\n        }\n        Self::kmp(&amp;haystack, &amp;needle)\n    }\n\n    fn kmp(text: &amp;str, pattern: &amp;str) -&gt; i32 {\n        let prefix = Self::get_prefix(pattern);\n        let mut j = -1;\n\n        for (i, c) in text.chars().enumerate() {\n            while j &gt;= 0 &amp;&amp; pattern.chars().nth((j + 1) as usize) != Some(c) {\n                j = prefix[j as usize];\n            }\n            if pattern.chars().nth((j + 1) as usize) == Some(c) {\n                j += 1;\n            }\n            if j == (pattern.len() as i32) - 1 {\n                return i as i32 - j;\n            }\n        }\n        -1\n    }\n\n    fn get_prefix(pattern: &amp;str) -&gt; Vec&lt;i32&gt; {\n        let mut prefix = vec![-1; pattern.len()];\n        let mut j = -1;\n\n        for i in 1..pattern.len() {\n            while j &gt;= 0 &amp;&amp; pattern.chars().nth((j + 1) as usize) != pattern.chars().nth(i) {\n                j = prefix[j as usize];\n            }\n            if pattern.chars().nth((j + 1) as usize) == pattern.chars().nth(i) {\n                j += 1;\n            }\n            prefix[i] = j;\n        }\n        prefix\n    }\n}\n\nfn main() {\n    let haystack = String::from(\"hello\");\n    let needle = String::from(\"ll\");\n    let result = Solution::strStr(haystack, needle);\n    println!(\"Result: {}\", result); // Output: 2\n}\n</code></pre> <pre><code>using System;\n\nclass Solution {\n    public int StrStr(string haystack, string needle) {\n        if (string.IsNullOrEmpty(needle)) return 0;\n        return KMP(haystack, needle);\n    }\n\n    private int KMP(string text, string pattern) {\n        int[] prefix = GetPrefix(pattern);\n        int j = -1;\n\n        for (int i = 0; i &lt; text.Length; i++) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] != text[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] == text[i]) {\n                j++;\n            }\n            if (j == pattern.Length - 1) {\n                return i - j;\n            }\n        }\n        return -1;\n    }\n\n    private int[] GetPrefix(string pattern) {\n        int[] prefix = new int[pattern.Length];\n        for (int i = 0; i &lt; pattern.Length; i++) prefix[i] = -1;\n        int j = -1;\n\n        for (int i = 1; i &lt; pattern.Length; i++) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] != pattern[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] == pattern[i]) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n        return prefix;\n    }\n}\n\nclass Program {\n    static void Main() {\n        Solution solution = new Solution();\n        string haystack = \"hello\";\n        string needle = \"ll\";\n        int result = solution.StrStr(haystack, needle);\n        Console.WriteLine($\"Result: {result}\"); // Output: 2\n    }\n}\n</code></pre> <pre><code>class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) return 0;\n        return KMP(haystack, needle);\n    }\n\n    private int KMP(String text, String pattern) {\n        int[] prefix = getPrefix(pattern);\n        int j = -1;\n\n        for (int i = 0; i &lt; text.length(); i++) {\n            while (j &gt;= 0 &amp;&amp; pattern.charAt(j + 1) != text.charAt(i)) {\n                j = prefix[j];\n            }\n            if (pattern.charAt(j + 1) == text.charAt(i)) {\n                j++;\n            }\n            if (j == pattern.length() - 1) {\n                return i - j;\n            }\n        }\n        return -1;\n    }\n\n    private int[] getPrefix(String pattern) {\n        int[] prefix = new int[pattern.length()];\n        for (int i = 0; i &lt; prefix.length; i++) prefix[i] = -1;\n        int j = -1;\n\n        for (int i = 1; i &lt; pattern.length(); i++) {\n            while (j &gt;= 0 &amp;&amp; pattern.charAt(j + 1) != pattern.charAt(i)) {\n                j = prefix[j];\n            }\n            if (pattern.charAt(j + 1) == pattern.charAt(i)) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n        return prefix;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String haystack = \"hello\";\n        String needle = \"ll\";\n        int result = solution.strStr(haystack, needle);\n        System.out.println(\"Result: \" + result); // Output: 2\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def strStr(haystack: String, needle: String): Int = {\n        if (needle.isEmpty) return 0\n        KMP(haystack, needle)\n    }\n\n    private def KMP(text: String, pattern: String): Int = {\n        val prefix = getPrefix(pattern)\n        var j = -1\n\n        for (i &lt;- text.indices) {\n            while (j &gt;= 0 &amp;&amp; pattern.charAt(j + 1) != text.charAt(i)) {\n                j = prefix(j)\n            }\n            if (pattern.charAt(j + 1) == text.charAt(i)) {\n                j += 1\n            }\n            if (j == pattern.length - 1) {\n                return i - j\n            }\n        }\n        -1\n    }\n\n    private def getPrefix(pattern: String): Array[Int] = {\n        val prefix = Array.fill(pattern.length)(-1)\n        var j = -1\n\n        for (i &lt;- 1 until pattern.length) {\n            while (j &gt;= 0 &amp;&amp; pattern.charAt(j + 1) != pattern.charAt(i)) {\n                j = prefix(j)\n            }\n            if (pattern.charAt(j + 1) == pattern.charAt(i)) {\n                j += 1\n            }\n            prefix(i) = j\n        }\n        prefix\n    }\n\n    def main(args: Array[String]): Unit = {\n        val haystack = \"hello\"\n        val needle = \"ll\"\n        val result = strStr(haystack, needle)\n        println(s\"Result: $result\") // Output: 2\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun strStr(haystack: String, needle: String): Int {\n        if (needle.isEmpty()) return 0\n        return kmp(haystack, needle)\n    }\n\n    private fun kmp(text: String, pattern: String): Int {\n        val prefix = getPrefix(pattern)\n        var j = -1\n\n        for (i in text.indices) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] != text[i]) {\n                j = prefix[j]\n            }\n            if (pattern[j + 1] == text[i]) {\n                j++\n            }\n            if (j == pattern.length - 1) {\n                return i - j\n            }\n        }\n        return -1\n    }\n\n    private fun getPrefix(pattern: String): IntArray {\n        val prefix = IntArray(pattern.length) { -1 }\n        var j = -1\n\n        for (i in 1 until pattern.length) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] != pattern[i]) {\n                j = prefix[j]\n            }\n            if (pattern[j + 1] == pattern[i]) {\n                j++\n            }\n            prefix[i] = j\n        }\n        return prefix\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val haystack = \"hello\"\n    val needle = \"ll\"\n    val result = solution.strStr(haystack, needle)\n    println(\"Result: $result\") // Output: 2\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) strStr(haystack string, needle string) int {\n    if len(needle) == 0 {\n        return 0\n    }\n    return s.kmp(haystack, needle)\n}\n\nfunc (s *Solution) kmp(text string, pattern string) int {\n    prefix := s.getPrefix(pattern)\n    j := -1\n\n    for i := 0; i &lt; len(text); i++ {\n        for j &gt;= 0 &amp;&amp; pattern[j+1] != text[i] {\n            j = prefix[j]\n        }\n        if pattern[j+1] == text[i] {\n            j++\n        }\n        if j == len(pattern)-1 {\n            return i - j\n        }\n    }\n    return -1\n}\n\nfunc (s *Solution) getPrefix(pattern string) []int {\n    prefix := make([]int, len(pattern))\n    for i := range prefix {\n        prefix[i] = -1\n    }\n    j := -1\n\n    for i := 1; i &lt; len(pattern); i++ {\n        for j &gt;= 0 &amp;&amp; pattern[j+1] != pattern[i] {\n            j = prefix[j]\n        }\n        if pattern[j+1] == pattern[i] {\n            j++\n        }\n        prefix[i] = j\n    }\n    return prefix\n}\n\nfunc main() {\n    solution := &amp;Solution{}\n    haystack := \"hello\"\n    needle := \"ll\"\n    result := solution.strStr(haystack, needle)\n    fmt.Printf(\"Result: %d\\n\", result) // Output: 2\n}\n</code></pre> <pre><code>class Solution {\n    strStr(haystack: string, needle: string): number {\n        if (needle.length === 0) return 0;\n        return this.kmp(haystack, needle);\n    }\n\n    private kmp(text: string, pattern: string): number {\n        const prefix = this.getPrefix(pattern);\n        let j = -1;\n\n        for (let i = 0; i &lt; text.length; i++) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] !== text[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] === text[i]) {\n                j++;\n            }\n            if (j === pattern.length - 1) {\n                return i - j;\n            }\n        }\n        return -1;\n    }\n\n    private getPrefix(pattern: string): number[] {\n        const prefix = new Array(pattern.length).fill(-1);\n        let j = -1;\n\n        for (let i = 1; i &lt; pattern.length; i++) {\n            while (j &gt;= 0 &amp;&amp; pattern[j + 1] !== pattern[i]) {\n                j = prefix[j];\n            }\n            if (pattern[j + 1] === pattern[i]) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n        return prefix;\n    }\n}\n\nconst solution = new Solution();\nconst haystack = \"hello\";\nconst needle = \"ll\";\nconst result = solution.strStr(haystack, needle);\nconsole.log(`Result: ${result}`); // Output: 2\n</code></pre> <pre><code>strStr &lt;- function(haystack, needle) {\n    if (nchar(needle) == 0) return(0)\n    return(KMP(haystack, needle))\n}\n\nKMP &lt;- function(text, pattern) {\n    prefix &lt;- getPrefix(pattern)\n    j &lt;- -1\n\n    for (i in seq_along(text)) {\n        while (j &gt;= 0 &amp;&amp; substr(pattern, j + 2, j + 2) != substr(text, i, i)) {\n        j &lt;- prefix[j + 1]\n        }\n        if (substr(pattern, j + 2, j + 2) == substr(text, i, i)) {\n        j &lt;- j + 1\n        }\n        if (j == nchar(pattern) - 1) {\n        return(i - j - 1)\n        }\n    }\n    return(-1)\n}\n\ngetPrefix &lt;- function(pattern) {\n    prefix &lt;- rep(-1, nchar(pattern))\n    j &lt;- -1\n\n    for (i in 2:nchar(pattern)) {\n        while (j &gt;= 0 &amp;&amp; substr(pattern, j + 2, j + 2) != substr(pattern, i, i)) {\n            j &lt;- prefix[j + 1]\n        }\n        if (substr(pattern, j + 2, j + 2) == substr(pattern, i, i)) {\n            j &lt;- j + 1\n        }\n        prefix[i] &lt;- j\n    }\n    return(prefix)\n}\n\n# Example usage\nhaystack &lt;- \"hello\"\nneedle &lt;- \"ll\"\nresult &lt;- strStr(haystack, needle)\ncat(\"Result:\", result, \"\\n\") # Output: 2\n</code></pre> <pre><code>module KMPStringMatching\n\nexport strStr\n\nfunction strStr(haystack::String, needle::String)\n    if isempty(needle) return 0 end\n    return kmp(haystack, needle)\nend\n\nfunction kmp(text::String, pattern::String)\n    prefix = getPrefix(pattern)\n    j = -1\n\n    for i in 1:length(text)\n        while j &gt;= 0 &amp;&amp; pattern[j + 1] != text[i]\n            j = prefix[j + 1]\n        end\n        if pattern[j + 1] == text[i]\n            j += 1\n        end\n        if j == length(pattern) - 1\n            return i - j - 1\n        end\n    end\n    return -1\nend\n\nfunction getPrefix(pattern::String)\n    prefix = fill(-1, length(pattern))\n    j = -1\n\n    for i in 2:length(pattern)\n        while j &gt;= 0 &amp;&amp; pattern[j + 1] != pattern[i]\n            j = prefix[j + 1]\n        end\n        if pattern[j + 1] == pattern[i]\n            j += 1\n        end\n        prefix[i] = j\n    end\n    return prefix\nend\n\nend # module\n\nusing .KMPStringMatching\n\n# Example usage\nhaystack = \"hello\"\nneedle = \"ll\"\nresult = strStr(haystack, needle)\nprintln(\"Result: \", result) # Output: 2\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#add-binary","title":"Add Binary","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-67-add-binary","title":"Problem Description: LeetCode - Problem 67 - Add Binary","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_5","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_5","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_5","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    # @param a, a string\n    # @param b, a string\n    # @return a string\n    def addBinary(self, a: str, b: str) -&gt; str:\n        result, carry, val = \"\", 0, 0\n        for i in range(max(len(a), len(b))):\n            val = carry\n            if i &lt; len(a):\n                val += int(a[-(i + 1)])\n            if i &lt; len(b):\n                val += int(b[-(i + 1)])\n            carry, val = divmod(val, 2)\n            result += str(val)\n        if carry:\n            result += str(carry)\n        return result[::-1]\n\n#from itertools import izip_longest\n#\n#\n#class Solution:\n#    def addBinary(self, a: str, b: str) -&gt; str:\n#        \"\"\"\n#        :type a: str\n#        :type b: str\n#        :rtype: str\n#        \"\"\"\n#        result = \"\"\n#        carry = 0\n#        for x, y in izip_longest(reversed(a), reversed(b), fillvalue=\"0\"):\n#            carry, remainder = divmod(int(x)+int(y)+carry, 2)\n#            result += str(remainder)\n#        \n#        if carry:\n#            result += str(carry)\n#        \n#        return result[::-1]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    std::string addBinary(std::string a, std::string b) {\n        std::string result;\n        int carry = 0;\n\n        int maxLength = std::max(a.length(), b.length());\n        for (int i = 0; i &lt; maxLength; ++i) {\n            int val = carry;\n            if (i &lt; a.length()) val += a[a.length() - 1 - i] - '0';\n            if (i &lt; b.length()) val += b[b.length() - 1 - i] - '0';\n            carry = val / 2;\n            result += (val % 2) + '0';\n        }\n        if (carry) result += '1';\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string a = \"1010\";\n    std::string b = \"1011\";\n    std::string result = solution.addBinary(a, b);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result &lt;&lt; std::endl; // Output: 10101\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn add_binary(a: String, b: String) -&gt; String {\n        let mut result = String::new();\n        let mut carry = 0;\n\n        let max_length = a.len().max(b.len());\n        for i in 0..max_length {\n            let mut val = carry;\n            if i &lt; a.len() {\n                val += a.chars().rev().nth(i).unwrap().to_digit(10).unwrap();\n            }\n            if i &lt; b.len() {\n                val += b.chars().rev().nth(i).unwrap().to_digit(10).unwrap();\n            }\n            carry = val / 2;\n            result.push(char::from_digit(val % 2, 10).unwrap());\n        }\n        if carry != 0 {\n            result.push('1');\n        }\n        result.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let a = String::from(\"1010\");\n    let b = String::from(\"1011\");\n    let result = solution.add_binary(a, b);\n    println!(\"Result: {}\", result); // Output: 10101\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public string AddBinary(string a, string b) {\n        string result = \"\";\n        int carry = 0;\n\n        int maxLength = Math.Max(a.Length, b.Length);\n        for (int i = 0; i &lt; maxLength; i++) {\n            int val = carry;\n            if (i &lt; a.Length) val += a[a.Length - 1 - i] - '0';\n            if (i &lt; b.Length) val += b[b.Length - 1 - i] - '0';\n            carry = val / 2;\n            result += (val % 2).ToString();\n        }\n        if (carry &gt; 0) result += carry;\n        char[] charArray = result.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n}\n\nclass Program {\n    static void Main() {\n        Solution solution = new Solution();\n        string a = \"1010\";\n        string b = \"1011\";\n        string result = solution.AddBinary(a, b);\n        Console.WriteLine(\"Result: \" + result); // Output: 10101\n    }\n}\n</code></pre> <pre><code>public class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int carry = 0;\n\n        int maxLength = Math.max(a.length(), b.length());\n        for (int i = 0; i &lt; maxLength; i++) {\n            int val = carry;\n            if (i &lt; a.length()) val += a.charAt(a.length() - 1 - i) - '0';\n            if (i &lt; b.length()) val += b.charAt(b.length() - 1 - i) - '0';\n            carry = val / 2;\n            result.append(val % 2);\n        }\n        if (carry &gt; 0) result.append(carry);\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String a = \"1010\";\n        String b = \"1011\";\n        String result = solution.addBinary(a, b);\n        System.out.println(\"Result: \" + result); // Output: 10101\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def addBinary(a: String, b: String): String = {\n        val result = new StringBuilder\n        var carry = 0\n\n        val maxLength = math.max(a.length, b.length)\n        for (i &lt;- 0 until maxLength) {\n            var val = carry\n            if (i &lt; a.length) val += a(a.length - 1 - i) - '0'\n            if (i &lt; b.length) val += b(b.length - 1 - i) - '0'\n            carry = val / 2\n            result.append(val % 2)\n        }\n        if (carry &gt; 0) result.append(carry)\n        result.reverse.toString()\n    }\n\n    def main(args: Array[String]): Unit = {\n        val a = \"1010\"\n        val b = \"1011\"\n        val result = addBinary(a, b)\n        println(s\"Result: $result\") // Output: 10101\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun addBinary(a: String, b: String): String {\n        val result = StringBuilder()\n        var carry = 0\n\n        val maxLength = maxOf(a.length, b.length)\n        for (i in 0 until maxLength) {\n            var val = carry\n            if (i &lt; a.length) val += a[a.length - 1 - i] - '0'\n            if (i &lt; b.length) val += b[b.length - 1 - i] - '0'\n            carry = val / 2\n            result.append(val % 2)\n        }\n        if (carry &gt; 0) result.append(carry)\n        return result.reverse().toString()\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val a = \"1010\"\n    val b = \"1011\"\n    val result = solution.addBinary(a, b)\n    println(\"Result: $result\") // Output: 10101\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) addBinary(a string, b string) string {\n    result := \"\"\n    carry := 0\n\n    maxLength := len(a)\n    if len(b) &gt; maxLength {\n        maxLength = len(b)\n    }\n    for i := 0; i &lt; maxLength; i++ {\n        val := carry\n        if i &lt; len(a) {\n            val += int(a[len(a)-1-i] - '0')\n        }\n        if i &lt; len(b) {\n            val += int(b[len(b)-1-i] - '0')\n        }\n        carry = val / 2\n        result += string(val%2 + '0')\n    }\n    if carry &gt; 0 {\n        result += '1'\n    }\n    // Reverse the result\n    runes := []rune(result)\n    for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc main() {\n    solution := Solution{}\n    a := \"1010\"\n    b := \"1011\"\n    result := solution.addBinary(a, b)\n    fmt.Println(\"Result:\", result) // Output: 10101\n}\n</code></pre> <pre><code>class Solution {\n    addBinary(a: string, b: string): string {\n        let result = '';\n        let carry = 0;\n\n        const maxLength = Math.max(a.length, b.length);\n        for (let i = 0; i &lt; maxLength; i++) {\n            let val = carry;\n            if (i &lt; a.length) val += parseInt(a[a.length - 1 - i]);\n            if (i &lt; b.length) val += parseInt(b[b.length - 1 - i]);\n            carry = Math.floor(val / 2);\n            result += (val % 2).toString();\n        }\n        if (carry) result += carry;\n        return result.split('').reverse().join('');\n    }\n}\n\nconst solution = new Solution();\nconst a = \"1010\";\nconst b = \"1011\";\nconst result = solution.addBinary(a, b);\nconsole.log(\"Result:\", result); // Output: 10101\n</code></pre> <pre><code>addBinary &lt;- function(a, b) {\n    result &lt;- \"\"\n    carry &lt;- 0\n\n    max_length &lt;- max(nchar(a), nchar(b))\n    for (i in 0:(max_length - 1)) {\n        val &lt;- carry\n        if (i &lt; nchar(a)) val &lt;- val + as.integer(substr(a, nchar(a) - i, nchar(a) - i))\n        if (i &lt; nchar(b)) val &lt;- val + as.integer(substr(b, nchar(b) - i, nchar(b) - i))\n        carry &lt;- val %/% 2\n        result &lt;- paste0(val %% 2, result)\n    }\n    if (carry &gt; 0) result &lt;- paste0(carry, result)\n    return(result)\n}\n\n# Main method\na &lt;- \"1010\"\nb &lt;- \"1011\"\nresult &lt;- addBinary(a, b)\ncat(\"Result:\", result, \"\\n\") # Output: 10101\n</code></pre> <pre><code>module BinaryAddition\n\nexport addBinary\n\nfunction addBinary(a::String, b::String)\n    result = \"\"\n    carry = 0\n\n    max_length = max(length(a), length(b))\n    for i in 0:(max_length - 1)\n        val = carry\n        if i &lt; length(a) val += Int(a[end - i] - '0') end\n        if i &lt; length(b) val += Int(b[end - i] - '0') end\n        carry = div(val, 2)\n        result *= string(val % 2)\n    end\n    if carry &gt; 0 result *= string(carry) end\n    return reverse(result)\nend\n\nend # module\n\n# Main method\nusing .BinaryAddition\n\na = \"1010\"\nb = \"1011\"\nresult = addBinary(a, b)\nprintln(\"Result: \", result) # Output: 10101\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#text-justification","title":"Text Justification","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-68-add-binary","title":"Problem Description: LeetCode - Problem 68 - Add Binary","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_6","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_6","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_6","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List\nclass Solution:\n    def fullJustify(self, words: str, maxWidth: str) -&gt; List[str]:\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i &lt; spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i &lt; maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in range(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) &lt; maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in range(len(words)):\n            if length + len(words[i]) + (i - begin) &gt; maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    std::vector&lt;std::string&gt; fullJustify(std::vector&lt;std::string&gt;&amp; words, int maxWidth) {\n        std::vector&lt;std::string&gt; res;\n        int begin = 0, length = 0;\n\n        for (int i = 0; i &lt; words.size(); ++i) {\n            if (length + words[i].length() + (i - begin) &gt; maxWidth) {\n                res.push_back(connect(words, maxWidth, begin, i, length, false));\n                begin = i;\n                length = 0;\n            }\n            length += words[i].length();\n        }\n\n        // Last line\n        res.push_back(connect(words, maxWidth, begin, words.size(), length, true));\n        return res;\n    }\n\nprivate:\n    int addSpaces(int i, int spaceCnt, int maxWidth, bool is_last) {\n        if (i &lt; spaceCnt) {\n            return is_last ? 1 : (maxWidth / spaceCnt) + (i &lt; maxWidth % spaceCnt);\n        }\n        return 0;\n    }\n\n    std::string connect(std::vector&lt;std::string&gt;&amp; words, int maxWidth, int begin, int end, int length, bool is_last) {\n        std::string line;\n        int n = end - begin;\n        for (int i = 0; i &lt; n; ++i) {\n            line += words[begin + i];\n            line += std::string(addSpaces(i, n - 1, maxWidth - length, is_last), ' ');\n        }\n        if (line.length() &lt; maxWidth) {\n            line += std::string(maxWidth - line.length(), ' ');\n        }\n        return line;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::vector&lt;std::string&gt; words = {\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"};\n    int maxWidth = 16;\n    std::vector&lt;std::string&gt; result = solution.fullJustify(words, maxWidth);\n\n    for (const auto&amp; line : result) {\n        std::cout &lt;&lt; \"\\\"\" &lt;&lt; line &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn full_justify(words: Vec&lt;String&gt;, max_width: usize) -&gt; Vec&lt;String&gt; {\n        let mut res = Vec::new();\n        let mut begin = 0;\n        let mut length = 0;\n\n        for i in 0..words.len() {\n            if length + words[i].len() + (i - begin) &gt; max_width {\n                res.push(Solution::connect(&amp;words, max_width, begin, i, length, false));\n                begin = i;\n                length = 0;\n            }\n            length += words[i].len();\n        }\n\n        // Last line\n        res.push(Solution::connect(&amp;words, max_width, begin, words.len(), length, true));\n        res\n    }\n\n    fn add_spaces(i: usize, space_cnt: usize, max_width: usize, is_last: bool) -&gt; usize {\n        if i &lt; space_cnt {\n            return if is_last { 1 } else { max_width / space_cnt + (i &lt; max_width % space_cnt) as usize };\n        }\n        0\n    }\n\n    fn connect(words: &amp;[String], max_width: usize, begin: usize, end: usize, length: usize, is_last: bool) -&gt; String {\n        let mut line = String::new();\n        let n = end - begin;\n\n        for i in 0..n {\n            line.push_str(&amp;words[begin + i]);\n            line.push_str(&amp;\" \".repeat(Solution::add_spaces(i, n - 1, max_width - length, is_last)));\n        }\n\n        if line.len() &lt; max_width {\n            line.push_str(&amp;\" \".repeat(max_width - line.len()));\n        }\n        line\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let words = vec![\n        String::from(\"This\"),\n        String::from(\"is\"),\n        String::from(\"an\"),\n        String::from(\"example\"),\n        String::from(\"of\"),\n        String::from(\"text\"),\n        String::from(\"justification.\"),\n    ];\n    let max_width = 16;\n    let result = solution.full_justify(words, max_width);\n\n    for line in result {\n        println!(\"{:?}\", line);\n    }\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public IList&lt;string&gt; FullJustify(string[] words, int maxWidth) {\n        var res = new List&lt;string&gt;();\n        int begin = 0, length = 0;\n\n        for (int i = 0; i &lt; words.Length; i++) {\n            if (length + words[i].Length + (i - begin) &gt; maxWidth) {\n                res.Add(Connect(words, maxWidth, begin, i, length, false));\n                begin = i;\n                length = 0;\n            }\n            length += words[i].Length;\n        }\n\n        // Last line\n        res.Add(Connect(words, maxWidth, begin, words.Length, length, true));\n        return res;\n    }\n\n    private int AddSpaces(int i, int spaceCnt, int maxWidth, bool isLast) {\n        if (i &lt; spaceCnt) {\n            return isLast ? 1 : (maxWidth / spaceCnt) + (i &lt; maxWidth % spaceCnt ? 1 : 0);\n        }\n        return 0;\n    }\n\n    private string Connect(string[] words, int maxWidth, int begin, int end, int length, bool isLast) {\n        var line = \"\";\n        int n = end - begin;\n\n        for (int i = 0; i &lt; n; i++) {\n            line += words[begin + i];\n            line += new string(' ', AddSpaces(i, n - 1, maxWidth - length, isLast));\n        }\n        if (line.Length &lt; maxWidth) {\n            line += new string(' ', maxWidth - line.Length);\n        }\n        return line;\n    }\n}\n\nclass Program {\n    static void Main() {\n        Solution solution = new Solution();\n        string[] words = { \"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\" };\n        int maxWidth = 16;\n        IList&lt;string&gt; result = solution.FullJustify(words, maxWidth);\n\n        foreach (var line in result) {\n            Console.WriteLine($\"\\\"{line}\\\"\");\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List&lt;String&gt; fullJustify(String[] words, int maxWidth) {\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        int begin = 0, length = 0;\n\n        for (int i = 0; i &lt; words.length; i++) {\n            if (length + words[i].length() + (i - begin) &gt; maxWidth) {\n                res.add(connect(words, maxWidth, begin, i, length, false));\n                begin = i;\n                length = 0;\n            }\n            length += words[i].length();\n        }\n\n        // Last line\n        res.add(connect(words, maxWidth, begin, words.length, length, true));\n        return res;\n    }\n\n    private int addSpaces(int i, int spaceCnt, int maxWidth, boolean isLast) {\n        if (i &lt; spaceCnt) {\n            return isLast ? 1 : (maxWidth / spaceCnt) + (i &lt; maxWidth % spaceCnt ? 1 : 0);\n        }\n        return 0;\n    }\n\n    private String connect(String[] words, int maxWidth, int begin, int end, int length, boolean isLast) {\n        StringBuilder line = new StringBuilder();\n        int n = end - begin;\n\n        for (int i = 0; i &lt; n; i++) {\n            line.append(words[begin + i]);\n            for (int j = 0; j &lt; addSpaces(i, n - 1, maxWidth - length, isLast); j++) {\n                line.append(' ');\n            }\n        }\n        if (line.length() &lt; maxWidth) {\n            for (int j = 0; j &lt; maxWidth - line.length(); j++) {\n                line.append(' ');\n            }\n        }\n        return line.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words = { \"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\" };\n        int maxWidth = 16;\n        List&lt;String&gt; result = solution.fullJustify(words, maxWidth);\n\n        for (String line : result) {\n            System.out.println(\"\\\"\" + line + \"\\\"\");\n        }\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {\n        var res = List[String]()\n        var begin = 0\n        var length = 0\n\n        for (i &lt;- words.indices) {\n            if (length + words(i).length + (i - begin) &gt; maxWidth) {\n                res = res :+ connect(words, maxWidth, begin, i, length, false)\n                begin = i\n                length = 0\n            }\n            length += words(i).length\n        }\n\n        // Last line\n        res = res :+ connect(words, maxWidth, begin, words.length, length, true)\n        res\n    }\n\n    private def addSpaces(i: Int, spaceCnt: Int, maxWidth: Int, isLast: Boolean): Int = {\n        if (i &lt; spaceCnt) {\n            if (isLast) 1 else (maxWidth / spaceCnt) + (if (i &lt; maxWidth % spaceCnt) 1 else 0)\n        } else {\n            0\n        }\n    }\n\n    private def connect(words: Array[String], maxWidth: Int, begin: Int, end: Int, length: Int, isLast: Boolean): String = {\n        val n = end - begin\n        val sb = new StringBuilder()\n\n        for (i &lt;- 0 until n) {\n            sb.append(words(begin + i))\n            sb.append(\" \" * addSpaces(i, n - 1, maxWidth - length, isLast))\n        }\n\n        if (sb.length &lt; maxWidth) {\n            sb.append(\" \" * (maxWidth - sb.length))\n        }\n        sb.toString()\n    }\n\n    def main(args: Array[String]): Unit = {\n        val words = Array(\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\")\n        val maxWidth = 16\n        val result = fullJustify(words, maxWidth)\n\n        result.foreach(line =&gt; println(s\"\"\"\"$line\"\"\"\"))\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun fullJustify(words: Array&lt;String&gt;, maxWidth: Int): List&lt;String&gt; {\n        val res = mutableListOf&lt;String&gt;()\n        var begin = 0\n        var length = 0\n\n        for (i in words.indices) {\n            if (length + words[i].length + (i - begin) &gt; maxWidth) {\n                res.add(connect(words, maxWidth, begin, i, length, false))\n                begin = i\n                length = 0\n            }\n            length += words[i].length\n        }\n\n        // Last line\n        res.add(connect(words, maxWidth, begin, words.size, length, true))\n        return res\n    }\n\n    private fun addSpaces(i: Int, spaceCnt: Int, maxWidth: Int, isLast: Boolean): Int {\n        return if (i &lt; spaceCnt) {\n            if (isLast) 1 else (maxWidth / spaceCnt) + if (i &lt; maxWidth % spaceCnt) 1 else 0\n        } else {\n            0\n        }\n    }\n\n    private fun connect(words: Array&lt;String&gt;, maxWidth: Int, begin: Int, end: Int, length: Int, isLast: Boolean): String {\n        val line = StringBuilder()\n        val n = end - begin\n\n        for (i in 0 until n) {\n            line.append(words[begin + i])\n            line.append(\" \".repeat(addSpaces(i, n - 1, maxWidth - length, isLast)))\n        }\n        if (line.length &lt; maxWidth) {\n            line.append(\" \".repeat(maxWidth - line.length))\n        }\n        return line.toString()\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val words = arrayOf(\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\")\n    val maxWidth = 16\n    val result = solution.fullJustify(words, maxWidth)\n\n    for (line in result) {\n        println(\"\\\"$line\\\"\")\n    }\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) FullJustify(words []string, maxWidth int) []string {\n    res := []string{}\n    begin, length := 0, 0\n\n    for i := 0; i &lt; len(words); i++ {\n        if length+len(words[i])+(i-begin) &gt; maxWidth {\n            res = append(res, s.connect(words, maxWidth, begin, i, length, false))\n            begin = i\n            length = 0\n        }\n        length += len(words[i])\n    }\n\n    // Last line\n    res = append(res, s.connect(words, maxWidth, begin, len(words), length, true))\n    return res\n}\n\nfunc (s *Solution) addSpaces(i, spaceCnt, maxWidth int, isLast bool) int {\n    if i &lt; spaceCnt {\n        if isLast {\n            return 1\n        }\n        return (maxWidth / spaceCnt) + boolToInt(i &lt; maxWidth%spaceCnt)\n    }\n    return 0\n}\n\nfunc (s *Solution) connect(words []string, maxWidth, begin, end, length int, isLast bool) string {\n    line := \"\"\n    n := end - begin\n\n    for i := 0; i &lt; n; i++ {\n        line += words[begin+i]\n        line += strings.Repeat(\" \", s.addSpaces(i, n-1, maxWidth-length, isLast))\n    }\n    if len(line) &lt; maxWidth {\n        line += strings.Repeat(\" \", maxWidth-len(line))\n    }\n    return line\n}\n\nfunc boolToInt(b bool) int {\n    if b {\n        return 1\n    }\n    return 0\n}\n\nfunc main() {\n    solution := Solution{}\n    words := []string{\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"}\n    maxWidth := 16\n    result := solution.FullJustify(words, maxWidth)\n\n    for _, line := range result {\n        fmt.Printf(\"\\\"%s\\\"\\n\", line)\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fullJustify(words: string[], maxWidth: number): string[] {\n        const res: string[] = [];\n        let begin = 0;\n        let length = 0;\n\n        for (let i = 0; i &lt; words.length; i++) {\n            if (length + words[i].length + (i - begin) &gt; maxWidth) {\n                res.push(this.connect(words, maxWidth, begin, i, length, false));\n                begin = i;\n                length = 0;\n            }\n            length += words[i].length;\n        }\n\n        // Last line\n        res.push(this.connect(words, maxWidth, begin, words.length, length, true));\n        return res;\n    }\n\n    private addSpaces(i: number, spaceCnt: number, maxWidth: number, isLast: boolean): number {\n        if (i &lt; spaceCnt) {\n            return isLast ? 1 : Math.floor(maxWidth / spaceCnt) + (i &lt; maxWidth % spaceCnt ? 1 : 0);\n        }\n        return 0;\n    }\n\n    private connect(words: string[], maxWidth: number, begin: number, end: number, length: number, isLast: boolean): string {\n        let line = '';\n        const n = end - begin;\n\n        for (let i = 0; i &lt; n; i++) {\n            line += words[begin + i];\n            line += ' '.repeat(this.addSpaces(i, n - 1, maxWidth - length, isLast));\n        }\n        if (line.length &lt; maxWidth) {\n            line += ' '.repeat(maxWidth - line.length);\n        }\n        return line;\n    }\n}\n\nconst solution = new Solution();\nconst words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"];\nconst maxWidth = 16;\nconst result = solution.fullJustify(words, maxWidth);\n\nfor (const line of result) {\n    console.log(`\"${line}\"`);\n}\n</code></pre> <pre><code>fullJustify &lt;- function(words, maxWidth) {\n    res &lt;- c()\n    begin &lt;- 1\n    length &lt;- 0\n\n    for (i in seq_along(words)) {\n        if (length + nchar(words[i]) + (i - begin) &gt; maxWidth) {\n        res &lt;- c(res, connect(words, maxWidth, begin, i, length, FALSE))\n        begin &lt;- i\n        length &lt;- 0\n        }\n        length &lt;- length + nchar(words[i])\n    }\n\n    # Last line\n    res &lt;- c(res, connect(words, maxWidth, begin, length(words), length, TRUE))\n    return(res)\n}\n\naddSpaces &lt;- function(i, spaceCnt, maxWidth, isLast) {\n    if (i &lt; spaceCnt) {\n        return(ifelse(isLast, 1, floor(maxWidth / spaceCnt) + ifelse(i &lt; maxWidth %% spaceCnt, 1, 0)))\n    }\n    return(0)\n}\n\nconnect &lt;- function(words, maxWidth, begin, end, length, isLast) {\n    line &lt;- \"\"\n    n &lt;- end - begin\n\n    for (i in seq_len(n)) {\n        line &lt;- paste0(line, words[begin + i - 1])\n        line &lt;- paste0(line, strrep(\" \", addSpaces(i - 1, n - 1, maxWidth - length, isLast)))\n    }\n    if (nchar(line) &lt; maxWidth) {\n        line &lt;- paste0(line, strrep(\" \", maxWidth - nchar(line)))\n    }\n    return(line)\n}\n\n# Main function\nwords &lt;- c(\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\")\nmaxWidth &lt;- 16\nresult &lt;- fullJustify(words, maxWidth)\n\nfor (line in result) {\n    cat(sprintf(\"\\\"%s\\\"\\n\", line))\n}\n</code></pre> <pre><code>module Justification\n\nexport fullJustify\n\nfunction fullJustify(words::Vector{String}, maxWidth::Int)\n    res = String[]\n    begin = 1\n    length = 0\n\n    for i in 1:length(words)\n        if length + length(words[i]) + (i - begin) &gt; maxWidth\n            push!(res, connect(words, maxWidth, begin, i, length, false))\n            begin = i\n            length = 0\n        end\n        length += length(words[i])\n    end\n\n    # Last line\n    push!(res, connect(words, maxWidth, begin, length(words), length, true))\n    return res\nend\n\nfunction addSpaces(i::Int, spaceCnt::Int, maxWidth::Int, isLast::Bool)\n    if i &lt; spaceCnt\n        return isLast ? 1 : div(maxWidth, spaceCnt) + (i &lt; maxWidth % spaceCnt ? 1 : 0)\n    end\n    return 0\nend\n\nfunction connect(words::Vector{String}, maxWidth::Int, begin::Int, end::Int, length::Int, isLast::Bool)\n    line = \"\"\n    n = end - begin\n\n    for i in 0:n-1\n        line *= words[begin + i]\n        line *= \" \" ^ addSpaces(i, n - 1, maxWidth - length, isLast)\n    end\n    if length(line) &lt; maxWidth\n        line *= \" \" ^ (maxWidth - length(line))\n    end\n    return line\nend\n\nend\n\n# Main function\nusing .Justification\n\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nmaxWidth = 16\nresult = fullJustify(words, maxWidth)\n\nfor line in result\n    println(\"\\\"$line\\\"\")\nend\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#valid-palindrome","title":"Valid Palindrome","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-125-valid-palindrome","title":"Problem Description: LeetCode - Problem 125 - Valid Palindrome","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_7","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_7","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_7","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    # @param s, a string\n    # @return a boolean\n    def isPalindrome(self, s: str) -&gt; bool:\n        i, j = 0, len(s) - 1\n        while i &lt; j:\n            while i &lt; j and not s[i].isalnum():\n                i += 1\n            while i &lt; j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n\nclass Solution {\npublic:\n    bool isPalindrome(const std::string&amp; s) {\n        int i = 0, j = s.size() - 1;\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !std::isalnum(s[i])) {\n                i++;\n            }\n            while (i &lt; j &amp;&amp; !std::isalnum(s[j])) {\n                j--;\n            }\n            if (std::tolower(s[i]) != std::tolower(s[j])) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string s = \"A man, a plan, a canal: Panama\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; solution.isPalindrome(s) &lt;&lt; std::endl;  // Output: true\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn is_palindrome(s: String) -&gt; bool {\n        let mut i = 0;\n        let mut j = s.len() - 1;\n\n        let s = s.to_lowercase();\n\n        while i &lt; j {\n            while i &lt; j &amp;&amp; !s.chars().nth(i).unwrap().is_alphanumeric() {\n                i += 1;\n            }\n            while i &lt; j &amp;&amp; !s.chars().nth(j).unwrap().is_alphanumeric() {\n                j -= 1;\n            }\n            if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n                return false;\n            }\n            i += 1;\n            j -= 1;\n        }\n        true\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let s = String::from(\"A man, a plan, a canal: Panama\");\n    println!(\"{}\", solution.is_palindrome(s));  // Output: true\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public bool IsPalindrome(string s) {\n        int i = 0, j = s.Length - 1;\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !char.IsLetterOrDigit(s[i])) {\n                i++;\n            }\n            while (i &lt; j &amp;&amp; !char.IsLetterOrDigit(s[j])) {\n                j--;\n            }\n            if (char.ToLower(s[i]) != char.ToLower(s[j])) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        Solution solution = new Solution();\n        string s = \"A man, a plan, a canal: Panama\";\n        Console.WriteLine(solution.IsPalindrome(s));  // Output: True\n    }\n}\n</code></pre> <pre><code>public class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) {\n                i++;\n            }\n            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) {\n                j--;\n            }\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"A man, a plan, a canal: Panama\";\n        System.out.println(solution.isPalindrome(s));  // Output: true\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def isPalindrome(s: String): Boolean = {\n        var i = 0\n        var j = s.length - 1\n\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !s(i).isLetterOrDigit) {\n                i += 1\n            }\n            while (i &lt; j &amp;&amp; !s(j).isLetterOrDigit) {\n                j -= 1\n            }\n            if (s(i).toLower != s(j).toLower) {\n                return false\n            }\n            i += 1\n            j -= 1\n        }\n        true\n    }\n\n    def main(args: Array[String]): Unit = {\n        val s = \"A man, a plan, a canal: Panama\"\n        println(isPalindrome(s))  // Output: true\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun isPalindrome(s: String): Boolean {\n        var i = 0\n        var j = s.length - 1\n\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !s[i].isLetterOrDigit()) {\n                i++\n            }\n            while (i &lt; j &amp;&amp; !s[j].isLetterOrDigit()) {\n                j--\n            }\n            if (s[i].lowercaseChar() != s[j].lowercaseChar()) {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val s = \"A man, a plan, a canal: Panama\"\n    println(solution.isPalindrome(s))  // Output: true\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) IsPalindrome(sStr string) bool {\n    i, j := 0, len(sStr)-1\n\n    for i &lt; j {\n        for i &lt; j &amp;&amp; !isAlphanumeric(rune(sStr[i])) {\n            i++\n        }\n        for i &lt; j &amp;&amp; !isAlphanumeric(rune(sStr[j])) {\n            j--\n        }\n        if toLower(rune(sStr[i])) != toLower(rune(sStr[j])) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nfunc isAlphanumeric(r rune) bool {\n    return unicode.IsLetter(r) || unicode.IsDigit(r)\n}\n\nfunc toLower(r rune) rune {\n    if 'A' &lt;= r &amp;&amp; r &lt;= 'Z' {\n        return r + 'a' - 'A'\n    }\n    return r\n}\n\nfunc main() {\n    solution := Solution{}\n    s := \"A man, a plan, a canal: Panama\"\n    fmt.Println(solution.IsPalindrome(s))  // Output: true\n}\n</code></pre> <pre><code>class Solution {\n    isPalindrome(s: string): boolean {\n        let i = 0;\n        let j = s.length - 1;\n\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !this.isAlphanumeric(s[i])) {\n                i++;\n            }\n            while (i &lt; j &amp;&amp; !this.isAlphanumeric(s[j])) {\n                j--;\n            }\n            if (s[i].toLowerCase() !== s[j].toLowerCase()) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    private isAlphanumeric(char: string): boolean {\n        return /^[a-zA-Z0-9]+$/.test(char);\n    }\n}\n\nconst solution = new Solution();\nconst s = \"A man, a plan, a canal: Panama\";\nconsole.log(solution.isPalindrome(s));  // Output: true\n</code></pre> <pre><code>isPalindrome &lt;- function(s) {\n    i &lt;- 1\n    j &lt;- nchar(s)\n\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; !is.alnum(substr(s, i, i))) {\n            i &lt;- i + 1\n        }\n        while (i &lt; j &amp;&amp; !is.alnum(substr(s, j, j))) {\n            j &lt;- j - 1\n        }\n        if (tolower(substr(s, i, i)) != tolower(substr(s, j, j))) {\n            return(FALSE)\n        }\n        i &lt;- i + 1\n        j &lt;- j - 1\n    }\n    return(TRUE)\n}\n\n# Main function\ns &lt;- \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # Output: TRUE\n</code></pre> <pre><code>module Palindrome\n\nexport is_palindrome\n\nfunction is_palindrome(s::String)\n    i = 1\n    j = length(s)\n\n    while i &lt; j\n        while i &lt; j &amp;&amp; !isletter(s[i]) &amp;&amp; !isdigit(s[i])\n            i += 1\n        end\n        while i &lt; j &amp;&amp; !isletter(s[j]) &amp;&amp; !isdigit(s[j])\n            j -= 1\n        end\n        if lowercase(s[i]) != lowercase(s[j])\n            return false\n        end\n        i += 1\n        j -= 1\n    end\n    return true\nend\n\nend\n\n# Main function\nusing .Palindrome\n\ns = \"A man, a plan, a canal: Panama\"\nprintln(is_palindrome(s))  # Output: true\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#reverse-words-in-a-string","title":"Reverse Words in a String","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-151-reverse-words-in-a-string","title":"Problem Description: LeetCode - Problem 151 - Reverse Words in a String","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_8","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_8","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_8","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    ## @param s, a string\n    ## @return a string\n    #def reverseWords(self, s: str) -&gt; str:\n    #    return ' '.join(reversed(s.split()))\n\n    ## @param s, a string\n    ## @return a string\n    #def reverseWords(self, s: str) -&gt; str:\n    #    return\" \".join(s.split()[::-1])\n\n    # @param s, a string\n    # @return a string\n    # Without built-in\n    def reverseWords(self, s: str) -&gt; str:\n        word=\"\"\n        res=\"\"\n        for i in s+\" \":\n            if i!=\" \":\n                word+=i\n            elif word:\n                res=word+\" \"+res\n                word=\"\"\n        return res[:-1]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\nclass Solution {\npublic:\n    std::string reverseWords(const std::string&amp; s) {\n        std::string word;\n        std::string res;\n\n        for (char i : s + \" \") {\n            if (i != ' ') {\n                word += i;\n            } else if (!word.empty()) {\n                res = word + \" \" + res;\n                word.clear();\n            }\n        }\n        return res.empty() ? res : res.substr(0, res.size() - 1); // Remove the trailing space\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string s = \"The sky is blue\";\n    std::cout &lt;&lt; solution.reverseWords(s) &lt;&lt; std::endl;  // Output: \"blue is sky The\"\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn reverse_words(s: String) -&gt; String {\n        let mut word = String::new();\n        let mut res = String::new();\n\n        for c in s.chars().chain(\" \".chars()) {\n            if c != ' ' {\n                word.push(c);\n            } else if !word.is_empty() {\n                res = format!(\"{} {}\", word, res);\n                word.clear();\n            }\n        }\n        res.trim_end().to_string() // Remove trailing space\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let s = String::from(\"The sky is blue\");\n    println!(\"{}\", solution.reverse_words(s)); // Output: \"blue is sky The\"\n}\n</code></pre> <pre><code>using System;\n\npublic class Solution {\n    public string ReverseWords(string s) {\n        string word = \"\";\n        string res = \"\";\n\n        foreach (char c in s + \" \") {\n            if (c != ' ') {\n                word += c;\n            } else if (word != \"\") {\n                res = word + \" \" + res;\n                word = \"\";\n            }\n        }\n        return res.TrimEnd(); // Remove trailing space\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        Solution solution = new Solution();\n        string s = \"The sky is blue\";\n        Console.WriteLine(solution.ReverseWords(s));  // Output: \"blue is sky The\"\n    }\n}\n</code></pre> <pre><code>public class Solution {\n    public String reverseWords(String s) {\n        StringBuilder word = new StringBuilder();\n        StringBuilder res = new StringBuilder();\n\n        for (char c : (s + \" \").toCharArray()) {\n            if (c != ' ') {\n                word.append(c);\n            } else if (word.length() &gt; 0) {\n                res.insert(0, word.toString() + \" \");\n                word.setLength(0);\n            }\n        }\n        return res.toString().trim(); // Remove trailing space\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"The sky is blue\";\n        System.out.println(solution.reverseWords(s));  // Output: \"blue is sky The\"\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def reverseWords(s: String): String = {\n        var word = \"\"\n        var res = \"\"\n\n        for (c &lt;- (s + \" \")) {\n            if (c != ' ') {\n                word += c\n            } else if (word.nonEmpty) {\n                res = word + \" \" + res\n                word = \"\"\n            }\n        }\n        res.trim // Remove trailing space\n    }\n\n    def main(args: Array[String]): Unit = {\n        val s = \"The sky is blue\"\n        println(reverseWords(s))  // Output: \"blue is sky The\"\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun reverseWords(s: String): String {\n        var word = \"\"\n        var res = \"\"\n\n        for (c in s + \" \") {\n            if (c != ' ') {\n                word += c\n            } else if (word.isNotEmpty()) {\n                res = \"$word $res\"\n                word = \"\"\n            }\n        }\n        return res.trim() // Remove trailing space\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val s = \"The sky is blue\"\n    println(solution.reverseWords(s))  // Output: \"blue is sky The\"\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) ReverseWords(sStr string) string {\n    word := \"\"\n    res := \"\"\n\n    for _, c := range sStr + \" \" {\n        if c != ' ' {\n            word += string(c)\n        } else if word != \"\" {\n            res = word + \" \" + res\n            word = \"\"\n        }\n    }\n    return strings.TrimSpace(res) // Remove trailing space\n}\n\nfunc main() {\n    solution := Solution{}\n    s := \"The sky is blue\"\n    fmt.Println(solution.ReverseWords(s)) // Output: \"blue is sky The\"\n}\n</code></pre> <pre><code>class Solution {\n    reverseWords(s: string): string {\n        let word = \"\";\n        let res = \"\";\n\n        for (let i of (s + \" \")) {\n            if (i !== ' ') {\n                word += i;\n            } else if (word) {\n                res = word + \" \" + res;\n                word = \"\";\n            }\n        }\n        return res.trim(); // Remove trailing space\n    }\n}\n\nconst solution = new Solution();\nconst s = \"The sky is blue\";\nconsole.log(solution.reverseWords(s));  // Output: \"blue is sky The\"\n</code></pre> <pre><code>reverseWords &lt;- function(s) {\n    word &lt;- \"\"\n    res &lt;- \"\"\n\n    for (i in strsplit(paste(s, \" \"), NULL)[[1]]) {\n        if (i != \" \") {\n            word &lt;- paste0(word, i)\n        } else if (nchar(word) &gt; 0) {\n            res &lt;- paste(word, res)\n            word &lt;- \"\"\n        }\n    }\n    return(trimws(res))  # Remove trailing space\n}\n\n# Main function\ns &lt;- \"The sky is blue\"\nprint(reverseWords(s))  # Output: \"blue is sky The\"\n</code></pre> <pre><code>module ReverseWords\n\nexport reverse_words\n\nfunction reverse_words(s::String)\n    word = \"\"\n    res = \"\"\n\n    for c in s * \" \"\n        if c != ' '\n            word *= c\n        elseif !isempty(word)\n            res *= word * \" \"\n            word = \"\"\n        end\n    end\n    return strip(res)  # Remove trailing space\nend\n\nend\n\n# Main function\nusing .ReverseWords\n\ns = \"The sky is blue\"\nprintln(reverse_words(s))  # Output: \"blue is sky The\"\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#shortest-palindrome-manachers-algorithm","title":"Shortest Palindrome - <code>Manacher's Algorithm</code>","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-214-shortest-palindrome","title":"Problem Description: LeetCode - Problem 214 - Shortest Palindrome","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_9","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_9","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_9","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class Solution:\n    def shortestPalindrome(self, s: str) -&gt; str:\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            string = ['^']\n            for c in s:\n                string +=  ['#', c]\n            string += ['#', '$']\n            return string\n\n        string = preProcess(s)\n        palindrome = [0] * len(string)\n        center, right = 0, 0\n        for i in range(1, len(string) - 1):\n            i_mirror = 2 * center - i\n            if right &gt; i:\n                palindrome[i] = min(right - i, palindrome[i_mirror])\n            else:\n                palindrome[i] = 0\n\n            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:\n                palindrome[i] += 1\n\n            if i + palindrome[i] &gt; right:\n                center, right = i, i + palindrome[i]\n\n        max_len = 0\n        for i in range(1, len(string) - 1):\n            if i - palindrome[i] == 1:\n                max_len = palindrome[i]\n        return s[len(s)-1:max_len-1:-1] + s\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    std::string shortestPalindrome(const std::string&amp; s) {\n        auto preProcess = [](const std::string&amp; s) {\n            if (s.empty()) return std::vector&lt;char&gt;{'^', '$'};\n            std::vector&lt;char&gt; result{'^'};\n            for (char c : s) {\n                result.push_back('#');\n                result.push_back(c);\n            }\n            result.push_back('#');\n            result.push_back('$');\n            return result;\n        };\n\n        auto string = preProcess(s);\n        std::vector&lt;int&gt; palindrome(string.size(), 0);\n        int center = 0, right = 0;\n\n        for (size_t i = 1; i &lt; string.size() - 1; ++i) {\n            int i_mirror = 2 * center - i;\n            if (right &gt; i) {\n                palindrome[i] = std::min(right - i, palindrome[i_mirror]);\n            } else {\n                palindrome[i] = 0;\n            }\n\n            while (string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]) {\n                ++palindrome[i];\n            }\n\n            if (i + palindrome[i] &gt; right) {\n                center = i;\n                right = i + palindrome[i];\n            }\n        }\n\n        int max_len = 0;\n        for (size_t i = 1; i &lt; string.size() - 1; ++i) {\n            if (i - palindrome[i] == 1) {\n                max_len = palindrome[i];\n            }\n        }\n\n        return std::string(s.rbegin(), s.rbegin() + s.size() - max_len) + s; // append reversed prefix\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string s = \"aacecaaa\";\n    std::cout &lt;&lt; solution.shortestPalindrome(s) &lt;&lt; std::endl; // Output: \"aaacecaaa\"\n    return 0;\n}\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    pub fn shortest_palindrome(s: String) -&gt; String {\n        fn pre_process(s: &amp;str) -&gt; Vec&lt;char&gt; {\n            if s.is_empty() {\n                return vec!['^', '$'];\n            }\n            let mut result = vec!['^'];\n            for c in s.chars() {\n                result.push('#');\n                result.push(c);\n            }\n            result.push('#');\n            result.push('$');\n            result\n        }\n\n        let string = pre_process(&amp;s);\n        let mut palindrome = vec![0; string.len()];\n        let mut center = 0;\n        let mut right = 0;\n\n        for i in 1..string.len() - 1 {\n            let i_mirror = 2 * center - i;\n            if right &gt; i {\n                palindrome[i] = palindrome[i_mirror].min(right - i);\n            } else {\n                palindrome[i] = 0;\n            }\n\n            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]] {\n                palindrome[i] += 1;\n            }\n\n            if i + palindrome[i] &gt; right {\n                center = i;\n                right = i + palindrome[i];\n            }\n        }\n\n        let mut max_len = 0;\n        for i in 1..string.len() - 1 {\n            if i - palindrome[i] == 1 {\n                max_len = palindrome[i];\n            }\n        }\n\n        let prefix: String = s.chars().rev().take(s.len() - max_len).collect();\n        format!(\"{}{}\", prefix, s) // append reversed prefix\n    }\n}\n\nfn main() {\n    let solution = Solution;\n    let s = String::from(\"aacecaaa\");\n    println!(\"{}\", solution.shortest_palindrome(s)); // Output: \"aaacecaaa\"\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public string ShortestPalindrome(string s) {\n        char[] preProcess(string s) {\n            if (string.IsNullOrEmpty(s)) return new char[] { '^', '$' };\n            List&lt;char&gt; result = new List&lt;char&gt; { '^' };\n            foreach (char c in s) {\n                result.Add('#');\n                result.Add(c);\n            }\n            result.Add('#');\n            result.Add('$');\n            return result.ToArray();\n        }\n\n        char[] stringProcessed = preProcess(s);\n        int[] palindrome = new int[stringProcessed.Length];\n        int center = 0, right = 0;\n\n        for (int i = 1; i &lt; stringProcessed.Length - 1; i++) {\n            int i_mirror = 2 * center - i;\n            if (right &gt; i) {\n                palindrome[i] = Math.Min(right - i, palindrome[i_mirror]);\n            } else {\n                palindrome[i] = 0;\n            }\n\n            while (stringProcessed[i + 1 + palindrome[i]] == stringProcessed[i - 1 - palindrome[i]]) {\n                palindrome[i]++;\n            }\n\n            if (i + palindrome[i] &gt; right) {\n                center = i;\n                right = i + palindrome[i];\n            }\n        }\n\n        int maxLen = 0;\n        for (int i = 1; i &lt; stringProcessed.Length - 1; i++) {\n            if (i - palindrome[i] == 1) {\n                maxLen = palindrome[i];\n            }\n        }\n\n        string prefix = new string(s.AsSpan(0, s.Length - maxLen).ToArray());\n        char[] reversedPrefix = prefix.ToCharArray();\n        Array.Reverse(reversedPrefix);\n        return new string(reversedPrefix) + s; // append reversed prefix\n    }\n\n    public static void Main() {\n        Solution solution = new Solution();\n        string s = \"aacecaaa\";\n        Console.WriteLine(solution.ShortestPalindrome(s)); // Output: \"aaacecaaa\"\n    }\n}\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public String shortestPalindrome(String s) {\n        char[] preProcess(String s) {\n            if (s.isEmpty()) return new char[] {'^', '$'};\n            List&lt;Character&gt; result = new ArrayList&lt;&gt;();\n            result.add('^');\n            for (char c : s.toCharArray()) {\n                result.add('#');\n                result.add(c);\n            }\n            result.add('#');\n            result.add('$');\n            char[] array = new char[result.size()];\n            for (int i = 0; i &lt; result.size(); i++) {\n                array[i] = result.get(i);\n            }\n            return array;\n        }\n\n        char[] stringProcessed = preProcess(s);\n        int[] palindrome = new int[stringProcessed.length];\n        int center = 0, right = 0;\n\n        for (int i = 1; i &lt; stringProcessed.length - 1; i++) {\n            int iMirror = 2 * center - i;\n            if (right &gt; i) {\n                palindrome[i] = Math.min(right - i, palindrome[iMirror]);\n            } else {\n                palindrome[i] = 0;\n            }\n\n            while (stringProcessed[i + 1 + palindrome[i]] == stringProcessed[i - 1 - palindrome[i]]) {\n                palindrome[i]++;\n            }\n\n            if (i + palindrome[i] &gt; right) {\n                center = i;\n                right = i + palindrome[i];\n            }\n        }\n\n        int maxLen = 0;\n        for (int i = 1; i &lt; stringProcessed.length - 1; i++) {\n            if (i - palindrome[i] == 1) {\n                maxLen = palindrome[i];\n            }\n        }\n\n        String prefix = new StringBuilder(s.substring(0, s.length() - maxLen)).reverse().toString();\n        return prefix + s; // append reversed prefix\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"aacecaaa\";\n        System.out.println(solution.shortestPalindrome(s)); // Output: \"aaacecaaa\"\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def shortestPalindrome(s: String): String = {\n        def preProcess(s: String): Array[Char] = {\n            if (s.isEmpty) return Array('^', '$')\n            val result = new scala.collection.mutable.ArrayBuffer[Char]()\n            result.append('^')\n            for (c &lt;- s) {\n                result.append('#', c)\n            }\n            result.append('#', '$')\n            result.toArray\n        }\n\n        val stringProcessed = preProcess(s)\n        val palindrome = Array.fill(stringProcessed.length)(0)\n        var center = 0\n        var right = 0\n\n        for (i &lt;- 1 until stringProcessed.length - 1) {\n            val iMirror = 2 * center - i\n            if (right &gt; i) {\n                palindrome(i) = math.min(right - i, palindrome(iMirror))\n            } else {\n                palindrome(i) = 0\n            }\n\n            while (stringProcessed(i + 1 + palindrome(i)) == stringProcessed(i - 1 - palindrome(i))) {\n                palindrome(i) += 1\n            }\n\n            if (i + palindrome(i) &gt; right) {\n                center = i\n                right = i + palindrome(i)\n            }\n        }\n\n        var maxLen = 0\n        for (i &lt;- 1 until stringProcessed.length - 1) {\n            if (i - palindrome(i) == 1) {\n                maxLen = palindrome(i)\n            }\n        }\n\n        val prefix = s.substring(0, s.length - maxLen).reverse\n        prefix + s // append reversed prefix\n    }\n\n    def main(args: Array[String]): Unit = {\n        val s = \"aacecaaa\"\n        println(shortestPalindrome(s)) // Output: \"aaacecaaa\"\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun shortestPalindrome(s: String): String {\n        fun preProcess(s: String): CharArray {\n            if (s.isEmpty()) return charArrayOf('^', '$')\n            val result = mutableListOf&lt;Char&gt;('^')\n            for (c in s) {\n                result.add('#')\n                result.add(c)\n            }\n            result.add('#')\n            result.add('$')\n            return result.toCharArray()\n        }\n\n        val stringProcessed = preProcess(s)\n        val palindrome = IntArray(stringProcessed.size)\n        var center = 0\n        var right = 0\n\n        for (i in 1 until stringProcessed.size - 1) {\n            val iMirror = 2 * center - i\n            palindrome[i] = if (right &gt; i) {\n                minOf(right - i, palindrome[iMirror])\n            } else {\n                0\n            }\n\n            while (stringProcessed[i + 1 + palindrome[i]] == stringProcessed[i - 1 - palindrome[i]]) {\n                palindrome[i]++\n            }\n\n            if (i + palindrome[i] &gt; right) {\n                center = i\n                right = i + palindrome[i]\n            }\n        }\n\n        var maxLen = 0\n        for (i in 1 until stringProcessed.size - 1) {\n            if (i - palindrome[i] == 1) {\n                maxLen = palindrome[i]\n            }\n        }\n\n        val prefix = s.substring(0, s.length - maxLen).reversed()\n        return prefix + s // append reversed prefix\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val s = \"aacecaaa\"\n    println(solution.shortestPalindrome(s)) // Output: \"aaacecaaa\"\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) shortestPalindrome(sStr string) string {\n    preProcess := func(s string) []rune {\n        if len(s) == 0 {\n            return []rune{'^', '$'}\n        }\n        result := []rune{'^'}\n        for _, c := range s {\n            result = append(result, '#', c)\n        }\n        result = append(result, '#', '$')\n        return result\n    }\n\n    stringProcessed := preProcess(sStr)\n    palindrome := make([]int, len(stringProcessed))\n    center, right := 0, 0\n\n    for i := 1; i &lt; len(stringProcessed)-1; i++ {\n        iMirror := 2*center - i\n        if right &gt; i {\n            palindrome[i] = min(right-i, palindrome[iMirror])\n        } else {\n            palindrome[i] = 0\n        }\n\n        for stringProcessed[i+1+palindrome[i]] == stringProcessed[i-1-palindrome[i]] {\n            palindrome[i]++\n        }\n\n        if i+palindrome[i] &gt; right {\n            center, right = i, i+palindrome[i]\n        }\n    }\n\n    maxLen := 0\n    for i := 1; i &lt; len(stringProcessed)-1; i++ {\n        if i-palindrome[i] == 1 {\n            maxLen = palindrome[i]\n        }\n    }\n\n    prefix := reverse(sStr[:len(sStr)-maxLen])\n    return prefix + sStr // append reversed prefix\n}\n\nfunc min(a, b int) int {\n    if a &lt; b {\n        return a\n    }\n    return b\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc main() {\n    solution := &amp;Solution{}\n    s := \"aacecaaa\"\n    fmt.Println(solution.shortestPalindrome(s)) // Output: \"aaacecaaa\"\n}\n</code></pre> <pre><code>class Solution {\n    shortestPalindrome(s: string): string {\n        const preProcess = (s: string): string[] =&gt; {\n            if (s.length === 0) return ['^', '$'];\n            const result: string[] = ['^'];\n            for (const c of s) {\n                result.push('#', c);\n            }\n            result.push('#', '$');\n            return result;\n        };\n\n        const stringProcessed = preProcess(s);\n        const palindrome: number[] = Array(stringProcessed.length).fill(0);\n        let center = 0;\n        let right = 0;\n\n        for (let i = 1; i &lt; stringProcessed.length - 1; i++) {\n            const iMirror = 2 * center - i;\n            if (right &gt; i) {\n                palindrome[i] = Math.min(right - i, palindrome[iMirror]);\n            } else {\n                palindrome[i] = 0;\n            }\n\n            while (stringProcessed[i + 1 + palindrome[i]] === stringProcessed[i - 1 - palindrome[i]]) {\n                palindrome[i]++;\n            }\n\n            if (i + palindrome[i] &gt; right) {\n                center = i;\n                right = i + palindrome[i];\n            }\n        }\n\n        let maxLen = 0;\n        for (let i = 1; i &lt; stringProcessed.length - 1; i++) {\n            if (i - palindrome[i] === 1) {\n                maxLen = palindrome[i];\n            }\n        }\n\n        const prefix = s.substring(0, s.length - maxLen).split('').reverse().join('');\n        return prefix + s; // append reversed prefix\n    }\n}\n\nconst solution = new Solution();\nconst s = \"aacecaaa\";\nconsole.log(solution.shortestPalindrome(s)); // Output: \"aaacecaaa\"\n</code></pre> <pre><code>shortestPalindrome &lt;- function(s) {\n    preProcess &lt;- function(s) {\n        if (nchar(s) == 0) return(c('^', '$'))\n        result &lt;- c('^')\n        for (c in strsplit(s, NULL)[[1]]) {\n            result &lt;- c(result, '#', c)\n        }\n        c(result, '#', '$')\n    }\n\n    stringProcessed &lt;- preProcess(s)\n    palindrome &lt;- integer(length(stringProcessed))\n    center &lt;- 0\n    right &lt;- 0\n\n    for (i in 2:(length(stringProcessed) - 1)) {\n        iMirror &lt;- 2 * center - i\n        if (right &gt; i) {\n            palindrome[i] &lt;- min(right - i, palindrome[iMirror])\n        } else {\n            palindrome[i] &lt;- 0\n        }\n\n        while (stringProcessed[i + 1 + palindrome[i]] == stringProcessed[i - 1 - palindrome[i]]) {\n            palindrome[i] &lt;- palindrome[i] + 1\n        }\n\n        if (i + palindrome[i] &gt; right) {\n            center &lt;- i\n            right &lt;- i + palindrome[i]\n        }\n    }\n\n    maxLen &lt;- 0\n    for (i in 2:(length(stringProcessed) - 1)) {\n        if (i - palindrome[i] == 1) {\n            maxLen &lt;- palindrome[i]\n        }\n    }\n\n    prefix &lt;- rev(strsplit(substring(s, 1, nchar(s) - maxLen), NULL)[[1]])\n    paste(c(prefix, strsplit(s, NULL)[[1]]), collapse = \"\") # append reversed prefix\n}\n\ns &lt;- \"aacecaaa\"\nprint(shortestPalindrome(s)) # Output: \"aaacecaaa\"\n</code></pre> <pre><code>struct Solution end\n\nfunction shortest_palindrome(s::String)\n    function pre_process(s::String)\n        if s == \"\" \n            return ['^', '$']\n        end\n        result = ['^']\n        for c in s\n            push!(result, '#', c)\n        end\n        push!(result, '#', '$')\n        return result\n    end\n\n    string_processed = pre_process(s)\n    palindrome = zeros(Int, length(string_processed))\n    center, right = 0, 0\n\n    for i in 2:length(string_processed)-1\n        i_mirror = 2 * center - i\n        if right &gt; i\n            palindrome[i] = min(right - i, palindrome[i_mirror])\n        else\n            palindrome[i] = 0\n        end\n\n        while string_processed[i + 1 + palindrome[i]] == string_processed[i - 1 - palindrome[i]\n        ]\n            palindrome[i] += 1\n        end\n\n        if i + palindrome[i] &gt; right\n            center, right = i, i + palindrome[i]\n        end\n    end\n\n    max_len = 0\n    for i in 2:length(string_processed)-1\n        if i - palindrome[i] == 1\n            max_len = palindrome[i]\n        end\n    end\n\n    prefix = reverse(s[1:end-max_len])\n    return prefix * s # append reversed prefix\nend\n\nfunction main()\n    s = \"aacecaaa\"\n    println(shortest_palindrome(s)) # Output: \"aaacecaaa\"\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#valid-anagram","title":"Valid Anagram","text":"","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-242-valid-anagram","title":"Problem Description: LeetCode - Problem 242 - Valid Anagram","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_10","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_10","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/002_String/#solutions_10","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>import collections\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        count = collections.defaultdict(int)\n        for c in s:\n            count[c] += 1\n        for c in t:\n            count[c] -= 1\n            if count[c] &lt; 0:\n                return False\n        return True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n\nclass Solution {\npublic:\n    bool isAnagram(const std::string&amp; s, const std::string&amp; t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        std::unordered_map&lt;char, int&gt; count;\n        for (char c : s) {\n            count[c]++;\n        }\n        for (char c : t) {\n            count[c]--;\n            if (count[c] &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::string s = \"anagram\";\n    std::string t = \"nagaram\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; solution.isAnagram(s, t) &lt;&lt; std::endl; // Output: true\n    return 0;\n}\n</code></pre> <pre><code>use std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    pub fn is_anagram(s: String, t: String) -&gt; bool {\n        if s.len() != t.len() {\n            return false;\n        }\n        let mut count = HashMap::new();\n        for c in s.chars() {\n            *count.entry(c).or_insert(0) += 1;\n        }\n        for c in t.chars() {\n            let entry = count.entry(c).or_insert(0);\n            *entry -= 1;\n            if *entry &lt; 0 {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nfn main() {\n    let s = String::from(\"anagram\");\n    let t = String::from(\"nagaram\");\n    println!(\"{}\", Solution::is_anagram(s, t)); // Output: true\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\nclass Solution {\n    public bool IsAnagram(string s, string t) {\n        if (s.Length != t.Length) {\n            return false;\n        }\n        var count = new Dictionary&lt;char, int&gt;();\n        foreach (char c in s) {\n            if (count.ContainsKey(c)) {\n                count[c]++;\n            } else {\n                count[c] = 1;\n            }\n        }\n        foreach (char c in t) {\n            if (count.ContainsKey(c)) {\n                count[c]--;\n                if (count[c] &lt; 0) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nclass Program {\n    static void Main() {\n        var solution = new Solution();\n        string s = \"anagram\";\n        string t = \"nagaram\";\n        Console.WriteLine(solution.IsAnagram(s, t)); // Output: True\n    }\n}\n</code></pre> <pre><code>import java.util.HashMap;\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;&gt;();\n        for (char c : s.toCharArray()) {\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n        for (char c : t.toCharArray()) {\n            count.put(c, count.getOrDefault(c, 0) - 1);\n            if (count.get(c) &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"anagram\";\n        String t = \"nagaram\";\n        System.out.println(solution.isAnagram(s, t)); // Output: true\n    }\n}\n</code></pre> <pre><code>import scala.collection.mutable\n\nclass Solution {\n    def isAnagram(s: String, t: String): Boolean = {\n        if (s.length != t.length) {\n            return false\n        }\n        val count = mutable.Map[Char, Int]()\n        for (c &lt;- s) {\n            count(c) = count.getOrElse(c, 0) + 1\n        }\n        for (c &lt;- t) {\n            count(c) = count.getOrElse(c, 0) - 1\n            if (count(c) &lt; 0) {\n                return false\n            }\n        }\n        true\n    }\n}\n\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val solution = new Solution()\n        val s = \"anagram\"\n        val t = \"nagaram\"\n        println(solution.isAnagram(s, t)) // Output: true\n    }\n}\n</code></pre> <pre><code>class Solution {\n    fun isAnagram(s: String, t: String): Boolean {\n        if (s.length != t.length) {\n            return false\n        }\n        val count = mutableMapOf&lt;Char, Int&gt;()\n        for (c in s) {\n            count[c] = count.getOrDefault(c, 0) + 1\n        }\n        for (c in t) {\n            count[c] = count.getOrDefault(c, 0) - 1\n            if (count[c]!! &lt; 0) {\n                return false\n            }\n        }\n        return true\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val s = \"anagram\"\n    val t = \"nagaram\"\n    println(solution.isAnagram(s, t)) // Output: true\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) IsAnagram(sStr string, tStr string) bool {\n    if len(sStr) != len(tStr) {\n        return false\n    }\n    count := make(map[rune]int)\n    for _, c := range sStr {\n        count[c]++\n    }\n    for _, c := range tStr {\n        count[c]--\n        if count[c] &lt; 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    solution := &amp;Solution{}\n    s := \"anagram\"\n    t := \"nagaram\"\n    fmt.Println(solution.IsAnagram(s, t)) // Output: true\n}\n</code></pre> <pre><code>class Solution {\n    isAnagram(s: string, t: string): boolean {\n        if (s.length !== t.length) {\n            return false;\n        }\n        const count: { [key: string]: number } = {};\n        for (const c of s) {\n            count[c] = (count[c] || 0) + 1;\n        }\n        for (const c of t) {\n            count[c] = (count[c] || 0) - 1;\n            if (count[c] &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nconst solution = new Solution();\nconst s = \"anagram\";\nconst t = \"nagaram\";\nconsole.log(solution.isAnagram(s, t)); // Output: true\n</code></pre> <pre><code>isAnagram &lt;- function(s, t) {\n    if (nchar(s) != nchar(t)) {\n        return(FALSE)\n    }\n    count &lt;- table(strsplit(s, NULL)[[1]])\n    for (c in strsplit(t, NULL)[[1]]) {\n        count[c] &lt;- count[c] - 1\n        if (count[c] &lt; 0) {\n            return(FALSE)\n        }\n    }\n    return(TRUE)\n}\n\ns &lt;- \"anagram\"\nt &lt;- \"nagaram\"\nprint(isAnagram(s, t)) # Output: TRUE\n</code></pre> <pre><code>struct Solution end\n\nfunction is_anagram(s::String, t::String)\n    if length(s) != length(t)\n        return false\n    end\n    count = Dict{Char, Int}()\n    for c in s\n        count[c] = get(count, c, 0) + 1\n    end\n    for c in t\n        count[c] = get(count, c, 0) - 1\n        if count[c] &lt; 0\n            return false\n        end\n    end\n    return true\nend\n\nfunction main()\n    s = \"anagram\"\n    t = \"nagaram\"\n    println(is_anagram(s, t)) # Output: true\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/002_String/#problem-description-leetcode-problem-2800-shortest-string-that-contains-three-strings","title":"Problem Description: LeetCode - Problem 2800 - Shortest String That Contains Three Strings","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solution-explanation_11","title":"Solution Explanation","text":"<p>1. Suffix Array Construction (<code>build_suffix_array</code>):    - This function builds a suffix array for a given string using the prefix doubling algorithm.    - It starts by sorting suffixes based on their first character, then iteratively sorts them based on longer prefixes (doubling the length each time).</p> <p>2. LCP Array Construction (<code>build_lcp_array</code>):    - This function builds the Longest Common Prefix (LCP) array from the suffix array and the original string.    - It uses Kasai's algorithm to compute the LCP values efficiently.</p> <p>3. Finding Overlap (<code>find_overlap</code>):    - This function finds the maximum overlap between two strings using the suffix array and LCP array.    - It combines the two strings with a separator, builds the suffix array and LCP array, and then finds the maximum LCP value between suffixes from different strings.</p> <p>4. Merging Strings (<code>merge_strings</code>):    - This function merges three strings by finding the overlap between the first two, then finding the overlap of the result with the third string.</p> <p>5. Main Function (<code>minimumString</code>):    - This function generates all permutations of the three input strings and finds the shortest merged string among them.    - It uses the <code>merge_strings</code> function for each permutation and selects the shortest result (or lexicographically smallest if there are multiple shortest results).</p>","tags":["Original"]},{"location":"data_structures/002_String/#complexity-analysis_11","title":"Complexity Analysis","text":"<p>1. Suffix Array Construction [<code>build_suffix_array</code> - TC: <code>O(n log n)</code> ; SC: <code>O(n)</code>] :    - Time Complexity: <code>O(n log n)</code>, where <code>n</code> is the length of the string.    - Space Complexity: <code>O(n)</code> for storing the suffix array and temporary arrays.</p> <p>2. LCP Array Construction [<code>build_lcp_array</code> - TC: <code>O(n)</code> ; SC: <code>O(n)</code>] :    - Time Complexity: <code>O(n)</code>, where <code>n</code> is the length of the string.    - Space Complexity: <code>O(n)</code> for storing the LCP array and rank array.</p> <p>3. Finding Overlap [<code>find_overlap</code> - TC: <code>O(n log n)</code> ; SC: <code>O(n)</code>] :    - Time Complexity: <code>O(n log n)</code> due to suffix array construction, where <code>n</code> is the total length of both strings.    - Space Complexity: <code>O(n)</code> for storing the combined string, suffix array, and LCP array.</p> <p>4. Merging Strings [<code>merge_strings</code> - TC: <code>O(n log n)</code> ; SC: <code>O(n)</code>] :    - Time Complexity: <code>O(n log n)</code>, where <code>n</code> is the total length of all three strings.    - Space Complexity: <code>O(n)</code> for storing the merged strings.</p> <p>5. Main Function [<code>minimumString</code> - TC: <code>O(n log n)</code> ; SC: <code>O(n)</code>] :    - Time Complexity: <code>O(n log n)</code>, where <code>n</code> is the total length of all input strings. Although we try 6 permutations, this is a constant factor.    - Space Complexity: <code>O(n)</code> for storing the merged strings.</p> <p>Overall Complexity Analysis [TC: <code>O(n log n)</code> ; SC: <code>O(n)</code>] : - Time Complexity: <code>O(n log n)</code>, where n is the total length of all input strings. This is dominated by the suffix array construction, which is done multiple times but always with a total string length proportional to <code>n</code>. - Space Complexity: <code>O(n)</code> for storing the suffix arrays, LCP arrays, and merged strings.</p> <ul> <li> <p>Summary : This solution is theoretically more efficient than <code>O(n^2)</code> solutions, especially for large inputs. The use of suffix arrays allows for efficient string matching and overlap finding. However, it's worth noting that:</p> </li> <li> <p>The implementation is more complex than simpler approaches, which could make it more prone to bugs and harder to maintain.</p> </li> <li>For smaller inputs, simpler O(n^2) solutions might actually be faster due to lower constant factors and better cache performance.</li> <li>This solution still tries all permutations of the three strings, which isn't necessary in theory but simplifies the implementation.</li> </ul> <p>In practice, the choice between this solution and simpler ones would depend on the expected size and characteristics of the input strings, as well as the importance of optimizing for worst-case versus average-case performance.</p>","tags":["Original"]},{"location":"data_structures/002_String/#solutions_11","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import List, Tuple\n\nclass Solution:\n    def minimumString(self, string1: str, string2: str, string3: str) -&gt; str:\n        def build_suffix_array(text: str) -&gt; List[int]:\n            text_length = len(text)\n            suffix_array = list(range(text_length))\n            rank = [ord(char) for char in text]\n            temp_rank = [0] * text_length\n            chunk_size = 1\n            while chunk_size &lt; text_length:\n                suffix_array.sort(key=lambda i: (rank[i], rank[i+chunk_size] if i+chunk_size &lt; text_length else -1))\n                for i in range(1, text_length):\n                    temp_rank[i] = temp_rank[i-1] + (\n                        (rank[suffix_array[i]], rank[suffix_array[i]+chunk_size] if suffix_array[i]+chunk_size &lt; text_length else -1) !=\n                        (rank[suffix_array[i-1]], rank[suffix_array[i-1]+chunk_size] if suffix_array[i-1]+chunk_size &lt; text_length else -1)\n                    )\n                for i in range(text_length):\n                    rank[suffix_array[i]] = temp_rank[i]\n                if temp_rank[-1] == text_length - 1:\n                    break\n                chunk_size *= 2\n            return suffix_array\n\n        def build_lcp_array(text: str, suffix_array: List[int]) -&gt; List[int]:\n            text_length = len(text)\n            rank = [0] * text_length\n            for i in range(text_length):\n                rank[suffix_array[i]] = i\n            lcp = [0] * (text_length - 1)\n            k = 0\n            for i in range(text_length):\n                if rank[i] == text_length - 1:\n                    k = 0\n                    continue\n                j = suffix_array[rank[i] + 1]\n                while i + k &lt; text_length and j + k &lt; text_length and text[i+k] == text[j+k]:\n                    k += 1\n                lcp[rank[i]] = k\n                if k:\n                    k -= 1\n            return lcp\n\n        def find_overlap(string_a: str, string_b: str) -&gt; Tuple[str, int]:\n            combined_string = string_a + '#' + string_b\n            suffix_array = build_suffix_array(combined_string)\n            lcp_array = build_lcp_array(combined_string, suffix_array)\n\n            max_overlap = 0\n            for i in range(len(combined_string) - 1):\n                if (suffix_array[i] &lt; len(string_a)) != (suffix_array[i+1] &lt; len(string_a)):\n                    max_overlap = max(max_overlap, lcp_array[i])\n\n            if string_a in string_b:\n                return string_b, len(string_a)\n            elif string_b in string_a:\n                return string_a, len(string_b)\n            elif max_overlap &gt; 0:\n                if suffix_array[i] &lt; len(string_a):\n                    return string_a + string_b[max_overlap:], max_overlap\n                else:\n                    return string_b + string_a[max_overlap:], max_overlap\n            else:\n                return string_a + string_b, 0\n\n        def merge_strings(s1: str, s2: str, s3: str) -&gt; str:\n            merged_s1_s2, _ = find_overlap(s1, s2)\n            final_merged, _ = find_overlap(merged_s1_s2, s3)\n            return final_merged\n\n        all_permutations = [\n            (string1, string2, string3), (string1, string3, string2),\n            (string2, string1, string3), (string2, string3, string1),\n            (string3, string1, string2), (string3, string2, string1)\n        ]\n        return min((merge_strings(x[0], x[1], x[2]) for x in all_permutations), key=lambda s: (len(s), s))\n</code></pre> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;tuple&gt;\n\nclass Solution {\npublic:\n    std::string minimumString(const std::string&amp; string1, const std::string&amp; string2, const std::string&amp; string3) {\n        auto build_suffix_array = [](const std::string&amp; text) -&gt; std::vector&lt;int&gt; {\n            int text_length = text.length();\n            std::vector&lt;int&gt; suffix_array(text_length), rank(text_length), temp_rank(text_length);\n            for (int i = 0; i &lt; text_length; ++i) {\n                suffix_array[i] = i;\n                rank[i] = text[i];\n            }\n            int chunk_size = 1;\n            while (chunk_size &lt; text_length) {\n                std::sort(suffix_array.begin(), suffix_array.end(), [&amp;](int i, int j) {\n                    return std::make_pair(rank[i], i + chunk_size &lt; text_length ? rank[i + chunk_size] : -1) &lt;\n                        std::make_pair(rank[j], j + chunk_size &lt; text_length ? rank[j + chunk_size] : -1);\n                });\n                temp_rank[0] = 0;\n                for (int i = 1; i &lt; text_length; ++i) {\n                    temp_rank[i] = temp_rank[i - 1] +\n                                (std::make_pair(rank[suffix_array[i]], suffix_array[i] + chunk_size &lt; text_length ? rank[suffix_array[i] + chunk_size] : -1) !=\n                                    std::make_pair(rank[suffix_array[i - 1]], suffix_array[i - 1] + chunk_size &lt; text_length ? rank[suffix_array[i - 1] + chunk_size] : -1));\n                }\n                for (int i = 0; i &lt; text_length; ++i) {\n                    rank[suffix_array[i]] = temp_rank[i];\n                }\n                if (temp_rank[text_length - 1] == text_length - 1) {\n                    break;\n                }\n                chunk_size *= 2;\n            }\n            return suffix_array;\n        };\n\n        auto build_lcp_array = [](const std::string&amp; text, const std::vector&lt;int&gt;&amp; suffix_array) -&gt; std::vector&lt;int&gt; {\n            int text_length = text.length();\n            std::vector&lt;int&gt; rank(text_length), lcp(text_length - 1);\n            for (int i = 0; i &lt; text_length; ++i) {\n                rank[suffix_array[i]] = i;\n            }\n            int k = 0;\n            for (int i = 0; i &lt; text_length; ++i) {\n                if (rank[i] == text_length - 1) {\n                    k = 0;\n                    continue;\n                }\n                int j = suffix_array[rank[i] + 1];\n                while (i + k &lt; text_length &amp;&amp; j + k &lt; text_length &amp;&amp; text[i + k] == text[j + k]) {\n                    k++;\n                }\n                lcp[rank[i]] = k;\n                if (k) {\n                    k--;\n                }\n            }\n            return lcp;\n        };\n\n        auto find_overlap = [&amp;](const std::string&amp; string_a, const std::string&amp; string_b) -&gt; std::tuple&lt;std::string, int&gt; {\n            std::string combined_string = string_a + \"#\" + string_b;\n            auto suffix_array = build_suffix_array(combined_string);\n            auto lcp_array = build_lcp_array(combined_string, suffix_array);\n\n            int max_overlap = 0;\n            for (int i = 0; i &lt; combined_string.length() - 1; ++i) {\n                if ((suffix_array[i] &lt; string_a.length()) != (suffix_array[i + 1] &lt; string_a.length())) {\n                    max_overlap = std::max(max_overlap, lcp_array[i]);\n                }\n            }\n\n            if (string_a.find(string_b) != std::string::npos) {\n                return {string_b, static_cast&lt;int&gt;(string_a.length())};\n            } else if (string_b.find(string_a) != std::string::npos) {\n                return {string_a, static_cast&lt;int&gt;(string_b.length())};\n            } else if (max_overlap &gt; 0) {\n                if (suffix_array[max_overlap] &lt; string_a.length()) {\n                    return {string_a + string_b.substr(max_overlap), max_overlap};\n                } else {\n                    return {string_b + string_a.substr(max_overlap), max_overlap};\n                }\n            } else {\n                return {string_a + string_b, 0};\n            }\n        };\n\n        auto merge_strings = [&amp;](const std::string&amp; s1, const std::string&amp; s2, const std::string&amp; s3) -&gt; std::string {\n            auto [merged_s1_s2, _] = find_overlap(s1, s2);\n            auto [final_merged, __] = find_overlap(merged_s1_s2, s3);\n            return final_merged;\n        };\n\n        std::vector&lt;std::tuple&lt;std::string, std::string, std::string&gt;&gt; all_permutations = {\n            {string1, string2, string3}, {string1, string3, string2},\n            {string2, string1, string3}, {string2, string3, string1},\n            {string3, string1, string2}, {string3, string2, string1}\n        };\n\n        std::string result = *std::min_element(all_permutations.begin(), all_permutations.end(), [&amp;](auto&amp; a, auto&amp; b) {\n            return merge_strings(std::get&lt;0&gt;(a), std::get&lt;1&gt;(a), std::get&lt;2&gt;(a)) &lt; \n                merge_strings(std::get&lt;0&gt;(b), std::get&lt;1&gt;(b), std::get&lt;2&gt;(b));\n        });\n\n        return result;\n    }\n};\n</code></pre> <pre><code>struct Solution;\n\nimpl Solution {\n    fn build_suffix_array(text: &amp;str) -&gt; Vec&lt;usize&gt; {\n        let text_length = text.len();\n        let mut suffix_array: Vec&lt;usize&gt; = (0..text_length).collect();\n        let mut rank: Vec&lt;i32&gt; = text.chars().map(|c| c as i32).collect();\n        let mut temp_rank = vec![0; text_length];\n        let mut chunk_size = 1;\n\n        while chunk_size &lt; text_length {\n            suffix_array.sort_by_key(|&amp;i| {\n                let second_rank = if i + chunk_size &lt; text_length {\n                    rank[i + chunk_size]\n                } else {\n                    -1\n                };\n                (rank[i], second_rank)\n            });\n\n            temp_rank[0] = 0;\n            for i in 1..text_length {\n                let first_pair = (rank[suffix_array[i]], if suffix_array[i] + chunk_size &lt; text_length { rank[suffix_array[i] + chunk_size] } else { -1 });\n                let second_pair = (rank[suffix_array[i - 1]], if suffix_array[i - 1] + chunk_size &lt; text_length { rank[suffix_array[i - 1] + chunk_size] } else { -1 });\n                temp_rank[i] = temp_rank[i - 1] + if first_pair != second_pair { 1 } else { 0 };\n            }\n\n            for i in 0..text_length {\n                rank[suffix_array[i]] = temp_rank[i];\n            }\n\n            if temp_rank[text_length - 1] == text_length as i32 - 1 {\n                break;\n            }\n            chunk_size *= 2;\n        }\n\n        suffix_array\n    }\n\n    fn build_lcp_array(text: &amp;str, suffix_array: &amp;Vec&lt;usize&gt;) -&gt; Vec&lt;usize&gt; {\n        let text_length = text.len();\n        let mut rank = vec![0; text_length];\n        let mut lcp = vec![0; text_length - 1];\n\n        for i in 0..text_length {\n            rank[suffix_array[i]] = i;\n        }\n\n        let mut k = 0;\n        for i in 0..text_length {\n            if rank[i] == text_length - 1 {\n                k = 0;\n                continue;\n            }\n            let j = suffix_array[rank[i] + 1];\n            while i + k &lt; text_length &amp;&amp; j + k &lt; text_length &amp;&amp; text.as_bytes()[i + k] == text.as_bytes()[j + k] {\n                k += 1;\n            }\n            lcp[rank[i]] = k;\n            if k &gt; 0 {\n                k -= 1;\n            }\n        }\n\n        lcp\n    }\n\n    fn find_overlap(string_a: &amp;str, string_b: &amp;str) -&gt; (String, usize) {\n        let combined_string = format!(\"{}#{}\", string_a, string_b);\n        let suffix_array = build_suffix_array(&amp;combined_string);\n        let lcp_array = build_lcp_array(&amp;combined_string, &amp;suffix_array);\n\n        let mut max_overlap = 0;\n        for i in 0..combined_string.len() - 1 {\n            if (suffix_array[i] &lt; string_a.len()) != (suffix_array[i + 1] &lt; string_a.len()) {\n                max_overlap = max_overlap.max(lcp_array[i]);\n            }\n        }\n\n        if string_a.contains(string_b) {\n            (string_b.to_string(), string_a.len())\n        } else if string_b.contains(string_a) {\n            (string_a.to_string(), string_b.len())\n        } else if max_overlap &gt; 0 {\n            if suffix_array[max_overlap] &lt; string_a.len() {\n                (format!(\"{}{}\", string_a, &amp;string_b[max_overlap..]), max_overlap)\n            } else {\n                (format!(\"{}{}\", string_b, &amp;string_a[max_overlap..]), max_overlap)\n            }\n        } else {\n            (format!(\"{}{}\", string_a, string_b), 0)\n        }\n    }\n\n    fn merge_strings(s1: &amp;str, s2: &amp;str, s3: &amp;str) -&gt; String {\n        let (merged_s1_s2, _) = find_overlap(s1, s2);\n        let (final_merged, _) = find_overlap(&amp;merged_s1_s2, s3);\n        final_merged\n    }\n\n    fn minimum_string(string1: &amp;str, string2: &amp;str, string3: &amp;str) -&gt; String {\n        let all_permutations = vec![\n            (string1, string2, string3),\n            (string1, string3, string2),\n            (string2, string1, string3),\n            (string2, string3, string1),\n            (string3, string1, string2),\n            (string3, string2, string1),\n        ];\n\n        all_permutations.into_iter()\n            .map(|(s1, s2, s3)| merge_strings(s1, s2, s3))\n            .min_by_key(|s| (s.len(), s.clone()))\n            .unwrap()\n    }\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Solution {\n    public string MinimumString(string string1, string string2, string string3) {\n        List&lt;int&gt; BuildSuffixArray(string text) {\n            int textLength = text.Length;\n            var suffixArray = Enumerable.Range(0, textLength).ToList();\n            var rank = text.Select(c =&gt; (int)c).ToList();\n            var tempRank = new List&lt;int&gt;(new int[textLength]);\n            int chunkSize = 1;\n\n            while (chunkSize &lt; textLength) {\n                suffixArray.Sort((i, j) =&gt; {\n                    int secondRankI = i + chunkSize &lt; textLength ? rank[i + chunkSize] : -1;\n                    int secondRankJ = j + chunkSize &lt; textLength ? rank[j + chunkSize] : -1;\n                    return (rank[i], secondRankI).CompareTo((rank[j], secondRankJ));\n                });\n\n                for (int i = 1; i &lt; textLength; i++) {\n                    tempRank[i] = tempRank[i - 1] + (\n                        (rank[suffixArray[i]], suffixArray[i] + chunkSize &lt; textLength ? rank[suffixArray[i] + chunkSize] : -1) != \n                        (rank[suffixArray[i - 1]], suffixArray[i - 1] + chunkSize &lt; textLength ? rank[suffixArray[i - 1] + chunkSize] : -1) \n                        ? 1 : 0);\n                }\n                for (int i = 0; i &lt; textLength; i++) {\n                    rank[suffixArray[i]] = tempRank[i];\n                }\n                if (tempRank[textLength - 1] == textLength - 1) {\n                    break;\n                }\n                chunkSize *= 2;\n            }\n            return suffixArray;\n        }\n\n        List&lt;int&gt; BuildLCPArray(string text, List&lt;int&gt; suffixArray) {\n            int textLength = text.Length;\n            var rank = new int[textLength];\n            for (int i = 0; i &lt; textLength; i++) {\n                rank[suffixArray[i]] = i;\n            }\n            var lcp = new List&lt;int&gt;(new int[textLength - 1]);\n            int k = 0;\n            for (int i = 0; i &lt; textLength; i++) {\n                if (rank[i] == textLength - 1) {\n                    k = 0;\n                    continue;\n                }\n                int j = suffixArray[rank[i] + 1];\n                while (i + k &lt; textLength &amp;&amp; j + k &lt; textLength &amp;&amp; text[i + k] == text[j + k]) {\n                    k++;\n                }\n                lcp[rank[i]] = k;\n                if (k &gt; 0) {\n                    k--;\n                }\n            }\n            return lcp;\n        }\n\n        (string, int) FindOverlap(string stringA, string stringB) {\n            string combinedString = stringA + \"#\" + stringB;\n            var suffixArray = BuildSuffixArray(combinedString);\n            var lcpArray = BuildLCPArray(combinedString, suffixArray);\n\n            int maxOverlap = 0;\n            for (int i = 0; i &lt; combinedString.Length - 1; i++) {\n                if ((suffixArray[i] &lt; stringA.Length) != (suffixArray[i + 1] &lt; stringA.Length)) {\n                    maxOverlap = Math.Max(maxOverlap, lcpArray[i]);\n                }\n            }\n\n            if (stringA.Contains(stringB)) {\n                return (stringB, stringA.Length);\n            } else if (stringB.Contains(stringA)) {\n                return (stringA, stringB.Length);\n            } else if (maxOverlap &gt; 0) {\n                if (suffixArray[maxOverlap] &lt; stringA.Length) {\n                    return (stringA + stringB.Substring(maxOverlap), maxOverlap);\n                } else {\n                    return (stringB + stringA.Substring(maxOverlap), maxOverlap);\n                }\n            } else {\n                return (stringA + stringB, 0);\n            }\n        }\n\n        string MergeStrings(string s1, string s2, string s3) {\n            var (mergedS1S2, _) = FindOverlap(s1, s2);\n            var (finalMerged, _) = FindOverlap(mergedS1S2, s3);\n            return finalMerged;\n        }\n\n        var allPermutations = new List&lt;(string, string, string)&gt; {\n            (string1, string2, string3),\n            (string1, string3, string2),\n            (string2, string1, string3),\n            (string2, string3, string1),\n            (string3, string1, string2),\n            (string3, string2, string1)\n        };\n\n        return allPermutations\n            .Select(p =&gt; MergeStrings(p.Item1, p.Item2, p.Item3))\n            .OrderBy(result =&gt; (result.Length, result))\n            .First();\n    }\n}\n</code></pre> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n    public static String minimumString(String string1, String string2, String string3) {\n        List&lt;Integer&gt; buildSuffixArray(String text) {\n            int textLength = text.length();\n            Integer[] suffixArray = new Integer[textLength];\n            for (int i = 0; i &lt; textLength; i++) {\n                suffixArray[i] = i;\n            }\n            int[] rank = new int[textLength];\n            for (int i = 0; i &lt; textLength; i++) {\n                rank[i] = text.charAt(i);\n            }\n            int[] tempRank = new int[textLength];\n            int chunkSize = 1;\n\n            while (chunkSize &lt; textLength) {\n                Arrays.sort(suffixArray, (i, j) -&gt; {\n                    int secondRankI = i + chunkSize &lt; textLength ? rank[i + chunkSize] : -1;\n                    int secondRankJ = j + chunkSize &lt; textLength ? rank[j + chunkSize] : -1;\n                    return rank[i] == rank[j] ? Integer.compare(secondRankI, secondRankJ) : Integer.compare(rank[i], rank[j]);\n                });\n\n                tempRank[suffixArray[0]] = 0;\n                for (int i = 1; i &lt; textLength; i++) {\n                    tempRank[suffixArray[i]] = tempRank[suffixArray[i - 1]] + (\n                            (rank[suffixArray[i]] != rank[suffixArray[i - 1]] ||\n                                    (suffixArray[i] + chunkSize &lt; textLength ? rank[suffixArray[i] + chunkSize] : -1) !=\n                                            (suffixArray[i - 1] + chunkSize &lt; textLength ? rank[suffixArray[i - 1] + chunkSize] : -1)) ? 1 : 0\n                    );\n                }\n                for (int i = 0; i &lt; textLength; i++) {\n                    rank[i] = tempRank[i];\n                }\n                if (tempRank[textLength - 1] == textLength - 1) {\n                    break;\n                }\n                chunkSize *= 2;\n            }\n\n            return Arrays.asList(suffixArray);\n        }\n\n        List&lt;Integer&gt; buildLCPArray(String text, List&lt;Integer&gt; suffixArray) {\n            int textLength = text.length();\n            int[] rank = new int[textLength];\n            for (int i = 0; i &lt; textLength; i++) {\n                rank[suffixArray.get(i)] = i;\n            }\n            int[] lcp = new int[textLength - 1];\n            int k = 0;\n            for (int i = 0; i &lt; textLength; i++) {\n                if (rank[i] == textLength - 1) {\n                    k = 0;\n                    continue;\n                }\n                int j = suffixArray.get(rank[i] + 1);\n                while (i + k &lt; textLength &amp;&amp; j + k &lt; textLength &amp;&amp; text.charAt(i + k) == text.charAt(j + k)) {\n                    k++;\n                }\n                lcp[rank[i]] = k;\n                if (k &gt; 0) {\n                    k--;\n                }\n            }\n\n            return Arrays.asList(lcp);\n        }\n\n        String mergeStrings(String s1, String s2, String s3) {\n            String mergedS1S2 = findOverlap(s1, s2).getFirst();\n            return findOverlap(mergedS1S2, s3).getFirst();\n        }\n\n        Pair&lt;String, Integer&gt; findOverlap(String stringA, String stringB) {\n            String combinedString = stringA + \"#\" + stringB;\n            List&lt;Integer&gt; suffixArray = buildSuffixArray(combinedString);\n            List&lt;Integer&gt; lcpArray = buildLCPArray(combinedString, suffixArray);\n\n            int maxOverlap = 0;\n            for (int i = 0; i &lt; combinedString.length() - 1; i++) {\n                if ((suffixArray.get(i) &lt; stringA.length()) != (suffixArray.get(i + 1) &lt; stringA.length())) {\n                    maxOverlap = Math.max(maxOverlap, lcpArray.get(i));\n                }\n            }\n\n            if (stringA.contains(stringB)) {\n                return new Pair&lt;&gt;(stringB, stringA.length());\n            } else if (stringB.contains(stringA)) {\n                return new Pair&lt;&gt;(stringA, stringB.length());\n            } else if (maxOverlap &gt; 0) {\n                return suffixArray.get(maxOverlap) &lt; stringA.length()\n                        ? new Pair&lt;&gt;(stringA + stringB.substring(maxOverlap), maxOverlap)\n                        : new Pair&lt;&gt;(stringB + stringA.substring(maxOverlap), maxOverlap);\n            } else {\n                return new Pair&lt;&gt;(stringA + stringB, 0);\n            }\n        }\n\n        List&lt;Pair&lt;String, String, String&gt;&gt; allPermutations = List.of(\n                new Pair&lt;&gt;(string1, string2, string3),\n                new Pair&lt;&gt;(string1, string3, string2),\n                new Pair&lt;&gt;(string2, string1, string3),\n                new Pair&lt;&gt;(string2, string3, string1),\n                new Pair&lt;&gt;(string3, string1, string2),\n                new Pair&lt;&gt;(string3, string2, string1)\n        );\n\n        return allPermutations.stream()\n                .map(p -&gt; mergeStrings(p.getFirst(), p.getSecond(), p.getThird()))\n                .min(Comparator.comparingInt(String::length).thenComparing(String::compareTo))\n                .get();\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def minimumString(string1: String, string2: String, string3: String): String = {\n\n        def buildSuffixArray(text: String): Array[Int] = {\n            val textLength = text.length\n            val suffixArray = (0 until textLength).toArray\n            val rank = text.map(_.toInt).toArray\n            val tempRank = Array.ofDim[Int](textLength)\n            var chunkSize = 1\n\n            while (chunkSize &lt; textLength) {\n                java.util.Arrays.sort(suffixArray, (i: Int, j: Int) =&gt; {\n                val secondRankI = if (i + chunkSize &lt; textLength) rank(i + chunkSize) else -1\n                val secondRankJ = if (j + chunkSize &lt; textLength) rank(j + chunkSize) else -1\n                if (rank(i) == rank(j)) Integer.compare(secondRankI, secondRankJ) else Integer.compare(rank(i), rank(j))\n                })\n\n                tempRank(suffixArray(0)) = 0\n                for (i &lt;- 1 until textLength) {\n                val currentSecondRank = if (suffixArray(i) + chunkSize &lt; textLength) rank(suffixArray(i) + chunkSize) else -1\n                val prevSecondRank = if (suffixArray(i - 1) + chunkSize &lt; textLength) rank(suffixArray(i - 1) + chunkSize) else -1\n                tempRank(suffixArray(i)) = tempRank(suffixArray(i - 1)) + (if (rank(suffixArray(i)) != rank(suffixArray(i - 1)) || currentSecondRank != prevSecondRank) 1 else 0)\n                }\n                for (i &lt;- 0 until textLength) {\n                rank(i) = tempRank(i)\n                }\n                if (tempRank(textLength - 1) == textLength - 1) {\n                return suffixArray\n                }\n                chunkSize *= 2\n            }\n\n            suffixArray\n        }\n\n        def buildLCPArray(text: String, suffixArray: Array[Int]): Array[Int] = {\n            val textLength = text.length\n            val rank = Array.ofDim[Int](textLength)\n            val lcp = Array.ofDim[Int](textLength - 1)\n            for (i &lt;- 0 until textLength) {\n                rank(suffixArray(i)) = i\n            }\n            var k = 0\n            for (i &lt;- 0 until textLength) {\n                if (rank(i) == textLength - 1) {\n                k = 0\n                } else {\n                val j = suffixArray(rank(i) + 1)\n                while (i + k &lt; textLength &amp;&amp; j + k &lt; textLength &amp;&amp; text.charAt(i + k) == text.charAt(j + k)) {\n                    k += 1\n                }\n                lcp(rank(i)) = k\n                if (k &gt; 0) k -= 1\n                }\n            }\n\n            lcp\n        }\n\n        def mergeStrings(s1: String, s2: String, s3: String): String = {\n            val (mergedS1S2, _) = findOverlap(s1, s2)\n            val (finalMerged, _) = findOverlap(mergedS1S2, s3)\n            finalMerged\n        }\n\n        def findOverlap(stringA: String, stringB: String): (String, Int) = {\n            val combinedString = s\"$stringA#$stringB\"\n            val suffixArray = buildSuffixArray(combinedString)\n            val lcpArray = buildLCPArray(combinedString, suffixArray)\n\n            var maxOverlap = 0\n            for (i &lt;- 0 until combinedString.length - 1) {\n                if ((suffixArray(i) &lt; stringA.length) != (suffixArray(i + 1) &lt; stringA.length)) {\n                maxOverlap = math.max(maxOverlap, lcpArray(i))\n                }\n            }\n\n            if (stringA.contains(stringB)) {\n                (stringB, stringA.length)\n            } else if (stringB.contains(stringA)) {\n                (stringA, stringB.length)\n            } else if (maxOverlap &gt; 0) {\n                if (suffixArray(maxOverlap) &lt; stringA.length) {\n                (stringA + stringB.substring(maxOverlap), maxOverlap)\n                } else {\n                (stringB + stringA.substring(maxOverlap), maxOverlap)\n                }\n            } else {\n                (stringA + stringB, 0)\n            }\n        }\n\n        val allPermutations = Seq(\n        (string1, string2, string3),\n        (string1, string3, string2),\n        (string2, string1, string3),\n        (string2, string3, string1),\n        (string3, string1, string2),\n        (string3, string2, string1)\n        )\n\n        allPermutations\n        .map { case (a, b, c) =&gt; mergeStrings(a, b, c) }\n        .minBy(s =&gt; (s.length, s))\n    }\n}\n</code></pre> <pre><code>import kotlin.math.max\n\nclass Solution {\n    fun minimumString(string1: String, string2: String, string3: String): String {\n\n        fun buildSuffixArray(text: String): List&lt;Int&gt; {\n            val textLength = text.length\n            var suffixArray = (0 until textLength).toList()\n            val rank = text.map { it.toInt() }\n            var tempRank = List(textLength) { 0 }\n            var chunkSize = 1\n\n            while (chunkSize &lt; textLength) {\n                suffixArray = suffixArray.sortedWith(compareBy({ i -&gt; Pair(rank[i], rank.getOrElse(i + chunkSize) { -1 }) }))\n                for (i in 1 until textLength) {\n                    tempRank[i] = tempRank[i - 1] + if (\n                        Pair(rank[suffixArray[i]],\n                            rank.getOrElse(suffixArray[i] + chunkSize) { -1 }) != Pair(rank[suffixArray[i - 1]],\n                            rank.getOrElse(suffixArray[i - 1] + chunkSize) { -1 })\n                    ) 1 else 0\n                }\n                for (i in 0 until textLength) {\n                    rank[suffixArray[i]] = tempRank[i]\n                }\n                if (tempRank[textLength - 1] == textLength - 1) {\n                    break\n                }\n                chunkSize *= 2\n            }\n            return suffixArray\n        }\n\n        fun buildLCPArray(text: String, suffixArray: List&lt;Int&gt;): List&lt;Int&gt; {\n            val textLength = text.length\n            val rank = MutableList(textLength) { 0 }\n            suffixArray.forEachIndexed { i, sa -&gt; rank[sa] = i }\n            val lcp = MutableList(textLength - 1) { 0 }\n            var k = 0\n\n            for (i in 0 until textLength) {\n                if (rank[i] == textLength - 1) {\n                    k = 0\n                    continue\n                }\n                var j = suffixArray[rank[i] + 1]\n                while (i + k &lt; textLength &amp;&amp; j + k &lt; textLength &amp;&amp; text[i + k] == text[j + k]) {\n                    k++\n                }\n                lcp[rank[i]] = k\n                if (k &gt; 0) k--\n            }\n            return lcp\n        }\n\n        fun findOverlap(stringA: String, stringB: String): Pair&lt;String, Int&gt; {\n            val combinedString = \"$stringA#$stringB\"\n            val suffixArray = buildSuffixArray(combinedString)\n            val lcpArray = buildLCPArray(combinedString, suffixArray)\n\n            var maxOverlap = 0\n            for (i in 0 until combinedString.length - 1) {\n                if ((suffixArray[i] &lt; stringA.length) != (suffixArray[i + 1] &lt; stringA.length)) {\n                    maxOverlap = max(maxOverlap, lcpArray[i])\n                }\n            }\n\n            if (stringA in stringB) {\n                return Pair(stringB, stringA.length)\n            } else if (stringB in stringA) {\n                return Pair(stringA, stringB.length)\n            } else if (maxOverlap &gt; 0) {\n                return if (suffixArray[maxOverlap] &lt; stringA.length) {\n                    Pair(stringA + stringB.substring(maxOverlap), maxOverlap)\n                } else {\n                    Pair(stringB + stringA.substring(maxOverlap), maxOverlap)\n                }\n            } else {\n                return Pair(stringA + stringB, 0)\n            }\n        }\n\n        fun mergeStrings(s1: String, s2: String, s3: String): String {\n            val (mergedS1S2, _) = findOverlap(s1, s2)\n            val (finalMerged, _) = findOverlap(mergedS1S2, s3)\n            return finalMerged\n        }\n\n        val allPermutations = listOf(\n            Triple(string1, string2, string3), Triple(string1, string3, string2),\n            Triple(string2, string1, string3), Triple(string2, string3, string1),\n            Triple(string3, string1, string2), Triple(string3, string2, string1)\n        )\n\n        return allPermutations.map { (a, b, c) -&gt; mergeStrings(a, b, c) }.minByOrNull { it.length } ?: \"\"\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val result = solution.minimumString(\"abc\", \"bca\", \"aaa\")\n    println(\"Minimum String: $result\")\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\ntype Solution struct{}\n\nfunc (s *Solution) buildSuffixArray(text string) []int {\n    textLength := len(text)\n    suffixArray := make([]int, textLength)\n    rank := make([]int, textLength)\n    tempRank := make([]int, textLength)\n\n    for i := 0; i &lt; textLength; i++ {\n        suffixArray[i] = i\n        rank[i] = int(text[i])\n    }\n\n    chunkSize := 1\n    for chunkSize &lt; textLength {\n        sort.SliceStable(suffixArray, func(i, j int) bool {\n            firstRankI := rank[suffixArray[i]]\n            secondRankI := -1\n            if suffixArray[i]+chunkSize &lt; textLength {\n                secondRankI = rank[suffixArray[i]+chunkSize]\n            }\n\n            firstRankJ := rank[suffixArray[j]]\n            secondRankJ := -1\n            if suffixArray[j]+chunkSize &lt; textLength {\n                secondRankJ = rank[suffixArray[j]+chunkSize]\n            }\n\n            if firstRankI == firstRankJ {\n                return secondRankI &lt; secondRankJ\n            }\n            return firstRankI &lt; firstRankJ\n        })\n\n        tempRank[suffixArray[0]] = 0\n        for i := 1; i &lt; textLength; i++ {\n            if rank[suffixArray[i]] != rank[suffixArray[i-1]] || (suffixArray[i]+chunkSize &lt; textLength &amp;&amp; rank[suffixArray[i]+chunkSize] != rank[suffixArray[i-1]+chunkSize]) {\n                tempRank[suffixArray[i]] = tempRank[suffixArray[i-1]] + 1\n            } else {\n                tempRank[suffixArray[i]] = tempRank[suffixArray[i-1]]\n            }\n        }\n\n        for i := 0; i &lt; textLength; i++ {\n            rank[i] = tempRank[i]\n        }\n\n        if tempRank[textLength-1] == textLength-1 {\n            break\n        }\n\n        chunkSize *= 2\n    }\n\n    return suffixArray\n}\n\nfunc (s *Solution) buildLCPArray(text string, suffixArray []int) []int {\n    textLength := len(text)\n    rank := make([]int, textLength)\n    lcp := make([]int, textLength-1)\n\n    for i := 0; i &lt; textLength; i++ {\n        rank[suffixArray[i]] = i\n    }\n\n    k := 0\n    for i := 0; i &lt; textLength; i++ {\n        if rank[i] == textLength-1 {\n            k = 0\n            continue\n        }\n        j := suffixArray[rank[i]+1]\n        for i+k &lt; textLength &amp;&amp; j+k &lt; textLength &amp;&amp; text[i+k] == text[j+k] {\n            k++\n        }\n        lcp[rank[i]] = k\n        if k &gt; 0 {\n            k--\n        }\n    }\n\n    return lcp\n}\n\nfunc (s *Solution) findOverlap(stringA, stringB string) (string, int) {\n    combinedString := stringA + \"#\" + stringB\n    suffixArray := s.buildSuffixArray(combinedString)\n    lcpArray := s.buildLCPArray(combinedString, suffixArray)\n\n    maxOverlap := 0\n    for i := 0; i &lt; len(combinedString)-1; i++ {\n        if (suffixArray[i] &lt; len(stringA)) != (suffixArray[i+1] &lt; len(stringA)) {\n            if lcpArray[i] &gt; maxOverlap {\n                maxOverlap = lcpArray[i]\n            }\n        }\n    }\n\n    if strings.Contains(stringA, stringB) {\n        return stringA, len(stringA)\n    } else if strings.Contains(stringB, stringA) {\n        return stringB, len(stringB)\n    } else if maxOverlap &gt; 0 {\n        if suffixArray[maxOverlap] &lt; len(stringA) {\n            return stringA + stringB[maxOverlap:], maxOverlap\n        }\n        return stringB + stringA[maxOverlap:], maxOverlap\n    } else {\n        return stringA + stringB, 0\n    }\n}\n\nfunc (s *Solution) mergeStrings(s1, s2, s3 string) string {\n    mergedS1S2, _ := s.findOverlap(s1, s2)\n    finalMerged, _ := s.findOverlap(mergedS1S2, s3)\n    return finalMerged\n}\n\nfunc (s *Solution) minimumString(string1, string2, string3 string) string {\n    permutations := [][]string{\n        {string1, string2, string3},\n        {string1, string3, string2},\n        {string2, string1, string3},\n        {string2, string3, string1},\n        {string3, string1, string2},\n        {string3, string2, string1},\n    }\n\n    var result string\n    for _, perm := range permutations {\n        merged := s.mergeStrings(perm[0], perm[1], perm[2])\n        if result == \"\" || len(merged) &lt; len(result) || (len(merged) == len(result) &amp;&amp; merged &lt; result) {\n            result = merged\n        }\n    }\n\n    return result\n}\n\nfunc main() {\n    s := Solution{}\n    fmt.Println(s.minimumString(\"abc\", \"def\", \"ghi\"))\n}\n</code></pre> <pre><code>class Solution {\n    buildSuffixArray(text: string): number[] {\n        const textLength = text.length;\n        const suffixArray = Array.from({ length: textLength }, (_, i) =&gt; i);\n        let rank = text.split('').map(char =&gt; char.charCodeAt(0));\n        const tempRank = Array(textLength).fill(0);\n        let chunkSize = 1;\n\n        while (chunkSize &lt; textLength) {\n            suffixArray.sort((i, j) =&gt; {\n                const secondRankI = i + chunkSize &lt; textLength ? rank[i + chunkSize] : -1;\n                const secondRankJ = j + chunkSize &lt; textLength ? rank[j + chunkSize] : -1;\n                return rank[i] === rank[j] ? secondRankI - secondRankJ : rank[i] - rank[j];\n            });\n\n            tempRank[suffixArray[0]] = 0;\n            for (let i = 1; i &lt; textLength; i++) {\n                const currentSecondRank = suffixArray[i] + chunkSize &lt; textLength ? rank[suffixArray[i] + chunkSize] : -1;\n                const prevSecondRank = suffixArray[i - 1] + chunkSize &lt; textLength ? rank[suffixArray[i - 1] + chunkSize] : -1;\n                tempRank[suffixArray[i]] = tempRank[suffixArray[i - 1]] + (rank[suffixArray[i]] !== rank[suffixArray[i - 1]] || currentSecondRank !== prevSecondRank ? 1 : 0);\n            }\n            rank = [...tempRank];\n\n            if (tempRank[textLength - 1] === textLength - 1) {\n                break;\n            }\n\n            chunkSize *= 2;\n        }\n\n        return suffixArray;\n    }\n\n    buildLCPArray(text: string, suffixArray: number[]): number[] {\n        const textLength = text.length;\n        const rank = Array(textLength).fill(0);\n        const lcp = Array(textLength - 1).fill(0);\n\n        suffixArray.forEach((sa, i) =&gt; rank[sa] = i);\n\n        let k = 0;\n        for (let i = 0; i &lt; textLength; i++) {\n            if (rank[i] === textLength - 1) {\n                k = 0;\n                continue;\n            }\n            const j = suffixArray[rank[i] + 1];\n            while (i + k &lt; textLength &amp;&amp; j + k &lt; textLength &amp;&amp; text[i + k] === text[j + k]) {\n                k++;\n            }\n            lcp[rank[i]] = k;\n            if (k &gt; 0) k--;\n        }\n\n        return lcp;\n    }\n\n    mergeStrings(s1: string, s2: string, s3: string): string {\n        const mergedS1S2 = this.findOverlap(s1, s2).merged;\n        return this.findOverlap(mergedS1S2, s3).merged;\n    }\n\n    findOverlap(stringA: string, stringB: string): { merged: string, overlap: number } {\n        const combinedString = `${stringA}#${stringB}`;\n        const suffixArray = this.buildSuffixArray(combinedString);\n        const lcpArray = this.buildLCPArray(combinedString, suffixArray);\n\n        let maxOverlap = 0;\n        for (let i = 0; i &lt; combinedString.length - 1; i++) {\n            const isDifferentSide = (suffixArray[i] &lt; stringA.length) !== (suffixArray[i + 1] &lt; stringA.length);\n            if (isDifferentSide &amp;&amp; lcpArray[i] &gt; maxOverlap) {\n                maxOverlap = lcpArray[i];\n            }\n        }\n\n        if (stringA.includes(stringB)) {\n            return { merged: stringA, overlap: stringA.length };\n        } else if (stringB.includes(stringA)) {\n            return { merged: stringB, overlap: stringB.length };\n        } else if (maxOverlap &gt; 0) {\n            if (suffixArray[maxOverlap] &lt; stringA.length) {\n                return { merged: stringA + stringB.slice(maxOverlap), overlap: maxOverlap };\n            }\n            return { merged: stringB + stringA.slice(maxOverlap), overlap: maxOverlap };\n        } else {\n            return { merged: stringA + stringB, overlap: 0 };\n        }\n    }\n\n    minimumString(string1: string, string2: string, string3: string): string {\n        const permutations = [\n            [string1, string2, string3],\n            [string1, string3, string2],\n            [string2, string1, string3],\n            [string2, string3, string1],\n            [string3, string1, string2],\n            [string3, string2, string1]\n        ];\n\n        return permutations\n            .map(([a, b, c]) =&gt; this.mergeStrings(a, b, c))\n            .reduce((min, current) =&gt; current.length &lt; min.length || (current.length === min.length &amp;&amp; current &lt; min) ? current : min);\n    }\n}\n\nconst solution = new Solution();\nconsole.log(solution.minimumString(\"abc\", \"bca\", \"aaa\"));\n</code></pre> <pre><code>#library(R6)\n#Solution &lt;- R6::R6Class(\"Solution\",\nSolution &lt;- setRefClass(\"Solution\",    \n    public = list(\n        build_suffix_array &lt;- function(text) {\n            text_length &lt;- nchar(text)\n            suffix_array &lt;- 0:(text_length - 1)\n            rank &lt;- as.integer(charToRaw(substr(text, suffix_array + 1, suffix_array + 1)))\n            temp_rank &lt;- integer(text_length)\n            chunk_size &lt;- 1\n\n            while (chunk_size &lt; text_length) {\n                suffix_array &lt;- suffix_array[order(rank[suffix_array + 1], rank[suffix_array + chunk_size])]\n\n                temp_rank[suffix_array[1]] &lt;- 0\n                for (i in 2:text_length) {\n                current_second_rank &lt;- ifelse(suffix_array[i] + chunk_size &lt; text_length, rank[suffix_array[i] + chunk_size], -1)\n                prev_second_rank &lt;- ifelse(suffix_array[i - 1] + chunk_size &lt; text_length, rank[suffix_array[i - 1] + chunk_size], -1)\n                temp_rank[suffix_array[i]] &lt;- temp_rank[suffix_array[i - 1]] + \n                    ((rank[suffix_array[i]] != rank[suffix_array[i - 1]]) || (current_second_rank != prev_second_rank))\n                }\n\n                rank &lt;- temp_rank\n\n                if (temp_rank[text_length] == text_length - 1) {\n                break\n                }\n\n                chunk_size &lt;- chunk_size * 2\n            }\n\n            suffix_array\n        }\n\n        build_lcp_array &lt;- function(text, suffix_array) {\n            text_length &lt;- nchar(text)\n            rank &lt;- integer(text_length)\n            lcp &lt;- integer(text_length - 1)\n\n            for (i in seq_along(suffix_array)) {\n                rank[suffix_array[i] + 1] &lt;- i - 1\n            }\n\n            k &lt;- 0\n            for (i in 0:(text_length - 1)) {\n                if (rank[i + 1] == text_length - 1) {\n                k &lt;- 0\n                next\n                }\n\n                j &lt;- suffix_array[rank[i + 1] + 2]\n                while (i + k &lt; text_length &amp;&amp; j + k &lt; text_length &amp;&amp; substr(text, i + k + 1, i + k + 1) == substr(text, j + k + 1, j + k + 1)) {\n                k &lt;- k + 1\n                }\n\n                lcp[rank[i + 1]] &lt;- k\n                if (k &gt; 0) k &lt;- k - 1\n            }\n\n            lcp\n        }\n\n        find_overlap &lt;- function(stringA, stringB) {\n            combined_string &lt;- paste0(stringA, \"#\", stringB)\n            suffix_array &lt;- build_suffix_array(combined_string)\n            lcp_array &lt;- build_lcp_array(combined_string, suffix_array)\n\n            max_overlap &lt;- 0\n            for (i in seq_along(suffix_array) - 1) {\n                if ((suffix_array[i] &lt; nchar(stringA)) != (suffix_array[i + 1] &lt; nchar(stringA))) {\n                max_overlap &lt;- max(max_overlap, lcp_array[i])\n                }\n            }\n\n            if (grepl(stringB, stringA)) {\n                return(list(merged = stringA, overlap = nchar(stringA)))\n            } else if (grepl(stringA, stringB)) {\n                return(list(merged = stringB, overlap = nchar(stringB)))\n            } else if (max_overlap &gt; 0) {\n                if (suffix_array[1] &lt; nchar(stringA)) {\n                return(list(merged = paste0(stringA, substr(stringB, max_overlap + 1, nchar(stringB))), overlap = max_overlap))\n                } else {\n                return(list(merged = paste0(stringB, substr(stringA, max_overlap + 1, nchar(stringA))), overlap = max_overlap))\n                }\n            } else {\n                return(list(merged = paste0(stringA, stringB), overlap = 0))\n            }\n        }\n\n        merge_strings &lt;- function(s1, s2, s3) {\n            merged_s1_s2 &lt;- find_overlap(s1, s2)$merged\n            final_merged &lt;- find_overlap(merged_s1_s2, s3)$merged\n            final_merged\n        }\n\n        minimum_string &lt;- function(string1, string2, string3) {\n            permutations &lt;- list(\n                c(string1, string2, string3),\n                c(string1, string3, string2),\n                c(string2, string1, string3),\n                c(string2, string3, string1),\n                c(string3, string1, string2),\n                c(string3, string2, string1)\n            )\n\n            result &lt;- permutations[[1]]\n            result_string &lt;- merge_strings(result[1], result[2], result[3])\n\n            for (perm in permutations) {\n                merged &lt;- merge_strings(perm[1], perm[2], perm[3])\n                if (nchar(merged) &lt; nchar(result_string) || (nchar(merged) == nchar(result_string) &amp;&amp; merged &lt; result_string)) {\n                result_string &lt;- merged\n                }\n            }\n\n            result_string\n        }\n    )\n)\n\n# Example usage:\nsolution &lt;- Solution$new()\nsolution$minimumString(\"abc\", \"def\", \"ghi\")\nprint(solution$minimumString(\"abc\", \"bca\", \"aaa\"))\n</code></pre> <pre><code>module SolutionModule\n\nusing Printf\n\nexport Solution\n\n# Define the Solution class\nmutable struct Solution\n    function Solution() end\nend\n\n# Method to build suffix array\nfunction Solution.build_suffix_array(s::Solution, text::String)::Vector{Int}\n    text_length = length(text)\n    suffix_array = 0:text_length-1\n    rank = [Int(text[i]) for i in 1:text_length]\n    temp_rank = zeros(Int, text_length)\n    chunk_size = 1\n\n    while chunk_size &lt; text_length\n        sort!(suffix_array, by = i -&gt; (rank[suffix_array[i] + 1], suffix_array[i] + chunk_size &lt;= text_length ? rank[suffix_array[i] + chunk_size + 1] : -1))\n\n        temp_rank[suffix_array[1] + 1] = 0\n        for i in 2:text_length\n            current_second_rank = suffix_array[i] + chunk_size &lt;= text_length ? rank[suffix_array[i] + chunk_size + 1] : -1\n            prev_second_rank = suffix_array[i - 1] + chunk_size &lt;= text_length ? rank[suffix_array[i - 1] + chunk_size + 1] : -1\n            temp_rank[suffix_array[i] + 1] = temp_rank[suffix_array[i - 1] + 1] + (rank[suffix_array[i] + 1] != rank[suffix_array[i - 1] + 1] || current_second_rank != prev_second_rank ? 1 : 0)\n        end\n\n        rank .= temp_rank\n\n        if temp_rank[text_length] == text_length - 1\n            break\n        end\n\n        chunk_size *= 2\n    end\n\n    suffix_array\nend\n\n# Method to build LCP array\nfunction Solution.build_lcp_array(s::Solution, text::String, suffix_array::Vector{Int})::Vector{Int}\n    text_length = length(text)\n    rank = zeros(Int, text_length)\n    lcp = zeros(Int, text_length - 1)\n\n    for (i, sa) in enumerate(suffix_array)\n        rank[sa + 1] = i - 1\n    end\n\n    k = 0\n    for i in 0:text_length-1\n        if rank[i + 1] == text_length - 1\n            k = 0\n            continue\n        end\n\n        j = suffix_array[rank[i + 1] + 2]\n        while i + k &lt; text_length &amp;&amp; j + k &lt; text_length &amp;&amp; text[i + k + 1] == text[j + k + 1]\n            k += 1\n        end\n\n        lcp[rank[i + 1]] = k\n        if k &gt; 0\n            k -= 1\n        end\n    end\n\n    lcp\nend\n\n# Method to find overlap\nfunction Solution.find_overlap(s::Solution, stringA::String, stringB::String)::Tuple{String, Int}\n    combined_string = stringA * \"#\" * stringB\n    suffix_array = Solution.build_suffix_array(s, combined_string)\n    lcp_array = Solution.build_lcp_array(s, combined_string, suffix_array)\n\n    max_overlap = 0\n    for i in 1:length(suffix_array) - 1\n        if (suffix_array[i] &lt; length(stringA)) != (suffix_array[i + 1] &lt; length(stringA))\n            max_overlap = max(max_overlap, lcp_array[i])\n        end\n    end\n\n    if occursin(stringB, stringA)\n        return (stringA, length(stringA))\n    elseif occursin(stringA, stringB)\n        return (stringB, length(stringB))\n    elseif max_overlap &gt; 0\n        if suffix_array[max_overlap] &lt; length(stringA)\n            return (stringA * stringB[max_overlap + 1:end], max_overlap)\n        else\n            return (stringB * stringA[max_overlap + 1:end], max_overlap)\n        end\n    else\n        return (stringA * stringB, 0)\n    end\nend\n\n# Method to merge strings\nfunction Solution.merge_strings(s::Solution, s1::String, s2::String, s3::String)::String\n    merged_s1_s2, _ = Solution.find_overlap(s, s1, s2)\n    final_merged, _ = Solution.find_overlap(s, merged_s1_s2, s3)\n    final_merged\nend\n\n# Method to find minimum string\nfunction Solution.minimum_string(s::Solution, string1::String, string2::String, string3::String)::String\n    permutations = [\n        (string1, string2, string3),\n        (string1, string3, string2),\n        (string2, string1, string3),\n        (string2, string3, string1),\n        (string3, string1, string2),\n        (string3, string2, string1)\n    ]\n\n    result = permutations[1]\n    result_string = Solution.merge_strings(s, result[1], result[2], result[3])\n\n    for perm in permutations\n        merged = Solution.merge_strings(s, perm[1], perm[2], perm[3])\n        if length(merged) &lt; length(result_string) || (length(merged) == length(result_string) &amp;&amp; merged &lt; result_string)\n            result_string = merged\n        end\n    end\n\n    result_string\nend\n\nend\n\n# Usage\nusing .SolutionModule\n\nsol = SolutionModule.Solution()\nprintln(SolutionModule.Solution.minimum_string(sol, \"abc\", \"bca\", \"aaa\"))\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/","title":"Linked List","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#design-a-linked-list","title":"Design a Linked List","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#problem-description-leetcode-problem-707-design-a-linked-list","title":"Problem Description: LeetCode - Problem 707 - Design a Linked List","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solution-explanation","title":"Solution Explanation","text":"<p>This solution defines a doubly linked list using a <code>MyLinkedList</code> class, designed to perform efficient node access, insertion, and deletion operations. Let's go through the design, each method, a walkthrough, and a complexity analysis.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solution-design","title":"Solution Design","text":"<p>The <code>MyLinkedList</code> class uses a doubly linked list structure with two sentinel nodes (<code>__head</code> and <code>__tail</code>) to represent the start and end of the list, simplifying insertion and deletion operations near the list boundaries. The list also keeps track of its current size (<code>__size</code>), which helps in validating indices for operations.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#methods-and-their-explanations","title":"Methods and Their Explanations","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#1-__init__-constructor","title":"1. <code>__init__</code>: Constructor","text":"<p>Initializes the linked list: - <code>__head</code> and <code>__tail</code> are sentinel nodes with no values (<code>-1</code>). - <code>__head.next</code> points to <code>__tail</code>, and <code>__tail.prev</code> points to <code>__head</code>. - <code>__size</code> is initialized to <code>0</code> since the list starts empty.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#2-get-get-the-value-of-a-node-by-index","title":"2. <code>get</code>: Get the Value of a Node by Index","text":"<ul> <li>If the index is within valid bounds, the function traverses from either the head or the tail, whichever is closer to the target index.</li> <li>Left half (<code>0 &lt;= index &lt;= __size // 2</code>): Uses <code>__forward</code> traversal starting from the <code>__head</code>.</li> <li>Right half (<code>__size // 2 &lt; index &lt; __size</code>): Uses <code>__backward</code> traversal starting from the <code>__tail</code>.</li> <li>Returns the node's value at the target index or <code>-1</code> if the index is invalid.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#3-addathead-insert-node-at-the-head","title":"3. <code>addAtHead</code>: Insert Node at the Head","text":"<ul> <li>Calls <code>__add</code>, passing <code>__head</code> as the previous node to insert a new node after <code>__head</code>.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#4-addattail-insert-node-at-the-tail","title":"4. <code>addAtTail</code>: Insert Node at the Tail","text":"<ul> <li>Calls <code>__add</code>, passing <code>__tail.prev</code> as the previous node to insert a new node before <code>__tail</code>.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#5-addatindex-insert-node-at-a-specific-index","title":"5. <code>addAtIndex</code>: Insert Node at a Specific Index","text":"<ul> <li>Checks if the index is within bounds (<code>0 &lt;= index &lt;= __size</code>). If valid:</li> <li>If closer to the head, it calls <code>__forward</code> to find the insertion point.</li> <li>If closer to the tail, it calls <code>__backward</code> to find the insertion point.</li> <li>Inserts the new node at the specified index.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#6-deleteatindex-delete-node-at-a-specific-index","title":"6. <code>deleteAtIndex</code>: Delete Node at a Specific Index","text":"<ul> <li>Checks if the index is valid. If so:</li> <li>Calls <code>__forward</code> or <code>__backward</code> to locate the node to delete.</li> <li>Calls <code>__remove</code> to unlink the node from the list.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#7-__add-helper-for-node-insertion","title":"7. <code>__add</code>: Helper for Node Insertion","text":"<ul> <li>Creates a new <code>Node</code> with the given value, inserts it after <code>preNode</code>, and updates links to include the new node.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#8-__remove-helper-for-node-deletion","title":"8. <code>__remove</code>: Helper for Node Deletion","text":"<ul> <li>Unlinks the specified node from the list by adjusting the <code>next</code> pointer of the node\u2019s <code>prev</code> and the <code>prev</code> pointer of the node\u2019s <code>next</code>.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#9-__forward-and-__backward-helpers-for-traversing-the-list","title":"9. <code>__forward</code> and <code>__backward</code>: Helpers for Traversing the List","text":"<ul> <li><code>__forward</code>: Starts from a given node, traversing forward to reach a specified index.</li> <li><code>__backward</code>: Starts from a given node, traversing backward to reach a specified index.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#example-walkthrough","title":"Example Walkthrough","text":"<pre><code>linked_list = MyLinkedList()\nlinked_list.addAtHead(1)    # List: 1\nlinked_list.addAtTail(2)    # List: 1 -&gt; 2\nlinked_list.addAtIndex(1, 3)  # List: 1 -&gt; 3 -&gt; 2\nprint(linked_list.get(1))   # Output: 3\nlinked_list.deleteAtIndex(1)  # List: 1 -&gt; 2\nprint(linked_list.get(1))   # Output: 2\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#explanation-of-steps","title":"Explanation of Steps:","text":"<ol> <li><code>addAtHead(1)</code>: Creates and inserts a node with value <code>1</code> at the head.</li> <li><code>addAtTail(2)</code>: Creates and appends a node with value <code>2</code> at the tail.</li> <li><code>addAtIndex(1, 3)</code>: Inserts a node with value <code>3</code> at index <code>1</code>, between nodes <code>1</code> and <code>2</code>.</li> <li><code>get(1)</code>: Retrieves the value of the node at index <code>1</code>, which is <code>3</code>.</li> <li><code>deleteAtIndex(1)</code>: Deletes the node at index <code>1</code> (value <code>3</code>), leaving the list as <code>1 -&gt; 2</code>.</li> <li><code>get(1)</code>: Retrieves the value of the node at index <code>1</code>, which is now <code>2</code>.</li> </ol>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#complexity-analysis","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#time-complexity","title":"Time Complexity","text":"<ul> <li><code>get(index)</code>: <code>O(n)</code>, where <code>n</code> is the size of the list.</li> <li>Traverses either forward or backward depending on index proximity to <code>head</code> or <code>tail</code>, requiring up to <code>O(n)</code> operations in the worst case.</li> <li><code>addAtHead(val)</code> and <code>addAtTail(val)</code>: <code>O(1)</code>.</li> <li>Insertion at the head or tail is done in constant time, involving only link adjustments.</li> <li><code>addAtIndex(index, val)</code>: <code>O(n)</code>.</li> <li>Requires traversal to the specified index (up to <code>O(n)</code> operations) before inserting the node.</li> <li><code>deleteAtIndex(index)</code>: <code>O(n)</code>.</li> <li>Requires traversal to locate the node to delete (up to <code>O(n)</code> operations) before unlinking it.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#space-complexity","title":"Space Complexity","text":"<ul> <li>Overall: <code>O(n)</code> for storing <code>n</code> nodes in the list, each requiring space for <code>val</code>, <code>next</code>, and <code>prev</code>.</li> <li>Auxiliary Space: <code>O(1)</code> as all helper methods operate in-place without additional data structures.</li> </ul> <p>This design leverages doubly linked list advantages for efficient node removal and insertion but incurs <code>O(n)</code> time complexity for direct access due to traversal requirements.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solutions","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code># Time:  O(n)\n# Space: O(n)\n\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, value: int) -&gt; None:\n        self.val: int = value\n        self.next: Optional[Node] = None\n        self.prev: Optional[Node] = None\n\n\nclass MyLinkedList:\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__head: Node = Node(-1)\n        self.__tail: Node = Node(-1)\n        self.__head.next = self.__tail\n        self.__tail.prev = self.__head\n        self.__size: int = 0\n\n    def get(self, index: int) -&gt; int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        if 0 &lt;= index &lt;= self.__size // 2:\n            return self.__forward(0, index, self.__head.next).val\n        elif self.__size // 2 &lt; index &lt; self.__size:\n            return self.__backward(self.__size, index, self.__tail).val\n        return -1\n\n    def addAtHead(self, val: int) -&gt; None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list.\n        After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        self.__add(self.__head, val)\n\n    def addAtTail(self, val: int) -&gt; None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        self.__add(self.__tail.prev, val)\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list.\n        If index equals to the length of linked list, the node will be appended to the end of linked list.\n        If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        if 0 &lt;= index &lt;= self.__size // 2:\n            self.__add(self.__forward(0, index, self.__head.next).prev, val)\n        elif self.__size // 2 &lt; index &lt;= self.__size:\n            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        if 0 &lt;= index &lt;= self.__size // 2:\n            self.__remove(self.__forward(0, index, self.__head.next))\n        elif self.__size // 2 &lt; index &lt; self.__size:\n            self.__remove(self.__backward(self.__size, index, self.__tail))\n\n    def __add(self, preNode: Node, val: int) -&gt; None:\n        node = Node(val)\n        node.prev = preNode\n        node.next = preNode.next\n        node.prev.next = node.next.prev = node\n        self.__size += 1\n\n    def __remove(self, node: Node) -&gt; None:\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.__size -= 1\n\n    def __forward(self, start: int, end: int, curr: Node) -&gt; Node:\n        while start != end:\n            start += 1\n            curr = curr.next\n        return curr\n\n    def __backward(self, start: int, end: int, curr: Node) -&gt; Node:\n        while start != end:\n            start -= 1\n            curr = curr.prev\n        return curr\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* prev;\n    Node(int value) : val(value), next(nullptr), prev(nullptr) {}\n};\n\nclass MyLinkedList {\npublic:\n    MyLinkedList() {\n        head = new Node(-1);\n        tail = new Node(-1);\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n        size = 0;\n    }\n\n    int get(int index) {\n        if (index &lt; 0 || index &gt;= size) return -1;\n        Node* curr = (index &lt; size / 2) ? forward(0, index, head-&gt;next) : backward(size, index, tail);\n        return curr-&gt;val;\n    }\n\n    void addAtHead(int val) { add(head, val); }\n\n    void addAtTail(int val) { add(tail-&gt;prev, val); }\n\n    void addAtIndex(int index, int val) {\n        if (index &lt; 0 || index &gt; size) return;\n        Node* preNode = (index &lt;= size / 2) ? forward(0, index, head-&gt;next)-&gt;prev : backward(size, index, tail)-&gt;prev;\n        add(preNode, val);\n    }\n\n    void deleteAtIndex(int index) {\n        if (index &lt; 0 || index &gt;= size) return;\n        Node* node = (index &lt; size / 2) ? forward(0, index, head-&gt;next) : backward(size, index, tail);\n        remove(node);\n    }\n\nprivate:\n    Node* head;\n    Node* tail;\n    int size;\n\n    void add(Node* preNode, int val) {\n        Node* node = new Node(val);\n        node-&gt;prev = preNode;\n        node-&gt;next = preNode-&gt;next;\n        preNode-&gt;next-&gt;prev = node;\n        preNode-&gt;next = node;\n        ++size;\n    }\n\n    void remove(Node* node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n        delete node;\n        --size;\n    }\n\n    Node* forward(int start, int end, Node* curr) {\n        while (start++ != end) curr = curr-&gt;next;\n        return curr;\n    }\n\n    Node* backward(int start, int end, Node* curr) {\n        while (start-- != end) curr = curr-&gt;prev;\n        return curr;\n    }\n};\n\nint main() {\n    MyLinkedList list;\n    list.addAtHead(1);\n    list.addAtTail(2);\n    list.addAtIndex(1, 3);\n    std::cout &lt;&lt; \"Value at index 1: \" &lt;&lt; list.get(1) &lt;&lt; std::endl; // Output: 3\n    list.deleteAtIndex(1);\n    std::cout &lt;&lt; \"Value at index 1 after deletion: \" &lt;&lt; list.get(1) &lt;&lt; std::endl; // Output: 2\n    return 0;\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\nstruct Node {\n    val: i32,\n    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n    prev: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\nimpl Node {\n    fn new(value: i32) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {\n        Rc::new(RefCell::new(Node {\n            val: value,\n            next: None,\n            prev: None,\n        }))\n    }\n}\n\nstruct MyLinkedList {\n    head: Rc&lt;RefCell&lt;Node&gt;&gt;,\n    tail: Rc&lt;RefCell&lt;Node&gt;&gt;,\n    size: usize,\n}\n\nimpl MyLinkedList {\n    fn new() -&gt; Self {\n        let head = Node::new(-1);\n        let tail = Node::new(-1);\n        head.borrow_mut().next = Some(Rc::clone(&amp;tail));\n        tail.borrow_mut().prev = Some(Rc::clone(&amp;head));\n        MyLinkedList { head, tail, size: 0 }\n    }\n\n    fn get(&amp;self, index: usize) -&gt; i32 {\n        if index &gt;= self.size { return -1; }\n        let mut node = if index &lt; self.size / 2 {\n            self.head.borrow().next.clone()\n        } else {\n            self.tail.borrow().prev.clone()\n        };\n        for _ in 0..index {\n            node = node.unwrap().borrow().next.clone();\n        }\n        node.unwrap().borrow().val\n    }\n\n    fn add_at_head(&amp;mut self, val: i32) {\n        self.add(&amp;self.head, val);\n    }\n\n    fn add_at_tail(&amp;mut self, val: i32) {\n        self.add(self.tail.borrow().prev.as_ref().unwrap(), val);\n    }\n\n    fn add_at_index(&amp;mut self, index: usize, val: i32) {\n        if index &gt; self.size { return; }\n        let pre_node = if index &lt;= self.size / 2 {\n            self.head.clone()\n        } else {\n            self.tail.borrow().prev.clone().unwrap()\n        };\n        self.add(&amp;pre_node, val);\n    }\n\n    fn delete_at_index(&amp;mut self, index: usize) {\n        if index &gt;= self.size { return; }\n        let node = if index &lt; self.size / 2 {\n            self.head.borrow().next.clone()\n        } else {\n            self.tail.borrow().prev.clone()\n        };\n        self.remove(&amp;node.unwrap());\n    }\n\n    fn add(&amp;mut self, pre_node: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, val: i32) {\n        let node = Node::new(val);\n        node.borrow_mut().prev = Some(Rc::clone(pre_node));\n        pre_node.borrow_mut().next = Some(Rc::clone(&amp;node));\n        self.size += 1;\n    }\n\n    fn remove(&amp;mut self, node: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;) {\n        let prev = node.borrow().prev.clone();\n        let next = node.borrow().next.clone();\n        prev.unwrap().borrow_mut().next = next.clone();\n        next.unwrap().borrow_mut().prev = prev.clone();\n        self.size -= 1;\n    }\n}\n\nfn main() {\n    let mut list = MyLinkedList::new();\n    list.add_at_head(1);\n    list.add_at_tail(2);\n    list.add_at_index(1, 3);\n    println!(\"Value at index 1: {}\", list.get(1)); // Output: 3\n    list.delete_at_index(1);\n    println!(\"Value at index 1 after deletion: {}\", list.get(1)); // Output: 2\n}\n</code></pre> <pre><code>using System;\n\npublic class Node {\n    public int val;\n    public Node next, prev;\n    public Node(int value) {\n        val = value;\n        next = prev = null;\n    }\n}\n\npublic class MyLinkedList {\n    private Node head, tail;\n    private int size;\n\n    public MyLinkedList() {\n        head = new Node(-1);\n        tail = new Node(-1);\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n    }\n\n    public int Get(int index) {\n        if (index &lt; 0 || index &gt;= size) return -1;\n        Node curr = (index &lt; size / 2) ? Forward(0, index, head.next) : Backward(size, index, tail);\n        return curr.val;\n    }\n\n    public void AddAtHead(int val) { Add(head, val); }\n\n    public void AddAtTail(int val) { Add(tail.prev, val); }\n\n    public void AddAtIndex(int index, int val) {\n        if (index &lt; 0 || index &gt; size) return;\n        Node preNode = (index &lt;= size / 2) ? Forward(0, index, head.next).prev : Backward(size, index, tail).prev;\n        Add(preNode, val);\n    }\n\n    public void DeleteAtIndex(int index) {\n        if (index &lt; 0 || index &gt;= size) return;\n        Node node = (index &lt; size / 2) ? Forward(0, index, head.next) : Backward(size, index, tail);\n        Remove(node);\n    }\n\n    private void Add(Node preNode, int val) {\n        Node node = new Node(val);\n        node.prev = preNode;\n        node.next = preNode.next;\n        preNode.next.prev = node;\n        preNode.next = node;\n        size++;\n    }\n\n    private void Remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        size--;\n    }\n\n    private Node Forward(int start, int end, Node curr) {\n        while (start++ != end) curr = curr.next;\n        return curr;\n    }\n\n    private Node Backward(int start, int end, Node curr) {\n        while (start-- != end) curr = curr.prev;\n        return curr;\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        MyLinkedList list = new MyLinkedList();\n        list.AddAtHead(1);\n        list.AddAtTail(2);\n        list.AddAtIndex(1, 3);\n        Console.WriteLine(\"Value at index 1: \" + list.Get(1)); // Output: 3\n        list.DeleteAtIndex(1);\n        Console.WriteLine(\"Value at index 1 after deletion: \" + list.Get(1)); // Output: 2\n    }\n}\n</code></pre> <pre><code>class Node {\n    int val;\n    Node next, prev;\n\n    Node(int value) {\n        this.val = value;\n    }\n}\n\npublic class MyLinkedList {\n    private Node head, tail;\n    private int size;\n\n    public MyLinkedList() {\n        head = new Node(-1);\n        tail = new Node(-1);\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n    }\n\n    public int get(int index) {\n        if (index &lt; 0 || index &gt;= size) return -1;\n        Node curr = (index &lt; size / 2) ? forward(0, index, head.next) : backward(size, index, tail);\n        return curr.val;\n    }\n\n    public void addAtHead(int val) { add(head, val); }\n\n    public void addAtTail(int val) { add(tail.prev, val); }\n\n    public void addAtIndex(int index, int val) {\n        if (index &lt; 0 || index &gt; size) return;\n        Node preNode = (index &lt;= size / 2) ? forward(0, index, head.next).prev : backward(size, index, tail).prev;\n        add(preNode, val);\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index &lt; 0 || index &gt;= size) return;\n        Node node = (index &lt; size / 2) ? forward(0, index, head.next) : backward(size, index, tail);\n        remove(node);\n    }\n\n    private void add(Node preNode, int val) {\n        Node node = new Node(val);\n        node.prev = preNode;\n        node.next = preNode.next;\n        preNode.next.prev = node;\n        preNode.next = node;\n        size++;\n    }\n\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        size--;\n    }\n\n    private Node forward(int start, int end, Node curr) {\n        while (start++ != end) curr = curr.next;\n        return curr;\n    }\n\n    private Node backward(int start, int end, Node curr) {\n        while (start-- != end) curr = curr.prev;\n        return curr;\n    }\n\n    public static void main(String[] args) {\n        MyLinkedList list = new MyLinkedList();\n        list.addAtHead(1);\n        list.addAtTail(2);\n        list.addAtIndex(1, 3);\n        System.out.println(\"Value at index 1: \" + list.get(1)); // Output: 3\n        list.deleteAtIndex(1);\n        System.out.println(\"Value at index 1 after deletion: \" + list.get(1)); // Output: 2\n    }\n}\n</code></pre> <pre><code>class Node(var val: Int, var next: Node = null, var prev: Node = null)\n\nclass MyLinkedList {\n    private val head = new Node(-1)\n    private val tail = new Node(-1)\n    private var size = 0\n    head.next = tail\n    tail.prev = head\n\n    def get(index: Int): Int = {\n        if (index &lt; 0 || index &gt;= size) -1\n        else (if (index &lt; size / 2) forward(0, index, head.next) else backward(size, index, tail)).val\n    }\n\n    def addAtHead(value: Int): Unit = add(head, value)\n\n    def addAtTail(value: Int): Unit = add(tail.prev, value)\n\n    def addAtIndex(index: Int, value: Int): Unit = {\n        if (index &gt;= 0 &amp;&amp; index &lt;= size) {\n        val preNode = if (index &lt;= size / 2) forward(0, index, head.next).prev else backward(size, index, tail).prev\n        add(preNode, value)\n        }\n    }\n\n    def deleteAtIndex(index: Int): Unit = {\n        if (index &gt;= 0 &amp;&amp; index &lt; size) {\n        val node = if (index &lt; size / 2) forward(0, index, head.next) else backward(size, index, tail)\n        remove(node)\n        }\n    }\n\n    private def add(preNode: Node, value: Int): Unit = {\n        val node = new Node(value)\n        node.prev = preNode\n        node.next = preNode.next\n        preNode.next.prev = node\n        preNode.next = node\n        size += 1\n    }\n\n    private def remove(node: Node): Unit = {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        size -= 1\n    }\n\n    private def forward(start: Int, end: Int, curr: Node): Node = {\n        var cur = curr\n        for (_ &lt;- start until end) cur = cur.next\n        cur\n    }\n\n    private def backward(start: Int, end: Int, curr: Node): Node = {\n        var cur = curr\n        for (_ &lt;- end until start) cur = cur.prev\n        cur\n    }\n}\n\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val list = new MyLinkedList\n        list.addAtHead(1)\n        list.addAtTail(2)\n        list.addAtIndex(1, 3)\n        println(s\"Value at index 1: ${list.get(1)}\") // Output: 3\n        list.deleteAtIndex(1)\n        println(s\"Value at index 1 after deletion: ${list.get(1)}\") // Output: 2\n    }\n}\n</code></pre> <pre><code>class Node(val value: Int) {\n    var next: Node? = null\n    var prev: Node? = null\n}\n\nclass MyLinkedList {\n    private val head = Node(-1)\n    private val tail = Node(-1)\n    private var size = 0\n\n    init {\n        head.next = tail\n        tail.prev = head\n    }\n\n    fun get(index: Int): Int {\n        if (index &lt; 0 || index &gt;= size) return -1\n        val node = if (index &lt; size / 2) forward(0, index, head.next) else backward(size, index, tail)\n        return node?.value ?: -1\n    }\n\n    fun addAtHead(value: Int) = add(head, value)\n\n    fun addAtTail(value: Int) = add(tail.prev!!, value)\n\n    fun addAtIndex(index: Int, value: Int) {\n        if (index &lt; 0 || index &gt; size) return\n        val preNode = if (index &lt;= size / 2) forward(0, index, head.next)?.prev else backward(size, index, tail)?.prev\n        add(preNode!!, value)\n    }\n\n    fun deleteAtIndex(index: Int) {\n        if (index &lt; 0 || index &gt;= size) return\n        val node = if (index &lt; size / 2) forward(0, index, head.next) else backward(size, index, tail)\n        node?.let { remove(it) }\n    }\n\n    private fun add(preNode: Node, value: Int) {\n        val node = Node(value)\n        node.prev = preNode\n        node.next = preNode.next\n        preNode.next?.prev = node\n        preNode.next = node\n        size++\n    }\n\n    private fun remove(node: Node) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n        size--\n    }\n\n    private fun forward(start: Int, end: Int, curr: Node?): Node? {\n        var cur = curr\n        repeat(end - start) { cur = cur?.next }\n        return cur\n    }\n\n    private fun backward(start: Int, end: Int, curr: Node?): Node? {\n        var cur = curr\n        repeat(start - end) { cur = cur?.prev }\n        return cur\n    }\n}\n\nfun main() {\n    val list = MyLinkedList()\n    list.addAtHead(1)\n    list.addAtTail(2)\n    list.addAtIndex(1, 3)\n    println(\"Value at index 1: ${list.get(1)}\") // Output: 3\n    list.deleteAtIndex(1)\n    println(\"Value at index 1 after deletion: ${list.get(1)}\") // Output: 2\n}\n</code></pre> <pre><code>package main\nimport \"fmt\"\n\ntype Node struct {\n    val  int\n    next *Node\n    prev *Node\n}\n\ntype MyLinkedList struct {\n    head *Node\n    tail *Node\n    size int\n}\n\nfunc Constructor() MyLinkedList {\n    head := &amp;Node{-1, nil, nil}\n    tail := &amp;Node{-1, nil, nil}\n    head.next = tail\n    tail.prev = head\n    return MyLinkedList{head: head, tail: tail, size: 0}\n}\n\nfunc (this *MyLinkedList) Get(index int) int {\n    if index &lt; 0 || index &gt;= this.size {\n        return -1\n    }\n    var node *Node\n    if index &lt; this.size/2 {\n        node = this.forward(0, index, this.head.next)\n    } else {\n        node = this.backward(this.size, index, this.tail)\n    }\n    return node.val\n}\n\nfunc (this *MyLinkedList) AddAtHead(val int) {\n    this.add(this.head, val)\n}\n\nfunc (this *MyLinkedList) AddAtTail(val int) {\n    this.add(this.tail.prev, val)\n}\n\nfunc (this *MyLinkedList) AddAtIndex(index, val int) {\n    if index &lt; 0 || index &gt; this.size {\n        return\n    }\n    var preNode *Node\n    if index &lt;= this.size/2 {\n        preNode = this.forward(0, index, this.head.next).prev\n    } else {\n        preNode = this.backward(this.size, index, this.tail).prev\n    }\n    this.add(preNode, val)\n}\n\nfunc (this *MyLinkedList) DeleteAtIndex(index int) {\n    if index &lt; 0 || index &gt;= this.size {\n        return\n    }\n    var node *Node\n    if index &lt; this.size/2 {\n        node = this.forward(0, index, this.head.next)\n    } else {\n        node = this.backward(this.size, index, this.tail)\n    }\n    this.remove(node)\n}\n\nfunc (this *MyLinkedList) add(preNode *Node, val int) {\n    node := &amp;Node{val: val}\n    node.prev = preNode\n    node.next = preNode.next\n    preNode.next.prev = node\n    preNode.next = node\n    this.size++\n}\n\nfunc (this *MyLinkedList) remove(node *Node) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    this.size--\n}\n\nfunc (this *MyLinkedList) forward(start, end int, curr *Node) *Node {\n    for start &lt; end {\n        curr = curr.next\n        start++\n    }\n    return curr\n}\n\nfunc (this *MyLinkedList) backward(start, end int, curr *Node) *Node {\n    for start &gt; end {\n        curr = curr.prev\n        start--\n    }\n    return curr\n}\n\nfunc main() {\n    list := Constructor()\n    list.AddAtHead(1)\n    list.AddAtTail(2)\n    list.AddAtIndex(1, 3)\n    fmt.Println(\"Value at index 1:\", list.Get(1)) // Output: 3\n    list.DeleteAtIndex(1)\n    fmt.Println(\"Value at index 1 after deletion:\", list.Get(1)) // Output: 2\n}\n</code></pre> <pre><code>class Node {\n    val: number;\n    next: Node | null = null;\n    prev: Node | null = null;\n\n    constructor(value: number) {\n        this.val = value;\n    }\n}\n\nclass MyLinkedList {\n    private head: Node;\n    private tail: Node;\n    private size: number = 0;\n\n    constructor() {\n        this.head = new Node(-1);\n        this.tail = new Node(-1);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n\n    get(index: number): number {\n        if (index &lt; 0 || index &gt;= this.size) return -1;\n        const node = (index &lt; this.size / 2) ? this.forward(0, index, this.head.next) : this.backward(this.size, index, this.tail);\n        return node ? node.val : -1;\n    }\n\n    addAtHead(value: number): void {\n        this.add(this.head, value);\n    }\n\n    addAtTail(value: number): void {\n        this.add(this.tail.prev as Node, value);\n    }\n\n    addAtIndex(index: number, value: number): void {\n        if (index &lt; 0 || index &gt; this.size) return;\n        const preNode = (index &lt;= this.size / 2) ? this.forward(0, index, this.head.next)?.prev : this.backward(this.size, index, this.tail)?.prev;\n        if (preNode) this.add(preNode, value);\n    }\n\n    deleteAtIndex(index: number): void {\n        if (index &lt; 0 || index &gt;= this.size) return;\n        const node = (index &lt; this.size / 2) ? this.forward(0, index, this.head.next) : this.backward(this.size, index, this.tail);\n        if (node) this.remove(node);\n    }\n\n    private add(preNode: Node, value: number): void {\n        const node = new Node(value);\n        node.prev = preNode;\n        node.next = preNode.next;\n        preNode.next!.prev = node;\n        preNode.next = node;\n        this.size++;\n    }\n\n    private remove(node: Node): void {\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        this.size--;\n    }\n\n    private forward(start: number, end: number, curr: Node | null): Node | null {\n        while (start++ !== end) curr = curr!.next;\n        return curr;\n    }\n\n    private backward(start: number, end: number, curr: Node | null): Node | null {\n        while (start-- !== end) curr = curr!.prev;\n        return curr;\n    }\n}\n\n// Testing\nconst list = new MyLinkedList();\nlist.addAtHead(1);\nlist.addAtTail(2);\nlist.addAtIndex(1, 3);\nconsole.log(\"Value at index 1:\", list.get(1)); // Output: 3\nlist.deleteAtIndex(1);\nconsole.log(\"Value at index 1 after deletion:\", list.get(1)); // Output: 2\n</code></pre> <pre><code>Node &lt;- setRefClass(\"Node\",\n                    fields = list(\n                    val = \"numeric\",\n                    next = \"Node\",\n                    prev = \"Node\"\n                    ))\n\nMyLinkedList &lt;- setRefClass(\"MyLinkedList\",\n                            fields = list(\n                            head = \"Node\",\n                            tail = \"Node\",\n                            size = \"numeric\"\n                            ),\n                            methods = list(\n                            initialize = function() {\n                                head &lt;&lt;- Node$new(val = -1)\n                                tail &lt;&lt;- Node$new(val = -1)\n                                head$next &lt;- tail\n                                tail$prev &lt;- head\n                                size &lt;&lt;- 0\n                            },\n                            get = function(index) {\n                                if (index &lt; 0 || index &gt;= size) return(-1)\n                                node &lt;- if (index &lt; size / 2) .self$forward(0, index, head$next) else .self$backward(size, index, tail)\n                                node$val\n                            },\n                            addAtHead = function(val) {\n                                add(head, val)\n                            },\n                            addAtTail = function(val) {\n                                add(tail$prev, val)\n                            },\n                            addAtIndex = function(index, val) {\n                                if (index &lt; 0 || index &gt; size) return(NULL)\n                                preNode &lt;- if (index &lt;= size / 2) .self$forward(0, index, head$next)$prev else .self$backward(size, index, tail)$prev\n                                add(preNode, val)\n                            },\n                            deleteAtIndex = function(index) {\n                                if (index &lt; 0 || index &gt;= size) return(NULL)\n                                node &lt;- if (index &lt; size / 2) .self$forward(0, index, head$next) else .self$backward(size, index, tail)\n                                remove(node)\n                            },\n                            add = function(preNode, val) {\n                                node &lt;- Node$new(val = val)\n                                node$prev &lt;- preNode\n                                node$next &lt;- preNode$next\n                                preNode$next$prev &lt;- node\n                                preNode$next &lt;- node\n                                size &lt;&lt;- size + 1\n                            },\n                            remove = function(node) {\n                                node$prev$next &lt;- node$next\n                                node$next$prev &lt;- node$prev\n                                size &lt;&lt;- size - 1\n                            },\n                            forward = function(start, end, curr) {\n                                while (start &lt; end) {\n                                start &lt;- start + 1\n                                curr &lt;- curr$next\n                                }\n                                curr\n                            },\n                            backward = function(start, end, curr) {\n                                while (start &gt; end) {\n                                start &lt;- start - 1\n                                curr &lt;- curr$prev\n                                }\n                                curr\n                            }\n                            ))\n\n# Testing\nlist &lt;- MyLinkedList$new()\nlist$addAtHead(1)\nlist$addAtTail(2)\nlist$addAtIndex(1, 3)\nprint(paste(\"Value at index 1:\", list$get(1))) # Output: 3\nlist$deleteAtIndex(1)\nprint(paste(\"Value at index 1 after deletion:\", list$get(1))) # Output: 2\n</code></pre> <pre><code>module MyLinkedListModule\n\nmutable struct Node\n    val::Int\n    next::Union{Node, Nothing}\n    prev::Union{Node, Nothing}\n\n    Node(val::Int) = new(val, nothing, nothing)\nend\n\nmutable struct MyLinkedList\n    head::Node\n    tail::Node\n    size::Int\n\n    MyLinkedList() = begin\n        head = Node(-1)\n        tail = Node(-1)\n        head.next = tail\n        tail.prev = head\n        new(head, tail, 0)\n    end\nend\n\nfunction get(list::MyLinkedList, index::Int)::Int\n    if index &lt; 0 || index &gt;= list.size\n        return -1\n    end\n    node = index &lt; div(list.size, 2) ? forward(0, index, list.head.next) : backward(list.size, index, list.tail)\n    return node.val\nend\n\nfunction add_at_head!(list::MyLinkedList, val::Int)\n    add!(list, list.head, val)\nend\n\nfunction add_at_tail!(list::MyLinkedList, val::Int)\n    add!(list, list.tail.prev, val)\nend\n\nfunction add_at_index!(list::MyLinkedList, index::Int, val::Int)\n    if index &lt; 0 || index &gt; list.size\n        return\n    end\n    preNode = index &lt;= div(list.size, 2) ? forward(0, index, list.head.next).prev : backward(list.size, index, list.tail).prev\n    add!(list, preNode, val)\nend\n\nfunction delete_at_index!(list::MyLinkedList, index::Int)\n    if index &lt; 0 || index &gt;= list.size\n        return\n    end\n    node = index &lt; div(list.size, 2) ? forward(0, index, list.head.next) : backward(list.size, index, list.tail)\n    remove!(list, node)\nend\n\nfunction add!(list::MyLinkedList, preNode::Node, val::Int)\n    node = Node(val)\n    node.prev = preNode\n    node.next = preNode.next\n    preNode.next.prev = node\n    preNode.next = node\n    list.size += 1\nend\n\nfunction remove!(list::MyLinkedList, node::Node)\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    list.size -= 1\nend\n\nfunction forward(start::Int, end::Int, curr::Node)::Node\n    while start &lt; end\n        curr = curr.next\n        start += 1\n    end\n    return curr\nend\n\nfunction backward(start::Int, end::Int, curr::Node)::Node\n    while start &gt; end\n        curr = curr.prev\n        start -= 1\n    end\n    return curr\nend\n\n# Testing\nlist = MyLinkedList()\nadd_at_head!(list, 1)\nadd_at_tail!(list, 2)\nadd_at_index!(list, 1, 3)\nprintln(\"Value at index 1:\", get(list, 1)) # Output: 3\ndelete_at_index!(list, 1)\nprintln(\"Value at index 1 after deletion:\", get(list, 1)) # Output: 2\n\nend # module\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#reverse-linked-list","title":"Reverse Linked List","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#problem-description-leetcode-problem-206-reverse-linked-list","title":"Problem Description: LeetCode - Problem 206 - Reverse Linked List","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solution-explanation_1","title":"Solution Explanation","text":"<p>The problem is to reverse a singly linked list. Given a linked list, the goal is to reverse the links between the nodes such that the last node becomes the first node and the first node becomes the last.</p> <p>The code provided has two solutions: 1. Iterative approach (<code>reverseIter</code>) 2. Recursive approach (<code>reverseRecur</code>)</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#1-iterative-approach-reverseiter","title":"1. Iterative Approach (<code>reverseIter</code>)","text":"<p>The iterative approach reverses the linked list by changing the <code>next</code> pointer of each node to point to the previous node.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#steps","title":"Steps:","text":"<ul> <li>Initialize three pointers: <code>prev</code> (which will track the previous node), <code>curr</code> (which points to the current node being processed), and <code>newHead</code> (which tracks the reversed list's head).</li> <li>Loop through the linked list:</li> <li>Store the next node in a temporary variable <code>curr.next</code>.</li> <li>Reverse the link by pointing the current node (<code>curr.next</code>) to the previous node (<code>prev</code>).</li> <li>Move the <code>prev</code> and <code>curr</code> pointers forward (to the current node and the next node, respectively).</li> <li>Continue this until you reach the end of the list.</li> <li>Finally, return the <code>newHead</code> as the new head of the reversed list.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#2-recursive-approach-reverserecur","title":"2. Recursive Approach (<code>reverseRecur</code>)","text":"<p>In the recursive approach, you break down the list into two parts: the head and the rest of the list. You recursively reverse the rest of the list and then link the current node (<code>head</code>) to the reversed list.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#steps_1","title":"Steps:","text":"<ol> <li>If the list is empty or contains only one node, return the head (base case).</li> <li>Otherwise, call the recursive function for the rest of the list (<code>head.next</code>).</li> <li>After the recursive call, reverse the link between <code>head</code> and <code>head.next</code>.</li> <li>Finally, return the new head of the reversed list (the return value of the recursive call).</li> </ol>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#example-run-for-iterative-solution-reverseiter","title":"Example Run for Iterative Solution (<code>reverseIter</code>)","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#input","title":"Input:","text":"<pre><code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#execution","title":"Execution:","text":"<ul> <li>Initially: </li> <li><code>prev = None</code>, <code>curr = 1</code>, <code>newHead = None</code></li> <li>First iteration:</li> <li>Reverse link: <code>curr.next = prev</code> =&gt; <code>1.next = None</code></li> <li>Move forward: <code>prev = 1</code>, <code>curr = 2</code>, <code>newHead = 1</code></li> <li>Second iteration:</li> <li>Reverse link: <code>2.next = 1</code></li> <li>Move forward: <code>prev = 2</code>, <code>curr = 3</code>, <code>newHead = 2</code></li> <li>And so on until:</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#output","title":"Output:","text":"<pre><code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#example-run-for-recursive-solution-reverserecur","title":"Example Run for Recursive Solution (<code>reverseRecur</code>)","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#input_1","title":"Input:","text":"<pre><code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#execution_1","title":"Execution:","text":"<ul> <li>Break the list recursively:</li> <li>Call for <code>2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</code></li> <li>Call for <code>3 -&gt; 4 -&gt; 5 -&gt; NULL</code></li> <li>Call for <code>4 -&gt; 5 -&gt; NULL</code></li> <li> <p>Call for <code>5 -&gt; NULL</code> (base case, return <code>5</code>)</p> </li> <li> <p>On returning, reverse the links:</p> </li> <li>Set <code>4.next.next = 4</code> and <code>4.next = NULL</code></li> <li>Set <code>3.next.next = 3</code> and <code>3.next = NULL</code></li> <li>And so on.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#output_1","title":"Output:","text":"<pre><code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL\n</code></pre> <p>Both approaches correctly reverse the linked list, but the iterative solution is more space-efficient than the recursive one.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#complexity-analysis_1","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#1-iterative-approach-reverseiter_1","title":"1. Iterative Approach (<code>reverseIter</code>)","text":"<ul> <li>Time Complexity: </li> <li> <p>The iterative approach processes each node exactly once in a single pass through the list. Therefore, the time complexity is O(n), where <code>n</code> is the number of nodes in the linked list.</p> </li> <li> <p>Space Complexity: </p> </li> <li>The iterative approach uses only a constant amount of extra space, primarily for the three pointers (<code>prev</code>, <code>curr</code>, and <code>newHead</code>). Hence, the space complexity is O(1).</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#2-recursive-approach-reverserecur_1","title":"2. Recursive Approach (<code>reverseRecur</code>)","text":"<ul> <li>Time Complexity: </li> <li> <p>Each recursive call processes one node, and since there are <code>n</code> nodes in the list, the time complexity is O(n).</p> </li> <li> <p>Space Complexity:</p> </li> <li>The recursive approach has a space complexity of O(n) because each recursive call adds a new frame to the call stack, and there are <code>n</code> recursive calls for a list of <code>n</code> nodes.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solutions_1","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None) -&gt; None:\n        self.val = val\n        self.next = next\n\ndef push(head: Optional[ListNode], data: int) -&gt; Optional[ListNode]:\n    new_node = ListNode(data)\n    if head is None:\n        return new_node\n    else:\n        curr = head\n        while curr.next is not None:\n            curr = curr.next\n        curr.next = new_node\n        return head\n\ndef print_list(head: Optional[ListNode]) -&gt; None:\n    while head:\n        print(f\"{head.data}--&gt;\", end=\"\")\n        head = head.next\n    print(\"NULL\")\n\nclass Solution:\n    def reverseIter(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        newHead = None\n        prev = None\n        curr = head\n\n        while curr:\n            prev = curr\n            curr = curr.next\n            prev.next = newHead\n            newHead = prev\n\n        return prev\n\n    def reverseRecur(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        rest = self.reverseRecur(head.next)\n        head.next.next = head\n        head.next = None\n\n        return rest\n\nif __name__ == \"__main__\":\n    head: Optional[ListNode] = None\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    print(\"Before Reversing LinkedList (Iterative):\\n\")\n    print_list(head)\n    head = Solution().reverseIter(head)    \n    print(\"After Reversing LinkedList (Iterative):\\n\")\n    print_list(head)\n\n    head = None\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    print(\"Before Reversing LinkedList (Recursive):\\n\")\n    print_list(head)\n    head = Solution().reverseRecur(head)    \n    print(\"After Reversing LinkedList (Recursive):\\n\")\n    print_list(head)\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;optional&gt;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* push(ListNode* head, int data) {\n    ListNode* new_node = new ListNode(data);\n    if (head == nullptr) {\n        return new_node;\n    } else {\n        ListNode* curr = head;\n        while (curr-&gt;next.has_value()) {\n            curr = curr-&gt;next.value();\n        }\n        curr-&gt;next = new_node;\n        return head;\n    }\n}\n\nvoid print_list(ListNode* head) {\n    while (head != nullptr) {\n        std::cout &lt;&lt; head-&gt;data &lt;&lt; \"--&gt; \";\n        head = head-&gt;next.value_or(nullptr);\n    }\n    std::cout &lt;&lt; \"NULL\" &lt;&lt; std::endl;\n}\n\nclass Solution {\npublic:\n    ListNode* reverseIter(ListNode* head) {\n        if (!head || !head-&gt;next) {\n            return head;\n        }\n        ListNode* newHead = nullptr;\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n\n        while (curr) {\n            prev = curr;\n            curr = curr-&gt;next.value_or(nullptr);\n            prev-&gt;next = newHead;\n            newHead = prev;\n        }\n\n        return prev;\n    }\n\n    ListNode* reverseRecur(ListNode* head) {\n        if (!head || !head-&gt;next) {\n            return head;\n        }\n\n        ListNode* rest = reverseRecur(head-&gt;next.value());\n        head-&gt;next.value()-&gt;next = head;\n        head-&gt;next = nullptr;\n\n        return rest;\n    }\n};\n\nint main() {\n    ListNode* head = nullptr;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    std::cout &lt;&lt; \"Before Reversing LinkedList (Iterative):\\n\";\n    print_list(head);\n    head = Solution().reverseIter(head);\n    std::cout &lt;&lt; \"After Reversing LinkedList (Iterative):\\n\";\n    print_list(head);\n\n    head = nullptr;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    std::cout &lt;&lt; \"Before Reversing LinkedList (Recursive):\\n\";\n    print_list(head);\n    head = Solution().reverseRecur(head);\n    std::cout &lt;&lt; \"After Reversing LinkedList (Recursive):\\n\";\n    print_list(head);\n\n    return 0;\n}\n</code></pre> <pre><code>#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode { val, next: None }\n    }\n}\n\nfn push(head: Option&lt;Box&lt;ListNode&gt;&gt;, data: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n    let mut new_node = Box::new(ListNode::new(data));\n    match head {\n        None =&gt; Some(new_node),\n        Some(mut node) =&gt; {\n            let mut current = &amp;mut node;\n            while let Some(ref mut next) = current.next {\n                current = next;\n            }\n            current.next = Some(new_node);\n            Some(node)\n        }\n    }\n}\n\nfn print_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) {\n    let mut current = &amp;head;\n    while let Some(node) = current {\n        print!(\"{} --&gt; \", node.val);\n        current = &amp;node.next;\n    }\n    println!(\"NULL\");\n}\n\nstruct Solution;\n\nimpl Solution {\n    fn reverse_iter(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut prev = None;\n        let mut curr = head;\n        while let Some(mut node) = curr {\n            let next = node.next.take();\n            node.next = prev;\n            prev = Some(node);\n            curr = next;\n        }\n        prev\n    }\n\n    fn reverse_recur(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        fn helper(node: Option&lt;Box&lt;ListNode&gt;&gt;, prev: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n            match node {\n                None =&gt; prev,\n                Some(mut n) =&gt; {\n                    let next = n.next.take();\n                    n.next = prev;\n                    helper(next, Some(n))\n                }\n            }\n        }\n        helper(head, None)\n    }\n}\n\nfn main() {\n    let mut head = None;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    println!(\"Before Reversing LinkedList (Iterative):\");\n    print_list(head.clone());\n    head = Solution::reverse_iter(head);\n    println!(\"After Reversing LinkedList (Iterative):\");\n    print_list(head.clone());\n\n    head = None;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    println!(\"Before Reversing LinkedList (Recursive):\");\n    print_list(head.clone());\n    head = Solution::reverse_recur(head);\n    println!(\"After Reversing LinkedList (Recursive):\");\n    print_list(head);\n}\n</code></pre> <pre><code>using System;\n\npublic class ListNode {\n    public int val;\n    public ListNode next;\n    public ListNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public static ListNode Push(ListNode head, int data) {\n        var newNode = new ListNode(data);\n        if (head == null) return newNode;\n\n        var current = head;\n        while (current.next != null) current = current.next;\n        current.next = newNode;\n        return head;\n    }\n\n    public static void PrintList(ListNode head) {\n        while (head != null) {\n            Console.Write($\"{head.val} --&gt; \");\n            head = head.next;\n        }\n        Console.WriteLine(\"NULL\");\n    }\n\n    public ListNode ReverseIter(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            var nextNode = head.next;\n            head.next = prev;\n            prev = head;\n            head = nextNode;\n        }\n        return prev;\n    }\n\n    public ListNode ReverseRecur(ListNode head) {\n        if (head == null || head.next == null) return head;\n        var newHead = ReverseRecur(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        ListNode head = null;\n        head = Solution.Push(head, 1);\n        head = Solution.Push(head, 2);\n        head = Solution.Push(head, 3);\n        head = Solution.Push(head, 4);\n        head = Solution.Push(head, 5);\n\n        Console.WriteLine(\"Before Reversing LinkedList (Iterative):\");\n        Solution.PrintList(head);\n        head = new Solution().ReverseIter(head);\n        Console.WriteLine(\"After Reversing LinkedList (Iterative):\");\n        Solution.PrintList(head);\n\n        head = null;\n        head = Solution.Push(head, 1);\n        head = Solution.Push(head, 2);\n        head = Solution.Push(head, 3);\n        head = Solution.Push(head, 4);\n        head = Solution.Push(head, 5);\n\n        Console.WriteLine(\"Before Reversing LinkedList (Recursive):\");\n        Solution.PrintList(head);\n        head = new Solution().ReverseRecur(head);\n        Console.WriteLine(\"After Reversing LinkedList (Recursive):\");\n        Solution.PrintList(head);\n    }\n}\n</code></pre> <pre><code>class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nclass Solution {\n    public static ListNode push(ListNode head, int data) {\n        ListNode newNode = new ListNode(data);\n        if (head == null) return newNode;\n        ListNode curr = head;\n        while (curr.next != null) curr = curr.next;\n        curr.next = newNode;\n        return head;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" --&gt; \");\n            head = head.next;\n        }\n        System.out.println(\"NULL\");\n    }\n\n    public ListNode reverseIter(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            ListNode nextNode = head.next;\n            head.next = prev;\n            prev = head;\n            head = nextNode;\n        }\n        return prev;\n    }\n\n    public ListNode reverseRecur(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode rest = reverseRecur(head.next);\n        head.next.next = head;\n        head.next = null;\n        return rest;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = null;\n        head = Solution.push(head, 1);\n        head = Solution.push(head, 2);\n        head = Solution.push(head, 3);\n        head = Solution.push(head, 4);\n        head = Solution.push(head, 5);\n\n        System.out.println(\"Before Reversing LinkedList (Iterative):\");\n        Solution.printList(head);\n        head = new Solution().reverseIter(head);\n        System.out.println(\"After Reversing LinkedList (Iterative):\");\n        Solution.printList(head);\n\n        head = null;\n        head = Solution.push(head, 1);\n        head = Solution.push(head, 2);\n        head = Solution.push(head, 3);\n        head = Solution.push(head, 4);\n        head = Solution.push(head, 5);\n\n        System.out.println(\"Before Reversing LinkedList (Recursive):\");\n        Solution.printList(head);\n        head = new Solution().reverseRecur(head);\n        System.out.println(\"After Reversing LinkedList (Recursive):\");\n        Solution.printList(head);\n    }\n}\n</code></pre> <pre><code>class ListNode(var value: Int) {\n    var next: Option[ListNode] = None\n}\n\nobject Solution {\n    def push(head: Option[ListNode], data: Int): Option[ListNode] = {\n        val newNode = Some(new ListNode(data))\n        head match {\n            case None =&gt; newNode\n            case Some(node) =&gt;\n                var current = node\n                while (current.next.isDefined) current = current.next.get\n                current.next = newNode\n                head\n        }\n    }\n\n    def printList(head: Option[ListNode]): Unit = {\n        var current = head\n        while (current.isDefined) {\n            print(s\"${current.get.value} --&gt; \")\n            current = current.get.next\n        }\n        println(\"NULL\")\n    }\n\n    def reverseIter(head: Option[ListNode]): Option[ListNode] = {\n        var prev: Option[ListNode] = None\n        var curr = head\n        while (curr.isDefined) {\n            val next = curr.get.next\n            curr.get.next = prev\n            prev = curr\n            curr = next\n        }\n        prev\n    }\n\n    def reverseRecur(head: Option[ListNode]): Option[ListNode] = {\n        if (head.isEmpty || head.get.next.isEmpty) head\n        else {\n            val rest = reverseRecur(head.get.next)\n            head.get.next.get.next = head.get\n            head.get.next = None\n            rest\n        }\n    }\n}\n\nobject Main extends App {\n    var head: Option[ListNode] = None\n    head = Solution.push(head, 1)\n    head = Solution.push(head, 2)\n    head = Solution.push(head, 3)\n    head = Solution.push(head, 4)\n    head = Solution.push(head, 5)\n\n    println(\"Before Reversing LinkedList (Iterative):\")\n    Solution.printList(head)\n    head = Solution.reverseIter(head)\n    println(\"After Reversing LinkedList (Iterative):\")\n    Solution.printList(head)\n\n    head = None\n    head = Solution.push(head, 1)\n    head = Solution.push(head, 2)\n    head = Solution.push(head, 3)\n    head = Solution.push(head, 4)\n    head = Solution.push(head, 5)\n\n    println(\"Before Reversing LinkedList (Recursive):\")\n    Solution.printList(head)\n    head = Solution.reverseRecur(head)\n    println(\"After Reversing LinkedList (Recursive):\")\n    Solution.printList(head)\n}\n</code></pre> <pre><code>class ListNode(var value: Int) {\n    var next: ListNode? = null\n}\n\nobject Solution {\n    fun push(head: ListNode?, data: Int): ListNode? {\n        val newNode = ListNode(data)\n        if (head == null) return newNode\n        var current = head\n        while (current.next != null) {\n            current = current.next!!\n        }\n        current.next = newNode\n        return head\n    }\n\n    fun printList(head: ListNode?) {\n        var current = head\n        while (current != null) {\n            print(\"${current.value} --&gt; \")\n            current = current.next\n        }\n        println(\"NULL\")\n    }\n\n    fun reverseIter(head: ListNode?): ListNode? {\n        var prev: ListNode? = null\n        var curr = head\n        while (curr != null) {\n            val next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        }\n        return prev\n    }\n\n    fun reverseRecur(head: ListNode?): ListNode? {\n        if (head?.next == null) return head\n        val rest = reverseRecur(head.next)\n        head.next!!.next = head\n        head.next = null\n        return rest\n    }\n}\n\nfun main() {\n    var head: ListNode? = null\n    head = Solution.push(head, 1)\n    head = Solution.push(head, 2)\n    head = Solution.push(head, 3)\n    head = Solution.push(head, 4)\n    head = Solution.push(head, 5)\n\n    println(\"Before Reversing LinkedList (Iterative):\")\n    Solution.printList(head)\n    head = Solution.reverseIter(head)\n    println(\"After Reversing LinkedList (Iterative):\")\n    Solution.printList(head)\n\n    head = null\n    head = Solution.push(head, 1)\n    head = Solution.push(head, 2)\n    head = Solution.push(head, 3)\n    head = Solution.push(head, 4)\n    head = Solution.push(head, 5)\n\n    println(\"Before Reversing LinkedList (Recursive):\")\n    Solution.printList(head)\n    head = Solution.reverseRecur(head)\n    println(\"After Reversing LinkedList (Recursive):\")\n    Solution.printList(head)\n}\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc push(head *ListNode, data int) *ListNode {\n    newNode := &amp;ListNode{Val: data}\n    if head == nil {\n        return newNode\n    }\n    current := head\n    for current.Next != nil {\n        current = current.Next\n    }\n    current.Next = newNode\n    return head\n}\n\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Printf(\"%d --&gt; \", head.Val)\n        head = head.Next\n    }\n    fmt.Println(\"NULL\")\n}\n\nfunc reverseIter(head *ListNode) *ListNode {\n    var prev *ListNode\n    current := head\n    for current != nil {\n        next := current.Next\n        current.Next = prev\n        prev = current\n        current = next\n    }\n    return prev\n}\n\nfunc reverseRecur(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    rest := reverseRecur(head.Next)\n    head.Next.Next = head\n    head.Next = nil\n    return rest\n}\n\nfunc main() {\n    var head *ListNode\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    fmt.Println(\"Before Reversing LinkedList (Iterative):\")\n    printList(head)\n    head = reverseIter(head)\n    fmt.Println(\"After Reversing LinkedList (Iterative):\")\n    printList(head)\n\n    head = nil\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    fmt.Println(\"Before Reversing LinkedList (Recursive):\")\n    printList(head)\n    head = reverseRecur(head)\n    fmt.Println(\"After Reversing LinkedList (Recursive):\")\n    printList(head)\n}\n</code></pre> <pre><code>class ListNode {\n    val: number;\n    next: ListNode | null = null;\n\n    constructor(val: number) {\n        this.val = val;\n    }\n}\n\nfunction push(head: ListNode | null, data: number): ListNode | null {\n    const newNode = new ListNode(data);\n    if (head === null) return newNode;\n\n    let current = head;\n    while (current.next !== null) current = current.next;\n    current.next = newNode;\n    return head;\n}\n\nfunction printList(head: ListNode | null): void {\n    while (head !== null) {\n        process.stdout.write(`${head.val} --&gt; `);\n        head = head.next;\n    }\n    console.log(\"NULL\");\n}\n\nfunction reverseIter(head: ListNode | null): ListNode | null {\n    let prev: ListNode | null = null;\n    let curr = head;\n    while (curr !== null) {\n        const nextNode = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\nfunction reverseRecur(head: ListNode | null): ListNode | null {\n    if (head === null || head.next === null) return head;\n    const rest = reverseRecur(head.next);\n    head.next.next = head;\n    head.next = null;\n    return rest;\n}\n\nlet head: ListNode | null = null;\nhead = push(head, 1);\nhead = push(head, 2);\nhead = push(head, 3);\nhead = push(head, 4);\nhead = push(head, 5);\n\nconsole.log(\"Before Reversing LinkedList (Iterative):\");\nprintList(head);\nhead = reverseIter(head);\nconsole.log(\"After Reversing LinkedList (Iterative):\");\nprintList(head);\n\nhead = null;\nhead = push(head, 1);\nhead = push(head, 2);\nhead = push(head, 3);\nhead = push(head, 4);\nhead = push(head, 5);\n\nconsole.log(\"Before Reversing LinkedList (Recursive):\");\nprintList(head);\nhead = reverseRecur(head);\nconsole.log(\"After Reversing LinkedList (Recursive):\");\nprintList(head);\n</code></pre> <pre><code># Define a ListNode class\nListNode &lt;- setRefClass(\"ListNode\",\n    fields = list(\n        val = \"numeric\",\n        next = \"ListNode\"\n    )\n)\n\n# Function to push a new node at the end\npush &lt;- function(head, data) {\n    newNode &lt;- ListNode$new(val = data)\n    if (is.null(head)) {\n        return(newNode)\n    }\n\n    current &lt;- head\n    while (!is.null(current$next)) {\n        current &lt;- current$next\n    }\n    current$next &lt;- newNode\n    return(head)\n}\n\n# Function to print the list\nprintList &lt;- function(head) {\n    current &lt;- head\n    while (!is.null(current)) {\n        cat(current$val, \"--&gt; \")\n        current &lt;- current$next\n    }\n    cat(\"NULL\\n\")\n}\n\n# Iterative reversal function\nreverseIter &lt;- function(head) {\n    prev &lt;- NULL\n    current &lt;- head\n    while (!is.null(current)) {\n        nextNode &lt;- current$next\n        current$next &lt;- prev\n        prev &lt;- current\n        current &lt;- nextNode\n    }\n    return(prev)\n}\n\n# Recursive reversal function\nreverseRecur &lt;- function(head) {\n    if (is.null(head) || is.null(head$next)) {\n        return(head)\n    }\n\n    rest &lt;- reverseRecur(head$next)\n    head$next$next &lt;- head\n    head$next &lt;- NULL\n    return(rest)\n}\n\n# Test the functions\nhead &lt;- NULL\nhead &lt;- push(head, 1)\nhead &lt;- push(head, 2)\nhead &lt;- push(head, 3)\nhead &lt;- push(head, 4)\nhead &lt;- push(head, 5)\n\ncat(\"Before Reversing LinkedList (Iterative):\\n\")\nprintList(head)\nhead &lt;- reverseIter(head)\ncat(\"After Reversing LinkedList (Iterative):\\n\")\nprintList(head)\n\n# Reset the list\nhead &lt;- NULL\nhead &lt;- push(head, 1)\nhead &lt;- push(head, 2)\nhead &lt;- push(head, 3)\nhead &lt;- push(head, 4)\nhead &lt;- push(head, 5)\n\ncat(\"Before Reversing LinkedList (Recursive):\\n\")\nprintList(head)\nhead &lt;- reverseRecur(head)\ncat(\"After Reversing LinkedList (Recursive):\\n\")\nprintList(head)\n</code></pre> <pre><code>struct ListNode\n    val::Int\n    next::Union{ListNode, Nothing}\n    ListNode(val) = new(val, nothing)\nend\n\nfunction push(head::Union{ListNode, Nothing}, data::Int)\n    new_node = ListNode(data)\n    if head === nothing\n        return new_node\n    end\n    current = head\n    while current.next !== nothing\n        current = current.next\n    end\n    current.next = new_node\n    return head\nend\n\nfunction print_list(head::Union{ListNode, Nothing})\n    while head !== nothing\n        print(\"$(head.val) --&gt; \")\n        head = head.next\n    end\n    println(\"NULL\")\nend\n\nfunction reverse_iter(head::Union{ListNode, Nothing})\n    prev = nothing\n    current = head\n    while current !== nothing\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    end\n    return prev\nend\n\nfunction reverse_recur(head::Union{ListNode, Nothing})\n    if head === nothing || head.next === nothing\n        return head\n    end\n    rest = reverse_recur(head.next)\n    head.next.next = head\n    head.next = nothing\n    return rest\nend\n\n# Test code\nhead = nothing\nhead = push(head, 1)\nhead = push(head, 2)\nhead = push(head, 3)\nhead = push(head, 4)\nhead = push(head, 5)\n\nprintln(\"Before Reversing LinkedList (Iterative):\")\nprint_list(head)\nhead = reverse_iter(head)\nprintln(\"After Reversing LinkedList (Iterative):\")\nprint_list(head)\n\nhead = nothing\nhead = push(head, 1)\nhead = push(head, 2)\nhead = push(head, 3)\nhead = push(head, 4)\nhead = push(head, 5)\n\nprintln(\"Before Reversing LinkedList (Recursive):\")\nprint_list(head)\nhead = reverse_recur(head)\nprintln(\"After Reversing LinkedList (Recursive):\")\nprint_list(head)\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#merge-two-sorted-linked-lists","title":"Merge Two Sorted Linked Lists","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#problem-description-leetcode-problem-21-merge-two-sorted-lists","title":"Problem Description: LeetCode - Problem 21 - Merge Two Sorted Lists","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solution-explanation_2","title":"Solution Explanation","text":"<ul> <li>For simplicity, we create a dummy node to which we attach nodes from lists.</li> <li>We iterate over lists using two-pointers</li> <li>And, then build up a resulting list so that values are monotonically increased.</li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#detailed-explanation","title":"Detailed Explanation","text":"<ul> <li> <p>The <code>Solution</code> class contains a method <code>mergeTwoLists</code> that merges two sorted singly-linked lists, <code>list1</code> and <code>list2</code>, into a single sorted list. It uses a pointer <code>cur</code> to iterate over the lists and create the merged list.</p> </li> <li> <p>The method iterates through both lists, comparing the values of nodes at the same position and linking them in sorted order to build the merged list. Once one of the lists has been fully merged, any remaining elements from the other list are appended to the merged list.</p> </li> <li> <p>Finally, the method returns the head of the merged list.</p> </li> </ul>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#complexity-analysis_2","title":"Complexity Analysis","text":"<ul> <li> <p>Let m be the number of nodes in <code>list1</code> and n be the number of nodes in <code>list2</code>.</p> </li> <li> <p>Time Complexity:</p> </li> <li>The merging process iterates through both lists once in a single pass until either <code>list1</code> or <code>list2</code> is exhausted.</li> <li> <p>Therefore, the time complexity is <code>O(m + n)</code> where m and n are the lengths of <code>list1</code> and <code>list2</code> respectively.</p> </li> <li> <p>Space Complexity:</p> </li> <li>Additional memory is only used for the <code>cur</code> pointer and the new merged linked list.</li> <li>Since the new nodes are created in-place and the space usage is mainly for pointers, the space complexity is _<code>O(1)</code>_, constant space complexity.</li> </ul> <p>In summary, the code efficiently merges two sorted singly-linked lists into a single sorted list with a time complexity of <code>O(m + n)</code> and a space complexity of <code>O(1)</code>.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solutions_2","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None) -&gt; None:\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val &lt; list2.val:\n                cur.next = list1\n                list1, cur = list1.next, list1\n            else:\n                cur.next = list2\n                list2, cur = list2.next, list2\n\n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n\n        return dummy.next\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;optional&gt;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* cur = new ListNode();\n        ListNode* dummy = cur;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy-&gt;next;\n    }\n};\n\nint main() {\n    ListNode* list1 = new ListNode(1);\n    list1-&gt;next = new ListNode(3);\n    list1-&gt;next-&gt;next = new ListNode(5);\n\n    ListNode* list2 = new ListNode(2);\n    list2-&gt;next = new ListNode(4);\n    list2-&gt;next-&gt;next = new ListNode(6);\n\n    Solution solution;\n    ListNode* mergedList = solution.mergeTwoLists(list1, list2);\n\n    while (mergedList != nullptr) {\n        std::cout &lt;&lt; mergedList-&gt;val &lt;&lt; \" \";\n        mergedList = mergedList-&gt;next;\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <pre><code>#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode { val, next: None }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn merge_two_lists(\n        list1: Option&lt;Box&lt;ListNode&gt;&gt;,\n        list2: Option&lt;Box&lt;ListNode&gt;&gt;,\n    ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut dummy = Box::new(ListNode::new(0));\n        let mut current = &amp;mut dummy;\n\n        let (mut l1, mut l2) = (list1, list2);\n        while let (Some(mut node1), Some(mut node2)) = (l1, l2) {\n            if node1.val &lt; node2.val {\n                l1 = node1.next.take();\n                current.next = Some(node1);\n            } else {\n                l2 = node2.next.take();\n                current.next = Some(node2);\n            }\n            current = current.next.as_mut().unwrap();\n        }\n        current.next = l1.or(l2);\n        dummy.next\n    }\n}\n\nfn main() {\n    let list1 = Some(Box::new(ListNode { val: 1, next: Some(Box::new(ListNode::new(3))) }));\n    let list2 = Some(Box::new(ListNode { val: 2, next: Some(Box::new(ListNode::new(4))) }));\n\n    let merged = Solution::merge_two_lists(list1, list2);\n    println!(\"{:?}\", merged);\n}\n</code></pre> <pre><code>public class ListNode {\n    public int val;\n    public ListNode next;\n    public ListNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (list1 != null &amp;&amp; list2 != null) {\n            if (list1.val &lt; list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        current.next = list1 ?? list2;\n        return dummy.next;\n    }\n}\n\nclass Program {\n    static void Main(string[] args) {\n        ListNode list1 = new ListNode(1) { next = new ListNode(3) };\n        ListNode list2 = new ListNode(2) { next = new ListNode(4) };\n\n        Solution solution = new Solution();\n        ListNode merged = solution.MergeTwoLists(list1, list2);\n\n        PrintList(merged);\n    }\n\n    static void PrintList(ListNode head) {\n        while (head != null) {\n            Console.Write(head.val + \" -&gt; \");\n            head = head.next;\n        }\n        Console.WriteLine(\"null\");\n    }\n}\n</code></pre> <pre><code>class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (list1 != null &amp;&amp; list2 != null) {\n            if (list1.val &lt; list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        current.next = (list1 != null) ? list1 : list2;\n        return dummy.next;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        ListNode list1 = new ListNode(1);\n        list1.next = new ListNode(3);\n        ListNode list2 = new ListNode(2);\n        list2.next = new ListNode(4);\n\n        Solution solution = new Solution();\n        ListNode merged = solution.mergeTwoLists(list1, list2);\n\n        printList(merged);\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" -&gt; \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n</code></pre> <pre><code>class ListNode(var x: Int = 0, var next: ListNode = null)\n\nobject Solution {\n    def mergeTwoLists(list1: ListNode, list2: ListNode): ListNode = {\n        val dummy = new ListNode(0)\n        var cur = dummy\n        var l1 = list1\n        var l2 = list2\n\n        while (l1 != null &amp;&amp; l2 != null) {\n            if (l1.x &lt; l2.x) {\n                cur.next = l1\n                l1 = l1.next\n            } else {\n                cur.next = l2\n                l2 = l2.next\n            }\n            cur = cur.next\n        }\n        cur.next = if (l1 != null) l1 else l2\n        dummy.next\n    }\n}\n\nobject Main extends App {\n    def printList(head: ListNode): Unit = {\n        var current = head\n        while (current != null) {\n            print(s\"${current.x} -&gt; \")\n            current = current.next\n        }\n        println(\"null\")\n    }\n\n    val list1 = new ListNode(1, new ListNode(3))\n    val list2 = new ListNode(2, new ListNode(4))\n\n    val merged = Solution.mergeTwoLists(list1, list2)\n    printList(merged)\n}\n</code></pre> <pre><code>class ListNode(var `val`: Int, var next: ListNode? = null)\n\nclass Solution {\n    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {\n        val dummy = ListNode(0)\n        var cur = dummy\n        var l1 = list1\n        var l2 = list2\n\n        while (l1 != null &amp;&amp; l2 != null) {\n            if (l1.`val` &lt; l2.`val`) {\n                cur.next = l1\n                l1 = l1.next\n            } else {\n                cur.next = l2\n                l2 = l2.next\n            }\n            cur = cur.next!!\n        }\n        cur.next = l1 ?: l2\n        return dummy.next\n    }\n}\n\nfun printList(head: ListNode?) {\n    var current = head\n    while (current != null) {\n        print(\"${current.`val`} -&gt; \")\n        current = current.next\n    }\n    println(\"null\")\n}\n\nfun main() {\n    val list1 = ListNode(1, ListNode(3))\n    val list2 = ListNode(2, ListNode(4))\n\n    val solution = Solution()\n    val merged = solution.mergeTwoLists(list1, list2)\n\n    printList(merged)\n}\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    dummy := &amp;ListNode{}\n    current := dummy\n\n    for list1 != nil &amp;&amp; list2 != nil {\n        if list1.Val &lt; list2.Val {\n            current.Next = list1\n            list1 = list1.Next\n        } else {\n            current.Next = list2\n            list2 = list2.Next\n        }\n        current = current.Next\n    }\n    if list1 != nil {\n        current.Next = list1\n    } else {\n        current.Next = list2\n    }\n\n    return dummy.Next\n}\n\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Printf(\"%d -&gt; \", head.Val)\n        head = head.Next\n    }\n    fmt.Println(\"nil\")\n}\n\nfunc main() {\n    list1 := &amp;ListNode{Val: 1, Next: &amp;ListNode{Val: 3}}\n    list2 := &amp;ListNode{Val: 2, Next: &amp;ListNode{Val: 4}}\n\n    fmt.Println(\"Merged Linked List:\")\n    merged := mergeTwoLists(list1, list2)\n    printList(merged)\n}\n</code></pre> <pre><code>class ListNode {\n    val: number;\n    next: ListNode | null;\n\n    constructor(val: number = 0, next: ListNode | null = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nclass Solution {\n    mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n        const dummy = new ListNode();\n        let current = dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1.val &lt; list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        current.next = list1 || list2;\n        return dummy.next;\n    }\n}\n\nfunction printList(head: ListNode | null): void {\n    while (head) {\n        process.stdout.write(head.val + \" -&gt; \");\n        head = head.next;\n    }\n    console.log(\"null\");\n}\n\nconst list1 = new ListNode(1, new ListNode(3));\nconst list2 = new ListNode(2, new ListNode(4));\n\nconst solution = new Solution();\nconst merged = solution.mergeTwoLists(list1, list2);\n\nconsole.log(\"Merged Linked List:\");\nprintList(merged);\n</code></pre> <pre><code>ListNode &lt;- setRefClass(\"ListNode\",\n                        fields = list(val = \"numeric\", next = \"ANY\"))\n\nmergeTwoLists &lt;- function(list1, list2) {\n    dummy &lt;- ListNode$new(val = 0)\n    current &lt;- dummy\n\n    while (!is.null(list1) &amp;&amp; !is.null(list2)) {\n        if (list1$val &lt; list2$val) {\n            current$next &lt;- list1\n            list1 &lt;- list1$next\n        } else {\n            current$next &lt;- list2\n            list2 &lt;- list2$next\n        }\n        current &lt;- current$next\n    }\n\n    if (!is.null(list1)) {\n        current$next &lt;- list1\n    } else {\n        current$next &lt;- list2\n    }\n\n    return(dummy$next)\n}\n\nprintList &lt;- function(head) {\n    while (!is.null(head)) {\n        cat(head$val, \"-&gt; \")\n        head &lt;- head$next\n    }\n    cat(\"NULL\\n\")\n}\n\n# Example usage\nlist1 &lt;- ListNode$new(val = 1, next = ListNode$new(val = 3))\nlist2 &lt;- ListNode$new(val = 2, next = ListNode$new(val = 4))\n\ncat(\"Merged Linked List:\\n\")\nmerged &lt;- mergeTwoLists(list1, list2)\nprintList(merged)\n</code></pre> <pre><code>mutable struct ListNode\n    val::Int\n    next::Union{ListNode, Nothing}\n    ListNode(val::Int, next::Union{ListNode, Nothing}=nothing) = new(val, next)\nend\n\nfunction mergeTwoLists(list1::Union{ListNode, Nothing}, list2::Union{ListNode, Nothing})\n    dummy = ListNode(0)\n    current = dummy\n\n    while list1 !== nothing &amp;&amp; list2 !== nothing\n        if list1.val &lt; list2.val\n            current.next = list1\n            list1 = list1.next\n        else\n            current.next = list2\n            list2 = list2.next\n        end\n        current = current.next\n    end\n\n    current.next = if list1 !== nothing list1 else list2 end\n    return dummy.next\nend\n\nfunction printList(head::Union{ListNode, Nothing})\n    while head !== nothing\n        print(head.val, \" -&gt; \")\n        head = head.next\n    end\n    println(\"nil\")\nend\n\n# Example usage\nlist1 = ListNode(1, ListNode(3))\nlist2 = ListNode(2, ListNode(4))\n\nprintln(\"Merged Linked List:\")\nmerged = mergeTwoLists(list1, list2)\nprintList(merged)\n</code></pre>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#linked-list-cycle","title":"Linked List Cycle","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#problem-description-leetcode-problem-21-linked-list-cycle","title":"Problem Description: LeetCode - Problem 21 - Linked List Cycle","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solution-explanation_3","title":"Solution Explanation","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#complexity-analysis_3","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#time-complexity_1","title":"Time Complexity","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#space-complexity_1","title":"Space Complexity","text":"","tags":["Original"]},{"location":"data_structures/003_Linked_List/#solutions_3","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code># TC = O(N), SC = O(1)\n\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, data: int) -&gt; None:\n        self.data: int = data\n        self.next: Optional['Node'] = None\n\ndef push(head: Optional[Node], data: int) -&gt; Node:\n    new_node = Node(data)\n    if head is None:\n        return new_node\n    else:\n        curr = head\n        while curr.next is not None:\n            curr = curr.next\n        curr.next = new_node\n        return head\n\n#def print_list(head: Optional[Node]) -&gt; None:\n#    while head:\n#        print(f\"{head.data}--&gt;\", end=\"\")\n#        head = head.next\n#    print(\"NULL\")\n\ndef print_list(head: Optional[Node]) -&gt; None:\n    visited = set()\n    while head:\n        if head in visited:\n            print(f\"({head.data})--&gt;\", end=\"\")\n            print(\"Cycle detected here...\")\n            return\n        print(f\"{head.data}--&gt;\", end=\"\")\n        visited.add(head)\n        head = head.next\n    print(\"NULL\")\n\nclass Solution:\n    def hasCycle(self, head: Optional[Node]) -&gt; bool:\n        if not head or not head.next:\n            return False\n\n        slow = head\n        fast = head.next\n\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n\n        return True\n\nif __name__ == \"__main__\":\n    head: Optional[Node] = None\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    print(\"Does the following LinkedList: [ \", end=\"\")\n    print_list(head)\n    print(f\" ] have a cycle? {Solution().hasCycle(head)}\")\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int data) : data(data), next(nullptr) {}\n};\n\nNode* push(Node* head, int data) {\n    Node* new_node = new Node(data);\n    if (!head) {\n        return new_node;\n    }\n    Node* curr = head;\n    while (curr-&gt;next) {\n        curr = curr-&gt;next;\n    }\n    curr-&gt;next = new_node;\n    return head;\n}\n\nvoid print_list(Node* head) {\n    std::unordered_set&lt;Node*&gt; visited;\n    while (head) {\n        if (visited.count(head)) {\n            std::cout &lt;&lt; \"(\" &lt;&lt; head-&gt;data &lt;&lt; \")--&gt;\";\n            std::cout &lt;&lt; \"Cycle detected here...\" &lt;&lt; std::endl;\n            return;\n        }\n        std::cout &lt;&lt; head-&gt;data &lt;&lt; \"--&gt;\";\n        visited.insert(head);\n        head = head-&gt;next;\n    }\n    std::cout &lt;&lt; \"NULL\" &lt;&lt; std::endl;\n}\n\nclass Solution {\npublic:\n    bool hasCycle(Node* head) {\n        if (!head || !head-&gt;next) return false;\n\n        Node* slow = head;\n        Node* fast = head-&gt;next;\n\n        while (slow != fast) {\n            if (!fast || !fast-&gt;next) return false;\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Node* head = nullptr;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    std::cout &lt;&lt; \"Does the following LinkedList: [ \";\n    print_list(head);\n    std::cout &lt;&lt; \"] have a cycle? \" &lt;&lt; std::boolalpha &lt;&lt; Solution().hasCycle(head) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <pre><code>use std::collections::HashSet;\n\n#[derive(Debug)]\nstruct Node {\n    data: i32,\n    next: Option&lt;Box&lt;Node&gt;&gt;,\n}\n\nimpl Node {\n    fn new(data: i32) -&gt; Self {\n        Node { data, next: None }\n    }\n}\n\nfn push(head: Option&lt;Box&lt;Node&gt;&gt;, data: i32) -&gt; Option&lt;Box&lt;Node&gt;&gt; {\n    let mut new_node = Box::new(Node::new(data));\n    if let Some(mut curr) = head {\n        while let Some(next) = curr.next.take() {\n            curr = next;\n        }\n        curr.next = Some(new_node);\n        Some(head)\n    } else {\n        Some(new_node)\n    }\n}\n\nfn print_list(head: &amp;Option&lt;Box&lt;Node&gt;&gt;) {\n    let mut visited = HashSet::new();\n    let mut current = head;\n    while let Some(node) = current {\n        if visited.contains(&amp;node.as_ref()) {\n            println!(\"({})--&gt; Cycle detected here...\", node.data);\n            return;\n        }\n        print!(\"{}--&gt;\", node.data);\n        visited.insert(node.as_ref());\n        current = &amp;node.next;\n    }\n    println!(\"NULL\");\n}\n\nstruct Solution;\n\nimpl Solution {\n    fn has_cycle(head: &amp;Option&lt;Box&lt;Node&gt;&gt;) -&gt; bool {\n        let mut slow = head.as_ref();\n        let mut fast = head.as_ref();\n\n        while let Some(s) = slow {\n            slow = s.next.as_ref();\n            fast = fast.and_then(|f| f.next.as_ref()).and_then(|f| f.next.as_ref());\n            if slow == fast {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut head = None;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    print!(\"Does the following LinkedList: [ \");\n    print_list(&amp;head);\n    println!(\"] have a cycle? {}\", Solution::has_cycle(&amp;head));\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\npublic class Node {\n    public int data;\n    public Node next;\n\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\npublic class Solution {\n    public bool HasCycle(Node head) {\n        if (head == null || head.next == null) return false;\n\n        Node slow = head;\n        Node fast = head.next;\n\n        while (slow != fast) {\n            if (fast == null || fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\nclass Program {\n    static Node Push(Node head, int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            return newNode;\n        } else {\n            Node curr = head;\n            while (curr.next != null) {\n                curr = curr.next;\n            }\n            curr.next = newNode;\n            return head;\n        }\n    }\n\n    static void PrintList(Node head) {\n        HashSet&lt;Node&gt; visited = new HashSet&lt;Node&gt;();\n        while (head != null) {\n            if (visited.Contains(head)) {\n                Console.WriteLine($\"({head.data})--&gt; Cycle detected here...\");\n                return;\n            }\n            Console.Write($\"{head.data}--&gt;\");\n            visited.Add(head);\n            head = head.next;\n        }\n        Console.WriteLine(\"NULL\");\n    }\n\n    static void Main() {\n        Node head = null;\n        head = Push(head, 1);\n        head = Push(head, 2);\n        head = Push(head, 3);\n        head = Push(head, 4);\n        head = Push(head, 5);\n\n        Console.Write(\"Does the following LinkedList: [ \");\n        PrintList(head);\n        Console.WriteLine($\"] have a cycle? {new Solution().HasCycle(head)}\");\n    }\n}\n</code></pre> <pre><code>import java.util.HashSet;\n\nclass Node {\n    int data;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass Solution {\n    public boolean hasCycle(Node head) {\n        if (head == null || head.next == null) return false;\n\n        Node slow = head;\n        Node fast = head.next;\n\n        while (slow != fast) {\n            if (fast == null || fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\npublic class LinkedListCycle {\n    static Node push(Node head, int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            return newNode;\n        } else {\n            Node curr = head;\n            while (curr.next != null) {\n                curr = curr.next;\n            }\n            curr.next = newNode;\n            return head;\n        }\n    }\n\n    static void printList(Node head) {\n        HashSet&lt;Node&gt; visited = new HashSet&lt;&gt;();\n        while (head != null) {\n            if (visited.contains(head)) {\n                System.out.println(\"(\" + head.data + \")--&gt; Cycle detected here...\");\n                return;\n            }\n            System.out.print(head.data + \"--&gt;\");\n            visited.add(head);\n            head = head.next;\n        }\n        System.out.println(\"NULL\");\n    }\n\n    public static void main(String[] args) {\n        Node head = null;\n        head = push(head, 1);\n        head = push(head, 2);\n        head = push(head, 3);\n        head = push(head, 4);\n        head = push(head, 5);\n\n        System.out.print(\"Does the following LinkedList: [ \");\n        printList(head);\n        System.out.println(\"] have a cycle? \" + new Solution().hasCycle(head));\n    }\n}\n</code></pre> <pre><code>import scala.collection.mutable\n\nclass Node(var data: Int) {\n    var next: Option[Node] = None\n}\n\nobject LinkedListCycle {\n    def push(head: Option[Node], data: Int): Option[Node] = {\n        val newNode = new Node(data)\n        head match {\n        case None =&gt; Some(newNode)\n        case Some(curr) =&gt;\n            var temp = curr\n            while (temp.next.isDefined) {\n                temp = temp.next.get\n            }\n            temp.next = Some(newNode)\n            head\n        }\n    }\n\n    def printList(head: Option[Node]): Unit = {\n        val visited = mutable.HashSet[Node]()\n        var current = head\n        while (current.isDefined) {\n            current match {\n                case Some(node) =&gt;\n                    if (visited.contains(node)) {\n                        println(s\"(${node.data})--&gt; Cycle detected here...\")\n                        return\n                    }\n                    print(s\"${node.data}--&gt;\")\n                    visited.add(node)\n                    current = node.next\n                case None =&gt; \n            }\n        }\n        println(\"NULL\")\n    }\n\n    class Solution {\n        def hasCycle(head: Option[Node]): Boolean = {\n        if (head.isEmpty || head.get.next.isEmpty) return false\n\n        var slow = head\n        var fast = head.flatMap(_.next)\n\n        while (slow != fast) {\n            if (fast.isEmpty || fast.get.next.isEmpty) return false\n            slow = slow.flatMap(_.next)\n            fast = fast.flatMap(_.next).flatMap(_.next)\n        }\n        true\n        }\n    }\n\n    def main(args: Array[String]): Unit = {\n        var head: Option[Node] = None\n        head = push(head, 1)\n        head = push(head, 2)\n        head = push(head, 3)\n        head = push(head, 4)\n        head = push(head, 5)\n\n        print(\"Does the following LinkedList: [ \")\n        printList(head)\n        println(s\"] have a cycle? ${new Solution().hasCycle(head)}\")\n    }\n}\n</code></pre> <pre><code>class Node(var data: Int) {\n    var next: Node? = null\n}\n\nclass Solution {\n    fun hasCycle(head: Node?): Boolean {\n        if (head == null || head.next == null) return false\n\n        var slow: Node? = head\n        var fast: Node? = head.next\n\n        while (slow != fast) {\n            if (fast == null || fast.next == null) return false\n            slow = slow?.next\n            fast = fast.next?.next\n        }\n        return true\n    }\n}\n\nfun push(head: Node?, data: Int): Node {\n    val newNode = Node(data)\n    return if (head == null) {\n        newNode\n    } else {\n        var curr = head\n        while (curr.next != null) {\n            curr = curr.next!!\n        }\n        curr.next = newNode\n        head\n    }\n}\n\nfun printList(head: Node?) {\n    val visited = mutableSetOf&lt;Node&gt;()\n    var current: Node? = head\n    while (current != null) {\n        if (current in visited) {\n            println(\"(${current.data})--&gt; Cycle detected here...\")\n            return\n        }\n        print(\"${current.data}--&gt;\")\n        visited.add(current)\n        current = current.next\n    }\n    println(\"NULL\")\n}\n\nfun main() {\n    var head: Node? = null\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    print(\"Does the following LinkedList: [ \")\n    printList(head)\n    println(\"] have a cycle? ${Solution().hasCycle(head)}\")\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype Node struct {\n    data int\n    next *Node\n}\n\nfunc push(head *Node, data int) *Node {\n    newNode := &amp;Node{data: data}\n    if head == nil {\n        return newNode\n    }\n    curr := head\n    for curr.next != nil {\n        curr = curr.next\n    }\n    curr.next = newNode\n    return head\n}\n\nfunc printList(head *Node) {\n    visited := make(map[*Node]bool)\n    for head != nil {\n        if visited[head] {\n            fmt.Printf(\"(%d)--&gt; Cycle detected here...\\n\", head.data)\n            return\n        }\n        fmt.Printf(\"%d--&gt;\", head.data)\n        visited[head] = true\n        head = head.next\n    }\n    fmt.Println(\"NULL\")\n}\n\ntype Solution struct{}\n\nfunc (s *Solution) hasCycle(head *Node) bool {\n    if head == nil || head.next == nil {\n        return false\n    }\n\n    slow, fast := head, head.next\n\n    for slow != fast {\n        if fast == nil || fast.next == nil {\n            return false\n        }\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return true\n}\n\nfunc main() {\n    var head *Node\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    fmt.Print(\"Does the following LinkedList: [ \")\n    printList(head)\n    fmt.Printf(\"] have a cycle? %v\\n\", (&amp;Solution{}).hasCycle(head))\n}\n</code></pre> <pre><code>class Node {\n    data: number;\n    next: Node | null;\n\n    constructor(data: number) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction push(head: Node | null, data: number): Node {\n    const newNode = new Node(data);\n    if (head === null) {\n        return newNode;\n    } else {\n        let curr = head;\n        while (curr.next !== null) {\n            curr = curr.next;\n        }\n        curr.next = newNode;\n        return head;\n    }\n}\n\nfunction printList(head: Node | null): void {\n    const visited = new Set&lt;Node&gt;();\n    while (head !== null) {\n        if (visited.has(head)) {\n            console.log(`(${head.data})--&gt; Cycle detected here...`);\n            return;\n        }\n        process.stdout.write(`${head.data}--&gt;`);\n        visited.add(head);\n        head = head.next;\n    }\n    console.log(\"NULL\");\n}\n\nclass Solution {\n    hasCycle(head: Node | null): boolean {\n        if (head === null || head.next === null) return false;\n\n        let slow: Node | null = head;\n        let fast: Node | null = head.next;\n\n        while (slow !== fast) {\n            if (fast === null || fast.next === null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\nfunction main(): void {\n    let head: Node | null = null;\n    head = push(head, 1);\n    head = push(head, 2);\n    head = push(head, 3);\n    head = push(head, 4);\n    head = push(head, 5);\n\n    process.stdout.write(\"Does the following LinkedList: [ \");\n    printList(head);\n    console.log(`] have a cycle? ${new Solution().hasCycle(head)}`);\n}\n\nmain();\n</code></pre> <pre><code>Node &lt;- setRefClass(\"Node\", fields = list(data = \"numeric\", next = \"Node\"))\n\npush &lt;- function(head, data) {\n    new_node &lt;- Node$new(data)\n    if (is.null(head)) {\n        return(new_node)\n    } else {\n        curr &lt;- head\n        while (!is.null(curr$next)) {\n            curr &lt;- curr$next\n        }\n        curr$next &lt;- new_node\n        return(head)\n    }\n}\n\nprint_list &lt;- function(head) {\n    visited &lt;- list()\n    while (!is.null(head)) {\n        if (head %in% visited) {\n            cat(sprintf(\"(%d)--&gt; Cycle detected here...\\n\", head$data))\n            return()\n        }\n        cat(sprintf(\"%d--&gt;\", head$data))\n        visited &lt;- append(visited, list(head))\n        head &lt;- head$next\n    }\n    cat(\"NULL\\n\")\n}\n\nhas_cycle &lt;- function(head) {\n    if (is.null(head) || is.null(head$next)) return(FALSE)\n\n    slow &lt;- head\n    fast &lt;- head$next\n\n    while (slow != fast) {\n        if (is.null(fast) || is.null(fast$next)) return(FALSE)\n        slow &lt;- slow$next\n        fast &lt;- fast$next$next\n    }\n    return(TRUE)\n}\n\nmain &lt;- function() {\n    head &lt;- NULL\n    head &lt;- push(head, 1)\n    head &lt;- push(head, 2)\n    head &lt;- push(head, 3)\n    head &lt;- push(head, 4)\n    head &lt;- push(head, 5)\n\n    cat(\"Does the following LinkedList: [ \")\n    print_list(head)\n    cat(sprintf(\"] have a cycle? %s\\n\", has_cycle(head)))\n}\n\nmain()\n</code></pre> <pre><code>mutable struct Node\n    data::Int\n    next::Union{Node, Nothing}\nend\n\nfunction push(head::Union{Node, Nothing}, data::Int)\n    new_node = Node(data, nothing)\n    if head === nothing\n        return new_node\n    else\n        curr = head\n        while curr.next !== nothing\n            curr = curr.next\n        end\n        curr.next = new_node\n        return head\n    end\nend\n\nfunction print_list(head::Union{Node, Nothing})\n    visited = Set{Node}()\n    while head !== nothing\n        if head in visited\n            println(\"($head.data)--&gt; Cycle detected here...\")\n            return\n        end\n        print(\"$head.data--&gt;\")\n        push!(visited, head)\n        head = head.next\n    end\n    println(\"NULL\")\nend\n\nstruct Solution end\n\nfunction has_cycle(s::Solution, head::Union{Node, Nothing})\n    if head === nothing || head.next === nothing\n        return false\n    end\n\n    slow = head\n    fast = head.next\n\n    while slow != fast\n        if fast === nothing || fast.next === nothing\n            return false\n        end\n        slow = slow.next\n        fast = fast.next.next\n    end\n    return true\nend\n\nfunction main()\n    head = nothing\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 3)\n    head = push(head, 4)\n    head = push(head, 5)\n\n    print(\"Does the following LinkedList: [ \")\n    print_list(head)\n    println(\"] have a cycle? \", has_cycle(Solution(), head))\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"data_structures/004_Stack/","title":"Stack","text":"","tags":["Original"]},{"location":"data_structures/005_Queue/","title":"Queue","text":"","tags":["Original"]},{"location":"data_structures/006_Binary_Heap/","title":"Binary Heap","text":"","tags":["Original"]},{"location":"data_structures/007_Tree/","title":"Tree","text":"","tags":["Original"]},{"location":"data_structures/008_Graph/","title":"Graph","text":"","tags":["Original"]},{"location":"data_structures/009_Hashtable/","title":"Hashtable","text":"","tags":["Original"]},{"location":"design/001_Design/","title":"Design","text":"","tags":["Original"]},{"location":"design/001_Design/#design-a-lru-cache","title":"Design a LRU Cache","text":"","tags":["Original"]},{"location":"design/001_Design/#problem-description-leetcode-problem-146-design-a-lru-cache","title":"Problem Description: LeetCode - Problem 146 - Design a LRU Cache","text":"","tags":["Original"]},{"location":"design/001_Design/#problem-description","title":"Problem Description:","text":"<p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p> <p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"design/001_Design/#solution-explanation","title":"Solution Explanation","text":"<p>The provided Python code implements a Least Recently Used (LRU) Cache using two different approaches: one based on <code>OrderedDict</code> and another using a custom linked list with a hash map for fast access. Below is a detailed explanation of both implementations, followed by a complexity analysis for time and space.</p>","tags":["Original"]},{"location":"design/001_Design/#explanation-of-the-implementations","title":"Explanation of the Implementations","text":"","tags":["Original"]},{"location":"design/001_Design/#1-lrucache-ordereddict-based","title":"1. LRUCache (OrderedDict-Based)","text":"<ul> <li>Class Definition:</li> <li>The class <code>LRUCache</code> is initialized with a specified <code>capacity</code>.</li> <li> <p>It uses <code>collections.OrderedDict</code> to maintain the order of the keys.</p> </li> <li> <p>Methods:</p> </li> <li> <p><code>__init__(self, capacity: int)</code>: Initializes the cache with a given capacity and an empty <code>OrderedDict</code>.</p> </li> <li> <p><code>get(self, key: int) -&gt; int</code>: </p> <ul> <li>Checks if the key exists in the cache.</li> <li>If it exists, it retrieves the value, updates the order of the key (moving it to the end), and returns the value.</li> <li>If it doesn't exist, returns <code>-1</code>.</li> </ul> </li> <li> <p><code>put(self, key: int, val: int) -&gt; None</code>: </p> <ul> <li>If the key does not exist and the cache has reached its capacity, it evicts the least recently used (the first item in the <code>OrderedDict</code>).</li> <li>Calls <code>__update</code> to update the value of the key.</li> </ul> </li> <li> <p><code>__update(self, key: int, val: int) -&gt; None</code>: </p> <ul> <li>Removes the key if it exists (to update its value).</li> <li>Adds the key and value to the cache, automatically moving it to the end (most recently used).</li> </ul> </li> </ul>","tags":["Original"]},{"location":"design/001_Design/#2-lrucache2-linked-list-based","title":"2. LRUCache2 (Linked List-Based)","text":"<ul> <li>Class Definitions:</li> <li><code>ListNode</code>: Represents each node in the linked list, containing the <code>key</code>, <code>value</code>, and pointers to the previous and next nodes.</li> <li> <p><code>LinkedList</code>: A custom linked list class that maintains a head and tail pointer.</p> <ul> <li><code>insert(self, node: ListNode)</code>: Inserts a new node at the end of the linked list.</li> <li><code>delete(self, node: ListNode)</code>: Removes a node from the linked list.</li> </ul> </li> <li> <p>Methods in <code>LRUCache2</code>:</p> </li> <li> <p><code>__init__(self, capacity: int)</code>: Initializes the linked list and a hash map (<code>dict</code>) to store key-node pairs.</p> </li> <li> <p><code>get(self, key: int) -&gt; int</code>: </p> <ul> <li>Similar to the previous implementation, retrieves the value if the key exists, updates its position, and returns the value. If it doesn't exist, returns <code>-1</code>.</li> </ul> </li> <li> <p><code>put(self, key: int, val: int) -&gt; None</code>: </p> <ul> <li>If the key does not exist and the cache is full, it evicts the least recently used node (the head of the linked list).</li> <li>Calls <code>__update</code> to insert or update the value of the key.</li> </ul> </li> <li> <p><code>__update(self, key: int, val: int) -&gt; None</code>: </p> <ul> <li>Deletes the existing node if the key exists.</li> <li>Creates a new <code>ListNode</code>, inserts it at the end of the linked list, and updates the hash map.</li> </ul> </li> </ul>","tags":["Original"]},{"location":"design/001_Design/#complexity-analysis","title":"Complexity Analysis","text":"","tags":["Original"]},{"location":"design/001_Design/#time-complexity","title":"Time Complexity","text":"<ul> <li>OrderedDict-Based LRUCache:</li> <li> <p>get: </p> <ul> <li><code>O(1)</code> average case for retrieving a value using the <code>OrderedDict</code>'s hash map.</li> <li><code>O(n)</code> in the worst case for moving the accessed item to the end of the <code>OrderedDict</code> due to the underlying structure (but this operation is generally fast due to the order being maintained).</li> </ul> </li> <li> <p>put: </p> <ul> <li><code>O(1)</code> for checking existence and inserting into the <code>OrderedDict</code>. The eviction is O(1)`__ since it removes the first item (least recently used).</li> </ul> </li> <li> <p>LinkedList-Based LRUCache2:</p> </li> <li> <p>get: </p> <ul> <li><code>O(1)</code> for retrieving the node from the hash map.</li> <li><code>O(1)</code> for deleting and reinserting the node in the linked list (updating position).</li> </ul> </li> <li> <p>put: </p> <ul> <li><code>O(1)</code> for checking existence and updating or inserting the node in the hash map.</li> <li><code>O(1)</code> for deleting the least recently used node (head of the linked list) if the cache is full.</li> </ul> </li> </ul>","tags":["Original"]},{"location":"design/001_Design/#space-complexity","title":"Space Complexity","text":"<ul> <li>Both implementations maintain two data structures:</li> <li>A hash map to store key-value pairs for <code>O(1)</code> access.</li> <li> <p>An additional structure (either <code>OrderedDict</code> or a linked list) to maintain the order of keys.</p> </li> <li> <p>Space Complexity:</p> </li> <li><code>O(capacity)</code>  for both implementations since they can only store up to <code>capacity</code> key-value pairs.</li> </ul>","tags":["Original"]},{"location":"design/001_Design/#summary","title":"Summary","text":"<ul> <li>The <code>OrderedDict</code>-based implementation is simpler and leverages Python's built-in features, making it easy to read and understand.</li> <li>The linked list implementation is more manual but provides a good understanding of how LRU caches work at a lower level, managing nodes and pointers.</li> <li>Both implementations efficiently support the required operations while adhering to <code>O(1)</code> average time complexity for <code>get</code> and <code>put</code> operations and <code>O(capacity)</code>  space complexity.</li> </ul>","tags":["Original"]},{"location":"design/001_Design/#solutions","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>from typing import Optional, Dict\nimport collections\n\n\n# Using OrderedDict\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache: collections.OrderedDict[int, int] = collections.OrderedDict()\n        self.capacity: int = capacity\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key: int, val: int) -&gt; None:\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n\n    def __update(self, key: int, val: int) -&gt; None:\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n# Linked List implementation for LRU cache\nclass ListNode:\n    def __init__(self, key: int, val: int):\n        self.val: int = val\n        self.key: int = key\n        self.next: Optional['ListNode'] = None\n        self.prev: Optional['ListNode'] = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head: Optional[ListNode] = None\n        self.tail: Optional[ListNode] = None\n\n    def insert(self, node: ListNode) -&gt; None:\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            assert self.tail is not None  # for type checking\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node: ListNode) -&gt; None:\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n\nclass LRUCache2:\n    def __init__(self, capacity: int):\n        self.list = LinkedList()\n        self.dict: Dict[int, ListNode] = {}\n        self.capacity: int = capacity\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key: int, val: int) -&gt; None:\n        if key not in self.dict and len(self.dict) == self.capacity:\n            assert self.list.head is not None  # for type checking\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key: int, val: int) -&gt; None:\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node\n\n\ndef main() -&gt; None:\n    # Demonstrating LRUCache (OrderedDict-based)\n    print(\"Using LRUCache (OrderedDict-based):\")\n    lru_cache = LRUCache(capacity=2)\n    lru_cache.put(1, 1)\n    lru_cache.put(2, 2)\n    print(lru_cache.get(1))  # returns 1\n    lru_cache.put(3, 3)      # evicts key 2\n    print(lru_cache.get(2))  # returns -1 (not found)\n    lru_cache.put(4, 4)      # evicts key 1\n    print(lru_cache.get(1))  # returns -1 (not found)\n    print(lru_cache.get(3))  # returns 3\n    print(lru_cache.get(4))  # returns 4\n\n    print(\"\\nUsing LRUCache2 (LinkedList-based):\")\n    # Demonstrating LRUCache2 (LinkedList-based)\n    lru_cache2 = LRUCache2(capacity=2)\n    lru_cache2.put(1, 1)\n    lru_cache2.put(2, 2)\n    print(lru_cache2.get(1))  # returns 1\n    lru_cache2.put(3, 3)      # evicts key 2\n    print(lru_cache2.get(2))  # returns -1 (not found)\n    lru_cache2.put(4, 4)      # evicts key 1\n    print(lru_cache2.get(1))  # returns -1 (not found)\n    print(lru_cache2.get(3))  # returns 3\n    print(lru_cache2.get(4))  # returns 4\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;unordered_map&gt;\n\n// OrderedDict-based LRU Cache using std::list and std::unordered_map\nclass LRUCacheOrdered {\n    int capacity;\n    std::list&lt;std::pair&lt;int, int&gt;&gt; cacheList;\n    std::unordered_map&lt;int, std::list&lt;std::pair&lt;int, int&gt;&gt;::iterator&gt; cacheMap;\n\npublic:\n    LRUCacheOrdered(int cap) : capacity(cap) {}\n\n    int get(int key) {\n        if (cacheMap.find(key) == cacheMap.end()) return -1;\n        cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);\n        return cacheMap[key]-&gt;second;\n    }\n\n    void put(int key, int value) {\n        if (cacheMap.find(key) != cacheMap.end()) {\n            cacheList.erase(cacheMap[key]);\n        } else if (cacheList.size() == capacity) {\n            int lastKey = cacheList.back().first;\n            cacheList.pop_back();\n            cacheMap.erase(lastKey);\n        }\n        cacheList.emplace_front(key, value);\n        cacheMap[key] = cacheList.begin();\n    }\n};\n\n// LinkedList-based LRU Cache\nstruct ListNode {\n    int key, value;\n    ListNode* next = nullptr;\n    ListNode* prev = nullptr;\n    ListNode(int k, int v) : key(k), value(v) {}\n};\n\nclass LRUCacheLinkedList {\n    int capacity;\n    std::unordered_map&lt;int, ListNode*&gt; cacheMap;\n    ListNode* head = nullptr;\n    ListNode* tail = nullptr;\n\n    void removeNode(ListNode* node) {\n        if (node-&gt;prev) node-&gt;prev-&gt;next = node-&gt;next;\n        if (node-&gt;next) node-&gt;next-&gt;prev = node-&gt;prev;\n        if (node == head) head = node-&gt;next;\n        if (node == tail) tail = node-&gt;prev;\n    }\n\n    void insertNodeAtEnd(ListNode* node) {\n        node-&gt;next = nullptr;\n        node-&gt;prev = tail;\n        if (tail) tail-&gt;next = node;\n        tail = node;\n        if (!head) head = node;\n    }\n\npublic:\n    LRUCacheLinkedList(int cap) : capacity(cap) {}\n\n    int get(int key) {\n        if (cacheMap.find(key) == cacheMap.end()) return -1;\n        ListNode* node = cacheMap[key];\n        removeNode(node);\n        insertNodeAtEnd(node);\n        return node-&gt;value;\n    }\n\n    void put(int key, int value) {\n        if (cacheMap.find(key) != cacheMap.end()) {\n            removeNode(cacheMap[key]);\n            delete cacheMap[key];\n        } else if (cacheMap.size() == capacity) {\n            int removeKey = head-&gt;key;\n            ListNode* temp = head;\n            removeNode(head);\n            delete temp;\n            cacheMap.erase(removeKey);\n        }\n        ListNode* newNode = new ListNode(key, value);\n        insertNodeAtEnd(newNode);\n        cacheMap[key] = newNode;\n    }\n\n    ~LRUCacheLinkedList() {\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* temp = curr;\n            curr = curr-&gt;next;\n            delete temp;\n        }\n    }\n};\n\nint main() {\n    // Testing OrderedDict-based LRU Cache\n    std::cout &lt;&lt; \"Testing LRUCacheOrdered:\\n\";\n    LRUCacheOrdered lruOrdered(2);\n    lruOrdered.put(1, 1);\n    lruOrdered.put(2, 2);\n    std::cout &lt;&lt; lruOrdered.get(1)`__ &lt;&lt; std::endl;  // returns 1\n    lruOrdered.put(3, 3);  // evicts key 2\n    std::cout &lt;&lt; lruOrdered.get(2) &lt;&lt; std::endl;  // returns -1 (not found)\n    lruOrdered.put(4, 4);  // evicts key 1\n    std::cout &lt;&lt; lruOrdered.get(1)`__ &lt;&lt; std::endl;  // returns -1 (not found)\n    std::cout &lt;&lt; lruOrdered.get(3) &lt;&lt; std::endl;  // returns 3\n    std::cout &lt;&lt; lruOrdered.get(4) &lt;&lt; std::endl;  // returns 4\n\n    // Testing LinkedList-based LRU Cache\n    std::cout &lt;&lt; \"\\nTesting LRUCacheLinkedList:\\n\";\n    LRUCacheLinkedList lruLinked(2);\n    lruLinked.put(1, 1);\n    lruLinked.put(2, 2);\n    std::cout &lt;&lt; lruLinked.get(1)`__ &lt;&lt; std::endl;  // returns 1\n    lruLinked.put(3, 3);  // evicts key 2\n    std::cout &lt;&lt; lruLinked.get(2) &lt;&lt; std::endl;  // returns -1 (not found)\n    lruLinked.put(4, 4);  // evicts key 1\n    std::cout &lt;&lt; lruLinked.get(1)`__ &lt;&lt; std::endl;  // returns -1 (not found)\n    std::cout &lt;&lt; lruLinked.get(3) &lt;&lt; std::endl;  // returns 3\n    std::cout &lt;&lt; lruLinked.get(4) &lt;&lt; std::endl;  // returns 4\n\n    return 0;\n}\n</code></pre> <pre><code>use std::collections::HashMap;\n\n// OrderedDict-based LRU Cache\nstruct LRUCacheOrdered {\n    capacity: usize,\n    cache: HashMap&lt;i32, i32&gt;,\n    order: Vec&lt;i32&gt;, // To maintain the order of keys\n}\n\nimpl LRUCacheOrdered {\n    fn new(capacity: usize) -&gt; Self {\n        LRUCacheOrdered {\n            capacity,\n            cache: HashMap::new(),\n            order: Vec::new(),\n        }\n    }\n\n    fn get(&amp;mut self, key: i32) -&gt; i32 {\n        if let Some(&amp;value) = self.cache.get(&amp;key) {\n            // Move the accessed key to the end of the order vector\n            self.order.retain(|&amp;k| k != key);\n            self.order.push(key);\n            return value;\n        }\n        -1 // Return -1 if key is not found\n    }\n\n    fn put(&amp;mut self, key: i32, value: i32) {\n        if self.cache.contains_key(&amp;key) {\n            // Key already exists, update value and move to end\n            self.cache.insert(key, value);\n            self.order.retain(|&amp;k| k != key);\n            self.order.push(key);\n        } else {\n            // If cache is full, remove the least recently used item\n            if self.cache.len() == self.capacity {\n                let lru_key = self.order.remove(0); // Remove the first element\n                self.cache.remove(&amp;lru_key);\n            }\n            self.cache.insert(key, value);\n            self.order.push(key);\n        }\n    }\n}\n\n// LinkedList-based LRU Cache\nstruct ListNode {\n    key: i32,\n    value: i32,\n    prev: Option&lt;Box&lt;ListNode&gt;&gt;,\n    next: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n\nstruct LRUCacheLinkedList {\n    capacity: usize,\n    cache: HashMap&lt;i32, Box&lt;ListNode&gt;&gt;,\n    head: Option&lt;Box&lt;ListNode&gt;&gt;,\n    tail: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n\nimpl LRUCacheLinkedList {\n    fn new(capacity: usize) -&gt; Self {\n        let head = Box::new(ListNode { key: 0, value: 0, prev: None, next: None });\n        let tail = Box::new(ListNode { key: 0, value: 0, prev: Some(head.clone()), next: None });\n\n        LRUCacheLinkedList {\n            capacity,\n            cache: HashMap::new(),\n            head: Some(head),\n            tail: Some(tail),\n        }\n    }\n\n    fn remove(&amp;mut self, node: &amp;Box&lt;ListNode&gt;) {\n        if let Some(ref mut head) = self.head {\n            if let Some(ref mut tail) = self.tail {\n                if let Some(ref mut prev) = node.prev {\n                    prev.next = node.next.clone();\n                }\n                if let Some(ref mut next) = node.next {\n                    next.prev = node.prev.clone();\n                }\n            }\n        }\n        self.cache.remove(&amp;node.key);\n    }\n\n    fn add_to_end(&amp;mut self, node: Box&lt;ListNode&gt;) {\n        if let Some(ref mut tail) = self.tail {\n            let mut last = tail.prev.take().unwrap();\n            last.next = Some(node.clone());\n            last.next.as_mut().unwrap().prev = Some(last);\n            tail.prev = Some(node);\n        }\n    }\n\n    fn get(&amp;mut self, key: i32) -&gt; i32 {\n        if let Some(node) = self.cache.get(&amp;key) {\n            self.remove(node);\n            self.add_to_end(node.clone());\n            return node.value;\n        }\n        -1 // Return -1 if key is not found\n    }\n\n    fn put(&amp;mut self, key: i32, value: i32) {\n        if let Some(node) = self.cache.get(&amp;key) {\n            self.remove(node);\n        } else if self.cache.len() == self.capacity {\n            // Evict the least recently used node\n            if let Some(ref mut head) = self.head {\n                if let Some(ref mut first) = head.next {\n                    self.remove(first);\n                }\n            }\n        }\n\n        let new_node = Box::new(ListNode {\n            key,\n            value,\n            prev: None,\n            next: None,\n        });\n        self.cache.insert(key, new_node.clone());\n        self.add_to_end(new_node);\n    }\n}\n\nfn main() {\n    // Testing OrderedDict-based LRUCache\n    println!(\"Testing LRUCacheOrdered:\");\n    let mut lru_ordered = LRUCacheOrdered::new(2);\n    lru_ordered.put(1, 1);\n    lru_ordered.put(2, 2);\n    println!(\"{}\", lru_ordered.get(1)); // prints 1\n    lru_ordered.put(3, 3); // evicts key 2\n    println!(\"{}\", lru_ordered.get(2)); // prints -1\n\n    // Testing LinkedList-based LRUCache\n    println!(\"\\nTesting LRUCacheLinkedList:\");\n    let mut lru_linked = LRUCacheLinkedList::new(2);\n    lru_linked.put(1, 1);\n    lru_linked.put(2, 2);\n    println!(\"{}\", lru_linked.get(1)); // prints 1\n    lru_linked.put(3, 3); // evicts key 2\n    println!(\"{}\", lru_linked.get(2)); // prints -1\n}\n</code></pre> <pre><code>using System;\nusing System.Collections.Generic;\n\n// OrderedDict-based LRU Cache\npublic class LRUCacheOrdered {\n    private int capacity;\n    private LinkedList&lt;(int key, int value)&gt; cacheList = new LinkedList&lt;(int, int)&gt;();\n    private Dictionary&lt;int, LinkedListNode&lt;(int key, int value)&gt;&gt; cacheMap = new Dictionary&lt;int, LinkedListNode&lt;(int, int)&gt;&gt;();\n\n    public LRUCacheOrdered(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public int Get(int key) {\n        if (!cacheMap.ContainsKey(key)) return -1;\n        var node = cacheMap[key];\n        cacheList.Remove(node);\n        cacheList.AddFirst(node);\n        return node.Value.value;\n    }\n\n    public void Put(int key, int value) {\n        if (cacheMap.ContainsKey(key)) cacheList.Remove(cacheMap[key]);\n        else if (cacheList.Count == capacity) {\n            cacheMap.Remove(cacheList.Last.Value.key);\n            cacheList.RemoveLast();\n        }\n        var newNode = new LinkedListNode&lt;(int key, int value)&gt;((key, value));\n        cacheList.AddFirst(newNode);\n        cacheMap[key] = newNode;\n    }\n}\n\n// LinkedList-based LRU Cache\npublic class ListNode {\n    public int Key, Value;\n    public ListNode Next, Prev;\n    public ListNode(int key, int value) { Key = key; Value = value; }\n}\n\npublic class LRUCacheLinkedList {\n    private int capacity;\n    private Dictionary&lt;int, ListNode&gt; cacheMap = new Dictionary&lt;int, ListNode&gt;();\n    private ListNode head = null, tail = null;\n\n    public LRUCacheLinkedList(int capacity) {\n        this.capacity = capacity;\n    }\n\n    private void RemoveNode(ListNode node) {\n        if (node.Prev != null) node.Prev.Next = node.Next;\n        else head = node.Next;\n        if (node.Next != null) node.Next.Prev = node.Prev;\n        else tail = node.Prev;\n    }\n\n    private void InsertAtEnd(ListNode node) {\n        if (tail != null) tail.Next = node;\n        node.Prev = tail;\n        node.Next = null;\n        tail = node;\n        if (head == null) head = node;\n    }\n\n    public int Get(int key) {\n        if (!cacheMap.ContainsKey(key)) return -1;\n        var node = cacheMap[key];\n        RemoveNode(node);\n        InsertAtEnd(node);\n        return node.Value;\n    }\n\n    public void Put(int key, int value) {\n        if (cacheMap.ContainsKey(key)) RemoveNode(cacheMap[key]);\n        else if (cacheMap.Count == capacity) {\n            cacheMap.Remove(head.Key);\n            RemoveNode(head);\n        }\n        var newNode = new ListNode(key, value);\n        InsertAtEnd(newNode);\n        cacheMap[key] = newNode;\n    }\n}\n\npublic class Program {\n    public static void Main() {\n        Console.WriteLine(\"Testing LRUCacheOrdered:\");\n        var lruOrdered = new LRUCacheOrdered(2);\n        lruOrdered.Put(1, 1);\n        lruOrdered.Put(2, 2);\n        Console.WriteLine(lruOrdered.Get(1));  // prints 1\n        lruOrdered.Put(3, 3);                  // evicts key 2\n        Console.WriteLine(lruOrdered.Get(2));  // prints -1 (not found)\n\n        Console.WriteLine(\"\\nTesting LRUCacheLinkedList:\");\n        var lruLinked = new LRUCacheLinkedList(2);\n        lruLinked.Put(1, 1);\n        lruLinked.Put(2, 2);\n        Console.WriteLine(lruLinked.Get(1));   // prints 1\n        lruLinked.Put(3, 3);                   // evicts key 2\n        Console.WriteLine(lruLinked.Get(2));   // prints -1 (not found)\n    }\n}\n</code></pre> <pre><code>import java.util.*;\n\n// OrderedDict-based LRU Cache\nclass LRUCacheOrdered extends LinkedHashMap&lt;Integer, Integer&gt; {\n    private int capacity;\n\n    public LRUCacheOrdered(int capacity) {\n        super(capacity, 0.75f, true);\n        this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) {\n        return size() &gt; capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n}\n\n// LinkedList-based LRU Cache\nclass ListNode {\n    int key, value;\n    ListNode prev, next;\n\n    ListNode(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass LRUCacheLinkedList {\n    private int capacity;\n    private Map&lt;Integer, ListNode&gt; cacheMap;\n    private ListNode head, tail;\n\n    public LRUCacheLinkedList(int capacity) {\n        this.capacity = capacity;\n        this.cacheMap = new HashMap&lt;&gt;();\n    }\n\n    private void removeNode(ListNode node) {\n        if (node.prev != null) node.prev.next = node.next;\n        else head = node.next;\n        if (node.next != null) node.next.prev = node.prev;\n        else tail = node.prev;\n    }\n\n    private void insertAtEnd(ListNode node) {\n        if (tail != null) tail.next = node;\n        node.prev = tail;\n        tail = node;\n        if (head == null) head = node;\n    }\n\n    public int get(int key) {\n        if (!cacheMap.containsKey(key)) return -1;\n        ListNode node = cacheMap.get(key);\n        removeNode(node);\n        insertAtEnd(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (cacheMap.containsKey(key)) removeNode(cacheMap.get(key));\n        else if (cacheMap.size() == capacity) {\n            cacheMap.remove(head.key);\n            removeNode(head);\n        }\n        ListNode newNode = new ListNode(key, value);\n        insertAtEnd(newNode);\n        cacheMap.put(key, newNode);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Testing LRUCacheOrdered:\");\n        LRUCacheOrdered lruOrdered = new LRUCacheOrdered(2);\n        lruOrdered.put(1, 1);\n        lruOrdered.put(2, 2);\n        System.out.println(lruOrdered.get(1));  // prints 1\n        lruOrdered.put(3, 3);                  // evicts key 2\n        System.out.println(lruOrdered.get(2));  // prints -1 (not found)\n\n        System.out.println(\"\\nTesting LRUCacheLinkedList:\");\n        LRUCacheLinkedList lruLinked = new LRUCacheLinkedList(2);\n        lruLinked.put(1, 1);\n        lruLinked.put(2, 2);\n        System.out.println(lruLinked.get(1));   // prints 1\n        lruLinked.put(3, 3);                   // evicts key 2\n        System.out.println(lruLinked.get(2));   // prints -1 (not found)\n    }\n}\n</code></pre> <pre><code>import scala.collection.mutable\n\n// OrderedDict-based LRU Cache using LinkedHashMap\nclass LRUCacheOrdered(capacity: Int) extends mutable.LinkedHashMap[Int, Int] {\n    override def removeEldestEntry(eldest: mutable.LinkedHashMap.Entry[Int, Int]): Boolean = {\n        size &gt; capacity\n    }\n\n    def get(key: Int): Int = {\n        this.getOrElseUpdate(key, -1)\n    }\n\n    def put(key: Int, value: Int): Unit = {\n        this.update(key, value)\n    }\n}\n\n// LinkedList-based LRU Cache\nclass ListNode(val key: Int, var value: Int) {\n    var prev: ListNode = _\n    var next: ListNode = _\n}\n\nclass LRUCacheLinkedList(capacity: Int) {\n    private val cacheMap = mutable.Map[Int, ListNode]()\n    private val dummyHead = new ListNode(0, 0)\n    private val dummyTail = new ListNode(0, 0)\n    dummyHead.next = dummyTail\n    dummyTail.prev = dummyHead\n\n    private def removeNode(node: ListNode): Unit = {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    }\n\n    private def addNodeToTail(node: ListNode): Unit = {\n        node.prev = dummyTail.prev\n        node.next = dummyTail\n        dummyTail.prev.next = node\n        dummyTail.prev = node\n    }\n\n    def get(key: Int): Int = {\n        cacheMap.get(key) match {\n            case Some(node) =&gt;\n                removeNode(node)\n                addNodeToTail(node)\n                node.value\n            case None =&gt; -1\n        }\n    }\n\n    def put(key: Int, value: Int): Unit = {\n        cacheMap.get(key).foreach(removeNode)\n        if (cacheMap.size == capacity) {\n            val headNext = dummyHead.next\n            cacheMap.remove(headNext.key)\n            removeNode(headNext)\n        }\n        val newNode = new ListNode(key, value)\n        cacheMap.put(key, newNode)\n        addNodeToTail(newNode)\n    }\n}\n\nobject Main extends App {\n    println(\"Testing LRUCacheOrdered:\")\n    val lruOrdered = new LRUCacheOrdered(2)\n    lruOrdered.put(1, 1)\n    lruOrdered.put(2, 2)\n    println(lruOrdered.get(1))  // prints 1\n    lruOrdered.put(3, 3)        // evicts key 2\n    println(lruOrdered.get(2))  // prints -1 (not found)\n\n    println(\"\\nTesting LRUCacheLinkedList:\")\n    val lruLinked = new LRUCacheLinkedList(2)\n    lruLinked.put(1, 1)\n    lruLinked.put(2, 2)\n    println(lruLinked.get(1))   // prints 1\n    lruLinked.put(3, 3)         // evicts key 2\n    println(lruLinked.get(2))   // prints -1 (not found)\n}\n</code></pre> <pre><code>// OrderedDict-based LRU Cache using LinkedHashMap\nclass LRUCacheOrdered(private val capacity: Int) : LinkedHashMap&lt;Int, Int&gt;(capacity, 0.75f, true) {\n    override fun removeEldestEntry(eldest: MutableMap.MutableEntry&lt;Int, Int&gt;): Boolean {\n        return size &gt; capacity\n    }\n\n    fun get(key: Int): Int {\n        return super.getOrDefault(key, -1)\n    }\n\n    fun put(key: Int, value: Int) {\n        super.put(key, value)\n    }\n}\n\n// LinkedList-based LRU Cache\nclass ListNode(val key: Int, var value: Int) {\n    var prev: ListNode? = null\n    var next: ListNode? = null\n}\n\nclass LRUCacheLinkedList(private val capacity: Int) {\n    private val cacheMap = mutableMapOf&lt;Int, ListNode&gt;()\n    private val head = ListNode(0, 0)\n    private val tail = ListNode(0, 0)\n\n    init {\n        head.next = tail\n        tail.prev = head\n    }\n\n    private fun removeNode(node: ListNode) {\n        node.prev?.next = node.next\n        node.next?.prev = node.prev\n    }\n\n    private fun addNodeToTail(node: ListNode) {\n        node.prev = tail.prev\n        node.next = tail\n        tail.prev?.next = node\n        tail.prev = node\n    }\n\n    fun get(key: Int): Int {\n        return cacheMap[key]?.let {\n            removeNode(it)\n            addNodeToTail(it)\n            it.value\n        } ?: -1\n    }\n\n    fun put(key: Int, value: Int) {\n        cacheMap[key]?.let {\n            removeNode(it)\n        } ?: if (cacheMap.size == capacity) {\n            head.next?.let {\n                cacheMap.remove(it.key)\n                removeNode(it)\n            }\n        }\n        val newNode = ListNode(key, value)\n        cacheMap[key] = newNode\n        addNodeToTail(newNode)\n    }\n}\n\nfun main() {\n    println(\"Testing LRUCacheOrdered:\")\n    val lruOrdered = LRUCacheOrdered(2)\n    lruOrdered.put(1, 1)\n    lruOrdered.put(2, 2)\n    println(lruOrdered.get(1))  // prints 1\n    lruOrdered.put(3, 3)        // evicts key 2\n    println(lruOrdered.get(2))  // prints -1 (not found)\n\n    println(\"\\nTesting LRUCacheLinkedList:\")\n    val lruLinked = LRUCacheLinkedList(2)\n    lruLinked.put(1, 1)\n    lruLinked.put(2, 2)\n    println(lruLinked.get(1))   // prints 1\n    lruLinked.put(3, 3)         // evicts key 2\n    println(lruLinked.get(2))   // prints -1 (not found)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// OrderedDict-based LRU Cache using container/list and map\ntype LRUCacheOrdered struct {\n    capacity int\n    cache    map[int]*list.Element\n    order    *list.List\n}\n\ntype KeyValuePair struct {\n    key, value int\n}\n\nfunc NewLRUCacheOrdered(capacity int) *LRUCacheOrdered {\n    return &amp;LRUCacheOrdered{\n        capacity: capacity,\n        cache:    make(map[int]*list.Element),\n        order:    list.New(),\n    }\n}\n\nfunc (lru *LRUCacheOrdered) Get(key int) int {\n    if elem, found := lru.cache[key]; found {\n        lru.order.MoveToFront(elem)\n        return elem.Value.(*KeyValuePair).value\n    }\n    return -1\n}\n\nfunc (lru *LRUCacheOrdered) Put(key, value int) {\n    if elem, found := lru.cache[key]; found {\n        lru.order.MoveToFront(elem)\n        elem.Value.(*KeyValuePair).value = value\n    } else {\n        if lru.order.Len() == lru.capacity {\n            backElem := lru.order.Back()\n            delete(lru.cache, backElem.Value.(*KeyValuePair).key)\n            lru.order.Remove(backElem)\n        }\n        elem := lru.order.PushFront(&amp;KeyValuePair{key, value})\n        lru.cache[key] = elem\n    }\n}\n\n// LinkedList-based LRU Cache\ntype ListNode struct {\n    key, value int\n    prev, next *ListNode\n}\n\ntype LRUCacheLinkedList struct {\n    capacity int\n    cache    map[int]*ListNode\n    head, tail *ListNode\n}\n\nfunc NewLRUCacheLinkedList(capacity int) *LRUCacheLinkedList {\n    head := &amp;ListNode{}\n    tail := &amp;ListNode{}\n    head.next = tail\n    tail.prev = head\n    return &amp;LRUCacheLinkedList{\n        capacity: capacity,\n        cache:    make(map[int]*ListNode),\n        head:     head,\n        tail:     tail,\n    }\n}\n\nfunc (lru *LRUCacheLinkedList) Get(key int) int {\n    if node, found := lru.cache[key]; found {\n        lru.remove(node)\n        lru.addToEnd(node)\n        return node.value\n    }\n    return -1\n}\n\nfunc (lru *LRUCacheLinkedList) Put(key, value int) {\n    if node, found := lru.cache[key]; found {\n        lru.remove(node)\n    } else if len(lru.cache) == lru.capacity {\n        frontNode := lru.head.next\n        lru.remove(frontNode)\n        delete(lru.cache, frontNode.key)\n    }\n    newNode := &amp;ListNode{key: key, value: value}\n    lru.addToEnd(newNode)\n    lru.cache[key] = newNode\n}\n\nfunc (lru *LRUCacheLinkedList) remove(node *ListNode) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n}\n\nfunc (lru *LRUCacheLinkedList) addToEnd(node *ListNode) {\n    node.prev = lru.tail.prev\n    node.next = lru.tail\n    lru.tail.prev.next = node\n    lru.tail.prev = node\n}\n\nfunc main() {\n    fmt.Println(\"Testing LRUCacheOrdered:\")\n    lruOrdered := NewLRUCacheOrdered(2)\n    lruOrdered.Put(1, 1)\n    lruOrdered.Put(2, 2)\n    fmt.Println(lruOrdered.Get(1)) // prints 1\n    lruOrdered.Put(3, 3)           // evicts key 2\n    fmt.Println(lruOrdered.Get(2))  // prints -1 (not found)\n\n    fmt.Println(\"\\nTesting LRUCacheLinkedList:\")\n    lruLinked := NewLRUCacheLinkedList(2)\n    lruLinked.Put(1, 1)\n    lruLinked.Put(2, 2)\n    fmt.Println(lruLinked.Get(1)) // prints 1\n    lruLinked.Put(3, 3)           // evicts key 2\n    fmt.Println(lruLinked.Get(2))  // prints -1 (not found)\n}\n</code></pre> <pre><code>// OrderedDict-based LRU Cache using Map\nclass LRUCacheOrdered {\n    private cache: Map&lt;number, number&gt;;\n    private capacity: number;\n\n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n\n    get(key: number): number {\n        if (!this.cache.has(key)) return -1;\n        const value = this.cache.get(key)!;\n        this.cache.delete(key);  // Remove and re-insert to refresh order\n        this.cache.set(key, value);\n        return value;\n    }\n\n    put(key: number, value: number): void {\n        if (this.cache.has(key)) this.cache.delete(key);\n        this.cache.set(key, value);\n        if (this.cache.size &gt; this.capacity) {\n            const oldestKey = this.cache.keys().next().value;\n            this.cache.delete(oldestKey);\n        }\n    }\n}\n\n// LinkedList-based LRU Cache\nclass ListNode {\n    key: number;\n    value: number;\n    prev: ListNode | null = null;\n    next: ListNode | null = null;\n\n    constructor(key: number, value: number) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass LRUCacheLinkedList {\n    private capacity: number;\n    private cache: Map&lt;number, ListNode&gt;;\n    private head: ListNode;\n    private tail: ListNode;\n\n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map();\n        this.head = new ListNode(0, 0);\n        this.tail = new ListNode(0, 0);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n\n    private remove(node: ListNode): void {\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n    }\n\n    private addToEnd(node: ListNode): void {\n        node.prev = this.tail.prev;\n        node.next = this.tail;\n        this.tail.prev!.next = node;\n        this.tail.prev = node;\n    }\n\n    get(key: number): number {\n        const node = this.cache.get(key);\n        if (!node) return -1;\n        this.remove(node);\n        this.addToEnd(node);\n        return node.value;\n    }\n\n    put(key: number, value: number): void {\n        if (this.cache.has(key)) this.remove(this.cache.get(key)!);\n        else if (this.cache.size === this.capacity) {\n            const lruNode = this.head.next!;\n            this.cache.delete(lruNode.key);\n            this.remove(lruNode);\n        }\n        const newNode = new ListNode(key, value);\n        this.cache.set(key, newNode);\n        this.addToEnd(newNode);\n    }\n}\n\n// Testing\nconsole.log(\"Testing LRUCacheOrdered:\");\nconst lruOrdered = new LRUCacheOrdered(2);\nlruOrdered.put(1, 1);\nlruOrdered.put(2, 2);\nconsole.log(lruOrdered.get(1));  // 1\nlruOrdered.put(3, 3);           // evicts key 2\nconsole.log(lruOrdered.get(2));  // -1\n\nconsole.log(\"\\nTesting LRUCacheLinkedList:\");\nconst lruLinked = new LRUCacheLinkedList(2);\nlruLinked.put(1, 1);\nlruLinked.put(2, 2);\nconsole.log(lruLinked.get(1));   // 1\nlruLinked.put(3, 3);             // evicts key 2\nconsole.log(lruLinked.get(2));   // -1\n</code></pre> <pre><code># OrderedDict-based LRU Cache using environment\nLRUCacheOrdered &lt;- function(capacity) {\n    cache &lt;- new.env(hash = TRUE)\n    keys &lt;- character(0)\n\n    get &lt;- function(key) {\n        if (exists(as.character(key), envir = cache)) {\n        value &lt;- get(as.character(key), envir = cache)\n        keys &lt;&lt;- c(setdiff(keys, key), key)  # Move key to end\n        return(value)\n        }\n        return(-1)\n    }\n\n    put &lt;- function(key, value) {\n        key &lt;- as.character(key)\n        if (exists(key, envir = cache)) {\n        keys &lt;&lt;- setdiff(keys, key)\n        }\n        assign(key, value, envir = cache)\n        keys &lt;&lt;- c(keys, key)\n        if (length(keys) &gt; capacity) {\n        remove(list = keys[1], envir = cache)\n        keys &lt;&lt;- keys[-1]\n        }\n    }\n\n    list(get = get, put = put)\n}\n\n# LinkedList-based LRU Cache using lists\nLRUCacheLinkedList &lt;- function(capacity) {\n    cache &lt;- list()\n    head &lt;- list(key = NULL, value = NULL, prev = NULL, next = NULL)\n    tail &lt;- list(key = NULL, value = NULL, prev = head, next = NULL)\n    head$next &lt;- tail\n\n    get &lt;- function(key) {\n        if (!is.null(cache[[as.character(key)]])) {\n        node &lt;- cache[[as.character(key)]]\n        removeNode(node)\n        addToEnd(node)\n        return(node$value)\n        }\n        return(-1)\n    }\n\n    put &lt;- function(key, value) {\n        if (!is.null(cache[[as.character(key)]])) {\n        removeNode(cache[[as.character(key)]])\n        } else if (length(cache) == capacity) {\n        removeHead()\n        }\n        newNode &lt;- list(key = key, value = value, prev = NULL, next = NULL)\n        cache[[as.character(key)]] &lt;&lt;- newNode\n        addToEnd(newNode)\n    }\n\n    removeNode &lt;- function(node) {\n        node$prev$next &lt;- node$next\n        node$next$prev &lt;- node$prev\n        cache[[as.character(node$key)]] &lt;&lt;- NULL\n    }\n\n    addToEnd &lt;- function(node) {\n        node$prev &lt;- tail$prev\n        node$next &lt;- tail\n        tail$prev$next &lt;- node\n        tail$prev &lt;- node\n    }\n\n    removeHead &lt;- function() {\n        node &lt;- head$next\n        removeNode(node)\n    }\n\n    list(get = get, put = put)\n}\n\n# Testing\ncat(\"Testing LRUCacheOrdered:\\n\")\nlruOrdered &lt;- LRUCacheOrdered(2)\nlruOrdered$put(1, 1)\nlruOrdered$put(2, 2)\ncat(lruOrdered$get(1), \"\\n\")  # prints 1\nlruOrdered$put(3, 3)          # evicts key 2\ncat(lruOrdered$get(2), \"\\n\")  # prints -1\n\ncat(\"\\nTesting LRUCacheLinkedList:\\n\")\nlruLinked &lt;- LRUCacheLinkedList(2)\nlruLinked$put(1, 1)\nlruLinked$put(2, 2)\ncat(lruLinked$get(1), \"\\n\")   # prints 1\nlruLinked$put(3, 3)           # evicts key 2\ncat(lruLinked$get(2), \"\\n\")   # prints -1\n</code></pre> <pre><code>using DataStructures\n\n# OrderedDict-based LRU Cache\nstruct LRUCacheOrdered\n    capacity::Int\n    cache::OrderedDict{Int, Int}\n\n    function LRUCacheOrdered(capacity::Int)\n        new(capacity, OrderedDict{Int, Int}())\n    end\nend\n\nfunction get(cache::LRUCacheOrdered, key::Int)\n    if haskey(cache.cache, key)\n        value = cache.cache[key]\n        delete!(cache.cache, key)\n        cache.cache[key] = value\n        return value\n    end\n    return -1\nend\n\nfunction put(cache::LRUCacheOrdered, key::Int, value::Int)\n    if haskey(cache.cache, key)\n        delete!(cache.cache, key)\n    end\n    cache.cache[key] = value\n    if length(cache.cache) &gt; cache.capacity\n        popfirst!(cache.cache)\n    end\nend\n\n# Testing OrderedDict-based LRUCache\nprintln(\"Testing LRUCacheOrdered:\")\nlruOrdered = LRUCacheOrdered(2)\nput(lruOrdered, 1, 1)\nput(lruOrdered, 2, 2)\nprintln(get(lruOrdered, 1))  # prints 1\nput(lruOrdered, 3, 3)        # evicts key 2\nprintln(get(lruOrdered, 2))  # prints -1\n\n# Julia does not natively support complex custom LinkedList structures as easily as other languages\n# For brevity, `OrderedDict` approach is typically preferred in Julia for LRUCache\n</code></pre>","tags":["Original"]},{"location":"design/001_Design/#design-circular-queue","title":"Design Circular Queue","text":"","tags":["Original"]},{"location":"design/001_Design/#problem-description-leetcode-problem-622-design-circular-queue","title":"Problem Description: LeetCode - Problem 622 - Design Circular Queue","text":"<p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"design/001_Design/#problem-description_1","title":"Problem Description:","text":"<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".</p> <p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p> <p>Implement the <code>MyCircularQueue</code> class:</p> <ul> <li><code>MyCircularQueue(k)</code> Initializes the object with the size of the queue to be <code>k</code>.</li> <li><code>int Front()</code> Gets the front item from the queue. If the queue is empty, return <code>-1</code>.</li> <li><code>int Rear()</code> Gets the last item from the queue. If the queue is empty, return <code>-1</code>.</li> <li><code>boolean enQueue(int value)</code> Inserts an element into the circular queue. Return <code>true</code> if the operation is successful.</li> <li><code>boolean deQueue()</code> Deletes an element from the circular queue. Return <code>true</code> if the operation is successful.</li> <li><code>boolean isEmpty()</code> Checks whether the circular queue is empty or not.</li> <li><code>boolean isFull()</code> Checks whether the circular queue is full or not.</li> </ul> <p>You must solve the problem without using the built-in queue data structure in your programming language. </p> <p>Bonus: Can you provide the in-place merge, improved space complexity solution.</p> <p>Tip</p> <p>Python solution is the easiest to understand so always start with that.</p>","tags":["Original"]},{"location":"design/001_Design/#solution-explanation_1","title":"Solution Explanation","text":"<p>Here's a detailed explanation of the provided circular queue solution, along with the time and space complexity analysis.</p> <ol> <li>Class Structure:</li> <li>The <code>MyCircularQueue</code> class implements a circular queue data structure using an array (list in Python). </li> <li> <p>It maintains three key attributes:</p> <ul> <li><code>__start</code>: An integer that tracks the index of the front element in the queue.</li> <li><code>__size</code>: An integer that keeps track of the number of elements currently in the queue.</li> <li><code>__buffer</code>: A list of integers that serves as the underlying storage for the queue, initialized to the specified capacity <code>k</code>.</li> </ul> </li> <li> <p>Initialization (<code>__init__</code> method):</p> </li> <li>The constructor takes an integer <code>k</code> as an argument, representing the maximum size of the queue. </li> <li> <p>It initializes the internal variables:</p> <ul> <li><code>__start</code> to 0 (indicating the front of the queue).</li> <li><code>__size</code> to 0 (indicating that the queue is initially empty).</li> <li><code>__buffer</code> to a list of zeros of size <code>k</code>.</li> </ul> </li> <li> <p>Enqueue (<code>enQueue</code> method):</p> </li> <li> <p>This method inserts an element at the rear of the queue:</p> <ul> <li>It first checks if the queue is full by calling <code>isFull()</code>. If the queue is full, it returns <code>False</code>.</li> <li>If not full, it calculates the position to insert the new value using the formula <code>(__start + __size) % len(__buffer)</code>, which wraps around if necessary.</li> <li>The element is added to the calculated position, and <code>__size</code> is incremented by 1.</li> <li>Finally, it returns <code>True</code> to indicate that the operation was successful.</li> </ul> </li> <li> <p>Dequeue (<code>deQueue</code> method):</p> </li> <li> <p>This method removes an element from the front of the queue:</p> <ul> <li>It checks if the queue is empty by calling <code>isEmpty()</code>. If empty, it returns <code>False</code>.</li> <li>If not empty, it updates <code>__start</code> to point to the next element in the queue using the formula <code>(__start + 1)</code>__ % len(__buffer)`, wrapping around if necessary.</li> <li><code>__size</code> is decremented by 1 to reflect the removal of the element.</li> <li>It returns <code>True</code> to indicate that the operation was successful.</li> </ul> </li> <li> <p>Front (<code>Front</code> method):</p> </li> <li> <p>This method returns the front element of the queue:</p> <ul> <li>If the queue is empty (checked using <code>isEmpty()</code>), it returns -1.</li> <li>Otherwise, it returns the element at the <code>__start</code> index in <code>__buffer</code>.</li> </ul> </li> <li> <p>Rear (<code>Rear</code> method):</p> </li> <li> <p>This method returns the last element of the queue:</p> <ul> <li>If the queue is empty, it returns -1.</li> <li>Otherwise, it calculates the position of the last element using <code>(__start + __size - 1)</code>__ % len(__buffer)` and returns that element.</li> </ul> </li> <li> <p>isEmpty (<code>isEmpty</code> method):</p> </li> <li> <p>This method checks if the queue is empty by comparing <code>__size</code> to 0. It returns <code>True</code> if empty, otherwise <code>False</code>.</p> </li> <li> <p>isFull (<code>isFull</code> method):</p> </li> <li>This method checks if the queue is full by comparing <code>__size</code> to the length of <code>__buffer</code>. It returns <code>True</code> if full, otherwise <code>False</code>.</li> </ol>","tags":["Original"]},{"location":"design/001_Design/#complexity-analysis_1","title":"Complexity Analysis","text":"<ol> <li>Time Complexity:</li> <li>Initialization: <ul> <li>The <code>__init__</code> method runs in <code>O(k)</code> time due to the creation of the buffer list of size <code>k</code>. </li> </ul> </li> <li>Enqueue (<code>enQueue</code>): <ul> <li>The method runs in <code>O(1)</code> time because it performs a constant number of operations: checking if full, calculating the position, and inserting the element.</li> </ul> </li> <li>Dequeue (<code>deQueue</code>): <ul> <li>The method also runs in <code>O(1)</code> time for similar reasons: checking if empty, updating the start position, and decrementing the size.</li> </ul> </li> <li>Front (<code>Front</code>): <ul> <li>This method runs in <code>O(1)</code> time as it accesses the element directly.</li> </ul> </li> <li>Rear (<code>Rear</code>): <ul> <li>This method runs in <code>O(1)</code> time as it accesses the element directly.</li> </ul> </li> <li>isEmpty: <ul> <li>This method runs in <code>O(1)</code> time as it performs a simple comparison.</li> </ul> </li> <li> <p>isFull: </p> <ul> <li>This method runs in <code>O(1)</code> time as it performs a simple comparison.</li> </ul> </li> <li> <p>Space Complexity:</p> </li> <li>The space complexity of the circular queue is <code>O(k)</code> due to the storage in <code>__buffer</code>, where <code>k</code> is the capacity of the queue. </li> <li>Other variables (<code>__start</code>, <code>__size</code>) consume <code>O(1)</code> space, but they do not scale with the input size.</li> </ol>","tags":["Original"]},{"location":"design/001_Design/#summary_1","title":"Summary","text":"<p>The overall complexity for the circular queue operations (enqueue, dequeue, and access) is very efficient, with constant time complexity <code>O(1)</code> for each operation and linear space complexity <code>O(k)</code> for the buffer, making this implementation well-suited for scenarios requiring a fixed-size queue with efficient insertions and deletions.</p>","tags":["Original"]},{"location":"design/001_Design/#solutions_1","title":"Solutions","text":"PythonC++RustC#JavaScalaKotlinGoTypeScriptRJulia <pre><code>class MyCircularQueue:\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        :param k: int\n        \"\"\"\n        self.__start: int = 0\n        self.__size: int = 0\n        self.__buffer: list[int] = [0] * k\n\n    def enQueue(self, value: int) -&gt; bool:\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        :param value: int\n        :return: bool\n        \"\"\"\n        if self.isFull():\n            return False\n        self.__buffer[(self.__start + self.__size) % len(self.__buffer)] = value\n        self.__size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        :return: bool\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.__start = (self.__start + 1)`__ % len(self.__buffer)\n        self.__size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        \"\"\"\n        Get the front item from the queue.\n        :return: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[self.__start]\n\n    def Rear(self) -&gt; int:\n        \"\"\"\n        Get the last item from the queue.\n        :return: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[(self.__start + self.__size - 1)`__ % len(self.__buffer)]\n\n    def isEmpty(self) -&gt; bool:\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        :return: bool\n        \"\"\"\n        return self.__size == 0\n\n    def isFull(self) -&gt; bool:\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        :return: bool\n        \"\"\"\n        return self.__size == len(self.__buffer)\n\ndef main() -&gt; None:\n    # Create a circular queue of capacity 3\n    circular_queue = MyCircularQueue(3)\n\n    print(circular_queue.enQueue(1))  # returns True\n    print(circular_queue.enQueue(2))  # returns True\n    print(circular_queue.enQueue(3))  # returns True\n    print(circular_queue.enQueue(4))  # returns False, the queue is full\n\n    print(circular_queue.Rear())       # returns 3\n    print(circular_queue.isFull())     # returns True\n\n    print(circular_queue.deQueue())    # returns True\n    print(circular_queue.enQueue(4))   # returns True\n\n    print(circular_queue.Rear())       # returns 4\n\n    print(circular_queue.Front())      # returns 2\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass MyCircularQueue {\nprivate:\n    int start;\n    int size;\n    std::vector&lt;int&gt; buffer;\n\npublic:\n    MyCircularQueue(int k) : start(0), size(0), buffer(k, 0) {}\n\n    bool enQueue(int value) {\n        if (isFull()) return false;\n        buffer[(start + size) % buffer.size()] = value;\n        size++;\n        return true;\n    }\n\n    bool deQueue() {\n        if (isEmpty()) return false;\n        start = (start + 1)`__ % buffer.size();\n        size--;\n        return true;\n    }\n\n    int Front() {\n        return isEmpty() ? -1 : buffer[start];\n    }\n\n    int Rear() {\n        return isEmpty() ? -1 : buffer[(start + size - 1)`__ % buffer.size()];\n    }\n\n    bool isEmpty() {\n        return size == 0;\n    }\n\n    bool isFull() {\n        return size == buffer.size();\n    }\n};\n\nint main() {\n    MyCircularQueue circularQueue(3);\n\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; circularQueue.enQueue(1)`__ &lt;&lt; std::endl;  // returns true\n    std::cout &lt;&lt; circularQueue.enQueue(2) &lt;&lt; std::endl;  // returns true\n    std::cout &lt;&lt; circularQueue.enQueue(3) &lt;&lt; std::endl;  // returns true\n    std::cout &lt;&lt; circularQueue.enQueue(4) &lt;&lt; std::endl;  // returns false\n\n    std::cout &lt;&lt; circularQueue.Rear() &lt;&lt; std::endl;       // returns 3\n    std::cout &lt;&lt; circularQueue.isFull() &lt;&lt; std::endl;     // returns true\n\n    std::cout &lt;&lt; circularQueue.deQueue() &lt;&lt; std::endl;    // returns true\n    std::cout &lt;&lt; circularQueue.enQueue(4) &lt;&lt; std::endl;   // returns true\n\n    std::cout &lt;&lt; circularQueue.Rear() &lt;&lt; std::endl;       // returns 4\n    std::cout &lt;&lt; circularQueue.Front() &lt;&lt; std::endl;      // returns 2\n\n    return 0;\n}\n</code></pre> <pre><code>struct MyCircularQueue {\n    start: usize,\n    size: usize,\n    buffer: Vec&lt;i32&gt;,\n}\n\nimpl MyCircularQueue {\n    fn new(k: i32) -&gt; Self {\n        Self {\n            start: 0,\n            size: 0,\n            buffer: vec![0; k as usize],\n        }\n    }\n\n    fn en_queue(&amp;mut self, value: i32) -&gt; bool {\n        if self.is_full() {\n            return false;\n        }\n        self.buffer[(self.start + self.size) % self.buffer.len()] = value;\n        self.size += 1;\n        true\n    }\n\n    fn de_queue(&amp;mut self) -&gt; bool {\n        if self.is_empty() {\n            return false;\n        }\n        self.start = (self.start + 1)`__ % self.buffer.len();\n        self.size -= 1;\n        true\n    }\n\n    fn front(&amp;self) -&gt; i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            self.buffer[self.start]\n        }\n    }\n\n    fn rear(&amp;self) -&gt; i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            self.buffer[(self.start + self.size - 1)`__ % self.buffer.len()]\n        }\n    }\n\n    fn is_empty(&amp;self) -&gt; bool {\n        self.size == 0\n    }\n\n    fn is_full(&amp;self) -&gt; bool {\n        self.size == self.buffer.len()\n    }\n}\n\nfn main() {\n    let mut circular_queue = MyCircularQueue::new(3);\n\n    println!(\"{}\", circular_queue.en_queue(1));  // returns true\n    println!(\"{}\", circular_queue.en_queue(2));  // returns true\n    println!(\"{}\", circular_queue.en_queue(3));  // returns true\n    println!(\"{}\", circular_queue.en_queue(4));  // returns false\n\n    println!(\"{}\", circular_queue.rear());        // returns 3\n    println!(\"{}\", circular_queue.is_full());     // returns true\n\n    println!(\"{}\", circular_queue.de_queue());     // returns true\n    println!(\"{}\", circular_queue.en_queue(4));   // returns true\n\n    println!(\"{}\", circular_queue.rear());        // returns 4\n    println!(\"{}\", circular_queue.front());       // returns 2\n}\n</code></pre> <pre><code>using System;\n\npublic class MyCircularQueue {\n    private int start;\n    private int size;\n    private int[] buffer;\n\n    public MyCircularQueue(int k) {\n        start = 0;\n        size = 0;\n        buffer = new int[k];\n    }\n\n    public bool EnQueue(int value) {\n        if (IsFull()) return false;\n        buffer[(start + size) % buffer.Length] = value;\n        size++;\n        return true;\n    }\n\n    public bool DeQueue() {\n        if (IsEmpty()) return false;\n        start = (start + 1)`__ % buffer.Length;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        return IsEmpty() ? -1 : buffer[start];\n    }\n\n    public int Rear() {\n        return IsEmpty() ? -1 : buffer[(start + size - 1)`__ % buffer.Length];\n    }\n\n    public bool IsEmpty() {\n        return size == 0;\n    }\n\n    public bool IsFull() {\n        return size == buffer.Length;\n    }\n}\n\nclass Program {\n    static void Main(string[] args) {\n        MyCircularQueue circularQueue = new MyCircularQueue(3);\n\n        Console.WriteLine(circularQueue.EnQueue(1));  // returns true\n        Console.WriteLine(circularQueue.EnQueue(2));  // returns true\n        Console.WriteLine(circularQueue.EnQueue(3));  // returns true\n        Console.WriteLine(circularQueue.EnQueue(4));  // returns false\n\n        Console.WriteLine(circularQueue.Rear());      // returns 3\n        Console.WriteLine(circularQueue.IsFull());    // returns true\n\n        Console.WriteLine(circularQueue.DeQueue());   // returns true\n        Console.WriteLine(circularQueue.EnQueue(4));   // returns true\n\n        Console.WriteLine(circularQueue.Rear());      // returns 4\n        Console.WriteLine(circularQueue.Front());     // returns 2\n    }\n}\n</code></pre> <pre><code>class MyCircularQueue {\n    private int start;\n    private int size;\n    private int[] buffer;\n\n    public MyCircularQueue(int k) {\n        start = 0;\n        size = 0;\n        buffer = new int[k];\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) return false;\n        buffer[(start + size) % buffer.length] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) return false;\n        start = (start + 1)`__ % buffer.length;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        return isEmpty() ? -1 : buffer[start];\n    }\n\n    public int Rear() {\n        return isEmpty() ? -1 : buffer[(start + size - 1)`__ % buffer.length];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == buffer.length;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyCircularQueue circularQueue = new MyCircularQueue(3);\n\n        System.out.println(circularQueue.enQueue(1));  // returns true\n        System.out.println(circularQueue.enQueue(2));  // returns true\n        System.out.println(circularQueue.enQueue(3));  // returns true\n        System.out.println(circularQueue.enQueue(4));  // returns false\n\n        System.out.println(circularQueue.Rear());      // returns 3\n        System.out.println(circularQueue.isFull());    // returns true\n\n        System.out.println(circularQueue.deQueue());   // returns true\n        System.out.println(circularQueue.enQueue(4));   // returns true\n\n        System.out.println(circularQueue.Rear());      // returns 4\n        System.out.println(circularQueue.Front());     // returns 2\n    }\n}\n</code></pre> <pre><code>class MyCircularQueue(k: Int) {\n    private var start: Int = 0\n    private var size: Int = 0\n    private val buffer: Array[Int] = new Array[Int](k)\n\n    def enQueue(value: Int): Boolean = {\n        if (isFull()) return false\n        buffer((start + size) % buffer.length) = value\n        size += 1\n        true\n    }\n\n    def deQueue(): Boolean = {\n        if (isEmpty()) return false\n        start = (start + 1)`__ % buffer.length\n        size -= 1\n        true\n    }\n\n    def Front(): Int = {\n        if (isEmpty()) -1 else buffer(start)\n    }\n\n    def Rear(): Int = {\n        if (isEmpty()) -1 else buffer((start + size - 1)`__ % buffer.length)\n    }\n\n    def isEmpty(): Boolean = size == 0\n\n    def isFull(): Boolean = size == buffer.length\n}\n\nobject Main extends App {\n    val circularQueue = new MyCircularQueue(3)\n\n    println(circularQueue.enQueue(1))  // returns true\n    println(circularQueue.enQueue(2))  // returns true\n    println(circularQueue.enQueue(3))  // returns true\n    println(circularQueue.enQueue(4))  // returns false\n\n    println(circularQueue.Rear())       // returns 3\n    println(circularQueue.isFull())     // returns true\n\n    println(circularQueue.deQueue())    // returns true\n    println(circularQueue.enQueue(4))   // returns true\n\n    println(circularQueue.Rear())       // returns 4\n    println(circularQueue.Front())      // returns 2\n}\n</code></pre> <pre><code>class MyCircularQueue(k: Int) {\n    private var start = 0\n    private var size = 0\n    private val buffer: IntArray = IntArray(k)\n\n    fun enQueue(value: Int): Boolean {\n        if (isFull()) return false\n        buffer[(start + size) % buffer.size] = value\n        size++\n        return true\n    }\n\n    fun deQueue(): Boolean {\n        if (isEmpty()) return false\n        start = (start + 1)`__ % buffer.size\n        size--\n        return true\n    }\n\n    fun Front(): Int {\n        return if (isEmpty()) -1 else buffer[start]\n    }\n\n    fun Rear(): Int {\n        return if (isEmpty()) -1 else buffer[(start + size - 1)`__ % buffer.size]\n    }\n\n    fun isEmpty(): Boolean {\n        return size == 0\n    }\n\n    fun isFull(): Boolean {\n        return size == buffer.size\n    }\n}\n\nfun main() {\n    val circularQueue = MyCircularQueue(3)\n\n    println(circularQueue.enQueue(1))  // returns true\n    println(circularQueue.enQueue(2))  // returns true\n    println(circularQueue.enQueue(3))  // returns true\n    println(circularQueue.enQueue(4))  // returns false\n\n    println(circularQueue.Rear())       // returns 3\n    println(circularQueue.isFull())     // returns true\n\n    println(circularQueue.deQueue())    // returns true\n    println(circularQueue.enQueue(4))   // returns true\n\n    println(circularQueue.Rear())       // returns 4\n    println(circularQueue.Front())      // returns 2\n}\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype MyCircularQueue struct {\n    start  int\n    size   int\n    buffer []int\n}\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{\n        start:  0,\n        size:   0,\n        buffer: make([]int, k),\n    }\n}\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    if this.IsFull() {\n        return false\n    }\n    this.buffer[(this.start+this.size)%len(this.buffer)] = value\n    this.size++\n    return true\n}\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    if this.IsEmpty() {\n        return false\n    }\n    this.start = (this.start + 1)`__ % len(this.buffer)\n    this.size--\n    return true\n}\n\nfunc (this *MyCircularQueue) Front() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.buffer[this.start]\n}\n\nfunc (this *MyCircularQueue) Rear() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.buffer[(this.start+this.size-1)%len(this.buffer)]\n}\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    return this.size == 0\n}\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    return this.size == len(this.buffer)\n}\n\nfunc main() {\n    circularQueue := Constructor(3)\n\n    fmt.Println(circularQueue.EnQueue(1))  // returns true\n    fmt.Println(circularQueue.EnQueue(2))  // returns true\n    fmt.Println(circularQueue.EnQueue(3))  // returns true\n    fmt.Println(circularQueue.EnQueue(4))  // returns false\n\n    fmt.Println(circularQueue.Rear())       // returns 3\n    fmt.Println(circularQueue.IsFull())     // returns true\n\n    fmt.Println(circularQueue.DeQueue())    // returns true\n    fmt.Println(circularQueue.EnQueue(4))   // returns true\n\n    fmt.Println(circularQueue.Rear())       // returns 4\n    fmt.Println(circularQueue.Front())      // returns 2\n}\n</code></pre> <pre><code>class MyCircularQueue {\n    private start: number;\n    private size: number;\n    private buffer: number[];\n\n    constructor(k: number) {\n        this.start = 0;\n        this.size = 0;\n        this.buffer = new Array(k).fill(0);\n    }\n\n    enQueue(value: number): boolean {\n        if (this.isFull()) return false;\n        this.buffer[(this.start + this.size) % this.buffer.length] = value;\n        this.size++;\n        return true;\n    }\n\n    deQueue(): boolean {\n        if (this.isEmpty()) return false;\n        this.start = (this.start + 1)`__ % this.buffer.length;\n        this.size--;\n        return true;\n    }\n\n    Front(): number {\n        return this.isEmpty() ? -1 : this.buffer[this.start];\n    }\n\n    Rear(): number {\n        return this.isEmpty() ? -1 : this.buffer[(this.start + this.size - 1)`__ % this.buffer.length];\n    }\n\n    isEmpty(): boolean {\n        return this.size === 0;\n    }\n\n    isFull(): boolean {\n        return this.size === this.buffer.length;\n    }\n}\n\nconst main = () =&gt; {\n    const circularQueue = new MyCircularQueue(3);\n\n    console.log(circularQueue.enQueue(1));  // returns true\n    console.log(circularQueue.enQueue(2));  // returns true\n    console.log(circularQueue.enQueue(3));  // returns true\n    console.log(circularQueue.enQueue(4));  // returns false\n\n    console.log(circularQueue.Rear());       // returns 3\n    console.log(circularQueue.isFull());     // returns true\n\n    console.log(circularQueue.deQueue());    // returns true\n    console.log(circularQueue.enQueue(4));   // returns true\n\n    console.log(circularQueue.Rear());       // returns 4\n    console.log(circularQueue.Front());      // returns 2\n};\n\nmain();\n</code></pre> <pre><code>MyCircularQueue &lt;- setRefClass(\n    \"MyCircularQueue\",\n    fields = list(\n        start = \"numeric\",\n        size = \"numeric\",\n        buffer = \"numeric\"\n    ),\n    methods = list(\n        initialize = function(k) {\n            start &lt;&lt;- 1\n            size &lt;&lt;- 0\n            buffer &lt;&lt;- numeric(k)\n        },\n        enQueue = function(value) {\n            if (isFull()) return(FALSE)\n            buffer[(start + size - 1)`__ %% length(buffer) + 1] &lt;&lt;- value\n            size &lt;&lt;- size + 1\n            return(TRUE)\n        },\n        deQueue = function() {\n            if (isEmpty()) return(FALSE)\n            start &lt;&lt;- (start %% length(buffer)) + 1\n            size &lt;&lt;- size - 1\n            return(TRUE)\n        },\n        Front = function() {\n            if (isEmpty()) return(-1)\n            return(buffer[start])\n        },\n        Rear = function() {\n            if (isEmpty()) return(-1)\n            return(buffer[(start + size - 2) %% length(buffer) + 1])\n        },\n        isEmpty = function() {\n            return(size == 0)\n        },\n        isFull = function() {\n            return(size == length(buffer))\n        }\n    )\n)\n\nmain &lt;- function() {\n    circularQueue &lt;- MyCircularQueue$new(3)\n\n    print(circularQueue$enQueue(1))  # returns TRUE\n    print(circularQueue$enQueue(2))  # returns TRUE\n    print(circularQueue$enQueue(3))  # returns TRUE\n    print(circularQueue$enQueue(4))  # returns FALSE\n\n    print(circularQueue$Rear())       # returns 3\n    print(circularQueue$isFull())     # returns TRUE\n\n    print(circularQueue$deQueue())    # returns TRUE\n    print(circularQueue$enQueue(4))   # returns TRUE\n\n    print(circularQueue$Rear())       # returns 4\n    print(circularQueue$Front())      # returns 2\n}\n\nmain()\n</code></pre> <pre><code>struct MyCircularQueue\n    start::Int\n    size::Int\n    buffer::Vector{Int}\nend\n\nfunction MyCircularQueue(k::Int)\n    return MyCircularQueue(1, 0, zeros(Int, k))\nend\n\nfunction enQueue(queue::MyCircularQueue, value::Int)\n    if isFull(queue)\n        return false\n    end\n    queue.buffer[(queue.start + queue.size - 1)`__ % length(queue.buffer) + 1] = value\n    queue.size += 1\n    return true\nend\n\nfunction deQueue(queue::MyCircularQueue)\n    if isEmpty(queue)\n        return false\n    end\n    queue.start = (queue.start % length(queue.buffer)) + 1\n    queue.size -= 1\n    return true\nend\n\nfunction Front(queue::MyCircularQueue)\n    return isEmpty(queue) ? -1 : queue.buffer[queue.start]\nend\n\nfunction Rear(queue::MyCircularQueue)\n    return isEmpty(queue) ? -1 : queue.buffer[(queue.start + queue.size - 2) % length(queue.buffer) + 1]\nend\n\nfunction isEmpty(queue::MyCircularQueue)\n    return queue.size == 0\nend\n\nfunction isFull(queue::MyCircularQueue)\n    return queue.size == length(queue.buffer)\nend\n\nfunction main()\n    circularQueue = MyCircularQueue(3)\n\n    println(enQueue(circularQueue, 1))  # returns true\n    println(enQueue(circularQueue, 2))  # returns true\n    println(enQueue(circularQueue, 3))  # returns true\n    println(enQueue(circularQueue, 4))  # returns false\n\n    println(Rear(circularQueue))         # returns 3\n    println(isFull(circularQueue))       # returns true\n\n    println(deQueue(circularQueue))      # returns true\n    println(enQueue(circularQueue, 4))   # returns true\n\n    println(Rear(circularQueue))         # returns 4\n    println(Front(circularQueue))        # returns 2\nend\n\nmain()\n</code></pre>","tags":["Original"]},{"location":"geometry/001_elementary_operations/","title":"Elementary Operations","text":"","tags":["Original"]},{"location":"geometry/002_polygons/","title":"Polygons","text":"","tags":["Original"]},{"location":"geometry/003_convex_hull/","title":"Convex Hull","text":"","tags":["Original"]},{"location":"geometry/004_sweep_line/","title":"Sweep-Line","text":"","tags":["Original"]},{"location":"geometry/005_planar_graphs/","title":"Planar Graphs","text":"","tags":["Original"]},{"location":"geometry/006_miscellaneous/","title":"Miscellaneous","text":"","tags":["Original"]},{"location":"large_language_model/001_nlp/","title":"NLP","text":"","tags":["Original"]},{"location":"large_language_model/002_word_embeddings/","title":"Word Embeddings","text":"","tags":["Original"]},{"location":"large_language_model/003_rnn_s_lstm_s_and_gru_s/","title":"RNNs, LSTMs, and, GRUs","text":"","tags":["Original"]},{"location":"large_language_model/004_encoder_decoder_architecture/","title":"Encoder Decoder Architecture","text":"","tags":["Original"]},{"location":"large_language_model/005_attention_mechanism/","title":"Attention Mechanism","text":"","tags":["Original"]},{"location":"large_language_model/006_transformers/","title":"Transformers","text":"","tags":["Original"]},{"location":"large_language_model/007_bert/","title":"BERT","text":"","tags":["Original"]},{"location":"large_language_model/008_gpt/","title":"GPT","text":"","tags":["Original"]},{"location":"large_language_model/009_llama/","title":"LLAMA","text":"","tags":["Original"]},{"location":"large_language_model/010_mistral/","title":"MISTRAL","text":"","tags":["Original"]},{"location":"linear_algebra/001_matrices/","title":"Matrices","text":"","tags":["Original"]},{"location":"logical_reasoning/001_logical_reasoning/","title":"Logical Reasoning Problems","text":""},{"location":"logical_reasoning/001_logical_reasoning/#-original","title":"- Original","text":""},{"location":"logical_reasoning/001_logical_reasoning/#logical-reasoning","title":"Logical Reasoning","text":""},{"location":"logical_reasoning/001_logical_reasoning/#barn-problem","title":"Barn Problem","text":""},{"location":"logical_reasoning/001_logical_reasoning/#problem-description","title":"Problem Description","text":"<p>You walk into barn and see collection of spiders,chickens and cows. You notice there are 520 legs in total. The number of chickens is twice that of cows and the number of spiders is twice that of chickens, compute the number of spiders.</p>"},{"location":"logical_reasoning/001_logical_reasoning/#solution","title":"Solution","text":"<p>Let's define the variables:</p> <ul> <li> <p>Let <code>c</code> represent the number of cows.</p> </li> <li> <p>The number of chickens is <code>2c</code> since the number of chickens is twice the number of cows.</p> </li> <li> <p>The number of spiders is <code>2(2c) = 4c</code> since the number of spiders is twice the number of chickens.</p> </li> </ul> <p>Now, let's calculate the total number of legs:</p> <ul> <li> <p>Cows have 4 legs, so the total number of legs from cows is <code>4c</code>.</p> </li> <li> <p>Chickens have 2 legs, so the total number of legs from chickens is <code>2(2c) = 4c</code>.</p> </li> <li> <p>Spiders have 8 legs, so the total number of legs from spiders is <code>8(4c) = 32c</code>.</p> </li> </ul> <p>The total number of legs is given as 520, so we can write the equation:</p> \\[ 4c + 4c + 32c = 520 \\] \\[ 40c = 520 \\] <p>Solving for <code>c</code>:</p> \\[ c = \\frac{520}{40} = 13 \\] <p>The number of spiders is <code>4c = 4(13) = 52</code>.</p> <p>Thus, there are 52 spiders.</p>"},{"location":"machine_learning/001_supervised_learning/","title":"Supervised Learning","text":"","tags":["Original"]},{"location":"machine_learning/002_unsupervised_learning/","title":"Un-supervised Learning","text":"","tags":["Original"]},{"location":"machine_learning/003_semi_supervised_learning/","title":"Semi-Supervised Learning","text":"","tags":["Original"]},{"location":"machine_learning/004_self_supervised_learning/","title":"Self-Supervised Learning","text":"","tags":["Original"]},{"location":"machine_learning/005_reinforcement_learning/","title":"Reinforcement Learning","text":"","tags":["Original"]},{"location":"numerical_methods/001_search/","title":"Search","text":"","tags":["Original"]},{"location":"numerical_methods/002_integration/","title":"Integration","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/","title":"Probability","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#combinatorics-probability-formulae-reference","title":"Combinatorics &amp; Probability Formulae Reference \ud83d\udcca","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#1-basic-counting-principles","title":"1. Basic Counting Principles \ud83d\udd22","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#multiplication-principle","title":"Multiplication Principle","text":"<ul> <li>If operation A can be done in \\(m\\) ways</li> <li>And operation B can be done in \\(n\\) ways</li> <li>Then A and B can be done in \\(m \\times n\\) ways</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#addition-principle","title":"Addition Principle","text":"<ul> <li>If operation A can be done in \\(m\\) ways</li> <li>Or operation B can be done in \\(n\\) ways</li> <li>Then A or B can be done in \\(m + n\\) ways</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#2-permutations","title":"2. Permutations \ud83d\udd04","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#basic-permutations","title":"Basic Permutations","text":"<ul> <li>\\(P(n) = n!\\)</li> <li>Orders n distinct objects</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#partial-permutations","title":"Partial Permutations","text":"<ul> <li>\\(P(n,r) = \\frac{n!}{(n-r)!}\\)</li> <li>Orders r items from n distinct objects</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#permutations-with-repetition","title":"Permutations with Repetition","text":"<ul> <li>With \\(n\\) objects, where object type \\(i\\) appears \\(k_i\\) times</li> <li>\\(P(n; k_1,k_2,\\ldots,k_m) = \\frac{n!}{k_1!k_2!\\cdots k_m!}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#circular-permutations","title":"Circular Permutations","text":"<ul> <li>\\(P_{circular}(n) = (n-1)!\\)</li> <li>Arranges n items in a circle</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#3-combinations","title":"3. Combinations \ud83c\udfaf","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#basic-combinations","title":"Basic Combinations","text":"<ul> <li>\\(C(n,r) = \\binom{n}{r} = \\frac{n!}{r!(n-r)!}\\)</li> <li>Selects r items from n distinct objects</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#combinations-with-repetition","title":"Combinations with Repetition","text":"<ul> <li>\\(C_{rep}(n,r) = \\binom{n+r-1}{r} = \\binom{n+r-1}{n-1}\\)</li> <li>Selects r items from n types, with repetition allowed</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#pascals-triangle-properties","title":"Pascal's Triangle Properties","text":"<ul> <li>\\(\\binom{n}{r} = \\binom{n}{n-r}\\)</li> <li>\\(\\binom{n}{r} = \\binom{n-1}{r-1} + \\binom{n-1}{r}\\)</li> <li>\\(\\sum_{r=0}^n \\binom{n}{r} = 2^n\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#4-basic-probability-rules","title":"4. Basic Probability Rules \ud83c\udfb2","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#probability-axioms","title":"Probability Axioms","text":"<ol> <li>\\(0 \\leq P(A) \\leq 1\\)</li> <li>\\(P(\\Omega) = 1\\) (total probability)</li> <li>For disjoint events: \\(P(A \\cup B) = P(A) + P(B)\\)</li> </ol>","tags":["Original"]},{"location":"probability/001_probability_basics/#complement-rule","title":"Complement Rule","text":"<ul> <li>\\(P(A^c) = 1 - P(A)\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#general-addition-rule","title":"General Addition Rule","text":"<ul> <li>\\(P(A \\cup B) = P(A) + P(B) - P(A \\cap B)\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#conditional-probability","title":"Conditional Probability","text":"<ul> <li>\\(P(A|B) = \\frac{P(A \\cap B)}{P(B)}\\)</li> <li>\\(P(A \\cap B) = P(A|B)P(B)\\) (Chain Rule)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#independence","title":"Independence","text":"<ul> <li>\\(P(A \\cap B) = P(A)P(B)\\)</li> <li>\\(P(A|B) = P(A)\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#5-bayes-theorem","title":"5. Bayes' Theorem \ud83d\udd04","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#basic-form","title":"Basic Form","text":"<ul> <li>\\(P(A|B) = \\frac{P(B|A)P(A)}{P(B)}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#extended-form","title":"Extended Form","text":"<ul> <li>\\(P(A_i|B) = \\frac{P(B|A_i)P(A_i)}{\\sum_j P(B|A_j)P(A_j)}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#6-random-variables","title":"6. Random Variables \ud83d\udcca","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#expected-value","title":"Expected Value","text":"<ul> <li>Discrete: \\(E(X) = \\sum x_i P(X = x_i)\\)</li> <li>Continuous: \\(E(X) = \\int_{-\\infty}^{\\infty} x f(x) dx\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#variance","title":"Variance","text":"<ul> <li>\\(Var(X) = E[(X-\\mu)^2] = E(X^2) - [E(X)]^2\\)</li> <li>\\(\\sigma = \\sqrt{Var(X)}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#properties","title":"Properties","text":"<ul> <li>\\(E(aX + b) = aE(X) + b\\)</li> <li>\\(Var(aX + b) = a^2Var(X)\\)</li> <li>\\(E(X + Y) = E(X) + E(Y)\\)</li> <li>\\(Var(X + Y) = Var(X) + Var(Y)\\) (if independent)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#7-common-probability-distributions","title":"7. Common Probability Distributions \ud83d\udcc8","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#bernoulli","title":"Bernoulli","text":"<ul> <li>\\(P(X = 1) = p\\), \\(P(X = 0) = 1-p\\)</li> <li>\\(E(X) = p\\)</li> <li>\\(Var(X) = p(1-p)\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#binomial","title":"Binomial","text":"<ul> <li>\\(P(X = k) = \\binom{n}{k}p^k(1-p)^{n-k}\\)</li> <li>\\(E(X) = np\\)</li> <li>\\(Var(X) = np(1-p)\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#geometric","title":"Geometric","text":"<ul> <li>\\(P(X = k) = p(1-p)^{k-1}\\)</li> <li>\\(E(X) = \\frac{1}{p}\\)</li> <li>\\(Var(X) = \\frac{1-p}{p^2}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#poisson","title":"Poisson","text":"<ul> <li>\\(P(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}\\)</li> <li>\\(E(X) = \\lambda\\)</li> <li>\\(Var(X) = \\lambda\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#8-useful-identities","title":"8. Useful Identities \ud83d\udcdd","text":"","tags":["Original"]},{"location":"probability/001_probability_basics/#summation-formulas","title":"Summation Formulas","text":"<ul> <li>\\(\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\\)</li> <li>\\(\\sum_{k=1}^n k^2 = \\frac{n(n+1)(2n+1)}{6}\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#probability-properties","title":"Probability Properties","text":"<ul> <li>Law of Total Probability: \\(P(A) = \\sum_i P(A|B_i)P(B_i)\\)</li> <li>\\(P(A_1 \\cap A_2 \\cap \\cdots \\cap A_n) = P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\\cdots\\)</li> </ul>","tags":["Original"]},{"location":"probability/001_probability_basics/#series-expansions","title":"Series Expansions","text":"<ul> <li>\\(e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots\\)</li> <li>\\((1+x)^n = 1 + nx + \\frac{n(n-1)}{2!}x^2 + \\cdots\\)</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/","title":"Probability","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-1-committees","title":"Problem 1: Committees","text":"<p>A committee of 6 is to be formed from a group of 6 men and 8 women.</p> <ul> <li>(a) : If you pick the committee (uniformly) at random, what is the probability that everyone in the group is female ?</li> <li>(b) : Suppose the committee should be balanced for gender (i.e., 3 men and 3 women) and that two of the men refuse to serve together. How many different committees are possible ?</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#solution-problem-1-committees","title":"Solution - Problem 1: Committees","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-1-a-probability-that-everyone-in-the-committee-is-female","title":"Problem 1-a) Probability that everyone in the committee is female","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#total-members-available","title":"Total members available:","text":"<ul> <li><code>6</code> men and <code>8</code> women, making a total of <code>6 + 8 = 14</code> people.</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#total-possible-committees","title":"Total possible committees:","text":"<p>The number of ways to select 6 people out of 14 is given by the combination formula: $$ \\binom{n}{r} = \\frac{n!}{r! \\cdot (n-r)!} $$ Here, \\(n = 14\\) and \\(r = 6\\): $$ \\binom{14}{6} = \\frac{14 \\cdot 13 \\cdot 12 \\cdot 11 \\cdot 10 \\cdot 9}{6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 3003 $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#favorable-outcomes-all-females","title":"Favorable outcomes (all females):","text":"<p>To select 6 women out of the 8 available: $$ \\binom{8}{6} = \\frac{8 \\cdot 7}{2 \\cdot 1} = 28 $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#probability_1","title":"Probability:","text":"<p>The probability is the ratio of favorable outcomes to total outcomes: $$ P(\\text{all female}) = \\frac{\\binom{8}{6}}{\\binom{14}{6}} = \\frac{28}{3003} \\approx 0.00932 $$</p> <p>Thus, the probability that the committee is entirely female is approximately 0.93%.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-1-b-number-of-gender-balanced-committees-3-men-and-3-women-under-constraints","title":"Problem 1-b) Number of gender-balanced committees (3 men and 3 women) under constraints","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#total-committees-with-gender-balance","title":"Total committees with gender balance:","text":"<p>We need to select 3 men out of 6 and 3 women out of 8. Without any constraints, the total number of committees is: $$ \\binom{6}{3} \\cdot \\binom{8}{3} $$ - Number of ways to select 3 men out of 6: $$ \\binom{6}{3} = \\frac{6 \\cdot 5 \\cdot 4}{3 \\cdot 2 \\cdot 1} = 20 $$ - Number of ways to select 3 women out of 8: $$ \\binom{8}{3} = \\frac{8 \\cdot 7 \\cdot 6}{3 \\cdot 2 \\cdot 1} = 56 $$ Total gender-balanced committees: $$ \\binom{6}{3} \\cdot \\binom{8}{3} = 20 \\cdot 56 = 1120 $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#adjust-for-constraints-two-men-refuse-to-serve-together","title":"Adjust for constraints (two men refuse to serve together):","text":"<p>Let the two men who refuse to serve together be \\(M_1\\) and \\(M_2\\).</p> <ol> <li> <p>Case 1: Both \\(M_1\\) and \\(M_2\\) are selected.    If <code>M_1</code> and <code>M_2</code> are in the committee, we must select <code>1</code> additional man from the remaining <code>6 - 2 = 4</code> men: $$    \\binom{4}{1} = 4 $$    For the women, we still select 3 out of 8: $$    \\binom{8}{3} = 56 $$    Total committees in this case: $$    \\binom{4}{1} \\cdot \\binom{8}{3} = 4 \\cdot 56 = 224 $$</p> </li> <li> <p>Case 2: At least one of \\(M_1\\) and \\(M_2\\) is excluded.    If either \\(M_1\\) or \\(M_2\\) is excluded, the other 3 men are chosen from the remaining \\(4 + 1 = 5\\) men: $$    \\binom{5}{3} = \\frac{5 \\cdot 4 \\cdot 3}{3 \\cdot 2 \\cdot 1} = 10 $$    For the women, we still select 3 out of 8: $$    \\binom{8}{3} = 56 $$    Total committees in this case: $$    \\binom{5}{3} \\cdot \\binom{8}{3} = 10 \\cdot 56 = 560 $$</p> </li> </ol>","tags":["Original"]},{"location":"probability/002_probability_problems/#total-gender-balanced-committees-with-constraints","title":"Total gender-balanced committees with constraints:","text":"<p>Subtract the invalid committees (Case 1) from the total: $$ \\text{Valid committees} = 1120 - 224 = 896 $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#final-answers","title":"Final Answers","text":"<ul> <li>a) Probability that the committee is all female: \\(\\mathbf{0.00932}\\) (or approximately \\(0.93\\%\\)$).</li> <li>b) Total number of valid gender-balanced committees: \\(\\mathbf{896}\\).</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-2-necklaces","title":"Problem 2: Necklaces","text":"<p>Suppose you have beads in 5 different shapes: \u25cf, \u25a0, \u25b2, \u2605, and \u2666. You have 6 different beads of every shape, all in one of six colors: red, green, blue, yellow, black, and white. So every bead has a unique color-shape combination (there is only one blue triangular bead, black circular one, etc.). </p> <p>You are going to make a necklace with 7 beads that should have a particular composition: 3 shapes have to occur precisely twice. Here are two examples of 7 beads with such a composition:</p> \\[ \\{\\textcolor{red}{\\star}, \\textcolor{blue}{\\square}, \\textcolor{yellow}{\\triangle}, \\textcolor{orange}{\\bullet}, \\textcolor{green}{\\triangle}, \\textcolor{blue}{\\square}, \\textcolor{red}{\\star}\\} \\] <p>or</p> \\[ \\{\\textcolor{red}{\\star}, \\textcolor{green}{\\triangle}, \\textcolor{blue}{\\triangle}, \\textcolor{yellow}{\\diamond}, \\textcolor{red}{\\bullet}, \\textcolor{blue}{\\star}, \\textcolor{orange}{\\diamond}\\}. \\]","tags":["Original"]},{"location":"probability/002_probability_problems/#a","title":"(a)","text":"<p>Before we can make a necklace (see part b), we need to pick our beads. You pick your 7 beads (uniformly) at random. What is the probability that they have the desired composition?</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#b","title":"(b)","text":"<p>Once we have our beads, we can make a necklace. We want to order the pairs of shapes symmetrically around the shape occurring once. As an example, take this necklace, which is symmetrical if you ignore color:</p> \\[ (\\textcolor{red}{\u2666}, \\textcolor{blue}{\\star}, \\textcolor{green}{\u25b2}, \\textcolor{orange}{\u25cf}, \\textcolor{black}{\u25b2}, \\textcolor{yellow}{\\star}, \\textcolor{red}{\u2666}) \\] <p>How many necklaces can you make from all possible groups of beads with the right composition? Note again that all beads are unique and that a necklace remains the same when you flip it around.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#solution-problem-2-necklaces","title":"Solution - Problem 2: Necklaces","text":"<p>To answer this multi-part problem, we need to analyze each part of the question in detail.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#part-a-probability-of-desired-composition","title":"Part (a) \u2014 Probability of Desired Composition","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#problem","title":"Problem:","text":"<p>We need to pick 7 beads uniformly at random, ensuring they have the desired composition: - 3 shapes appear twice. - 1 shape appears once.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#total-beads","title":"Total Beads:","text":"<p>Each shape (\u25cf, \u25a0, \u25b2, \u2605, \u2666) comes in 6 colors. So, there are \\(5 \\times 6 = 30\\) unique beads.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#total-ways-to-pick-7-beads","title":"Total Ways to Pick 7 Beads:","text":"<p>The total number of ways to pick 7 beads from 30 beads is: $$ \\binom{30}{7} $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#ways-to-pick-beads-matching-the-desired-composition","title":"Ways to Pick Beads Matching the Desired Composition:","text":"<ol> <li> <p>Step 1: Select 3 shapes to appear twice.    There are 5 shapes, and we choose 3 of them: $$ \\binom{5}{3} $$</p> </li> <li> <p>Step 2: Choose 2 beads (colors) for each of the 3 selected shapes.    For each of the 3 shapes, we select 2 colors from 6: $$ \\binom{6}{2} \\times \\binom{6}{2} \\times \\binom{6}{2} = \\binom{6}{2}^3 $$</p> </li> <li> <p>Step 3: Choose the 1 shape to appear once.    There are 2 remaining shapes (out of the original 5) after selecting 3 for Step 1: $$ \\binom{2}{1} = 2 $$</p> </li> <li> <p>Step 4: Choose 1 bead (color) for this single shape.    For the selected shape, choose 1 bead from 6: $$ \\binom{6}{1} = 6 $$</p> </li> </ol> <p>Combining all of these: $$ \\binom{5}{3} \\cdot \\binom{6}{2}^3 \\cdot \\binom{2}{1} \\cdot \\binom{6}{1} $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#probability_2","title":"Probability:","text":"<p>The probability is the ratio of favorable outcomes to total outcomes: $$ P = \\frac{\\binom{5}{3} \\cdot \\binom{6}{2}^3 \\cdot \\binom{2}{1} \\cdot \\binom{6}{1}}{\\binom{30}{7}} $$</p> <p>Let us compute this explicitly.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#part-b-number-of-unique-necklaces","title":"Part (b) \u2014 Number of Unique Necklaces","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#problem_1","title":"Problem:","text":"<p>Once we have the desired composition, we need to count the number of distinct necklaces. A necklace is considered the same if it can be rotated or flipped to match another.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#step-1-symmetry-of-the-necklace","title":"Step 1: Symmetry of the Necklace","text":"<ul> <li>The necklace consists of 7 beads arranged in a circle.</li> <li>The arrangement must be symmetric around the shape that appears once (the center).</li> <li>The 3 pairs of shapes must be symmetrically arranged around this center shape.</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#step-2-arranging-the-shapes","title":"Step 2: Arranging the Shapes","text":"<ol> <li> <p>Fix the central shape (appearing once).    There is only 1 way to choose this central shape since the shape was already determined in part (a).</p> </li> <li> <p>Arrange 3 pairs of shapes symmetrically.    There are \\(3!\\) ways to arrange the 3 shapes. Since they must be symmetric, we divide by 2 to account for rotation: $$    \\frac{3!}{2} = 3 $$</p> </li> <li> <p>Arrange the colors within each shape pair.    For each pair, there are 2 ways to order the colors. Since there are 3 pairs: $$    2 \\times 2 \\times 2 = 8 $$</p> </li> </ol>","tags":["Original"]},{"location":"probability/002_probability_problems/#total-unique-necklaces","title":"Total Unique Necklaces:","text":"<p>Combining all possibilities: $$ \\text{Total Necklaces} = 3 \\cdot 8 = 24 $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#final-answer","title":"Final Answer:","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#a-probability","title":"(a) Probability:","text":"\\[ P = \\frac{\\binom{5}{3} \\cdot \\binom{6}{2}^3 \\cdot \\binom{2}{1} \\cdot \\binom{6}{1}}{\\binom{30}{7}} \\]","tags":["Original"]},{"location":"probability/002_probability_problems/#b-unique-necklaces","title":"(b) Unique Necklaces:","text":"\\[ \\text{Total Necklaces} = 24 \\]","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-3-counting-functions","title":"Problem 3: Counting Functions","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#a_1","title":"(a)","text":"<p>Let \\(X\\) and \\(Y\\) be two finite sets. How many functions are there from \\(X\\) to \\(Y\\)$? (If you are unsure about what functions precisely are, check the Wikipedia entry Function (Mathematics)).</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#b_1","title":"(b)","text":"<p>How many functions are there from \\(\\{0, 1\\}^n\\) to \\(\\{0, 1\\}^{n^2}\\)$?</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#c","title":"(c)","text":"<p>Let \\(A, B \\subset \\{1, \\ldots, 100\\}\\) be such that \\(A\\) contains all even numbers and \\(B\\) all multiples of 3. Let \\(X\\) be their union and \\(n \\in \\mathbb{N}\\) some integer. How many functions \\(f : \\{1, \\ldots, n\\} \\to X\\) are there?</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#solution-problem-3-counting","title":"Solution - Problem 3: Counting","text":"<p>Let's break down and solve each part of Problem 3: Counting Functions:</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#a-how-many-functions-are-there-from-x-to-y","title":"(a) How many functions are there from \\(X\\) to \\(Y\\)$?","text":"<p>If \\(X\\) has \\(|X| = m\\) elements and \\(Y\\) has \\(|Y| = n\\) elements, then each element of \\(X\\) can be mapped to any of the \\(n\\) elements of \\(Y\\). Thus, the total number of functions is:</p> \\[ n^m \\] <ul> <li>Explanation: For each of the \\(m\\) elements of \\(X\\)\\(, there are \\(n\\) choices in \\(Y\\). Since these choices are independent for each element of \\(X\\)\\), the total number of functions is the product \\(n^m\\).</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#b-how-many-functions-are-there-from-0-1n-to-0-1n2","title":"(b) How many functions are there from \\(\\{0, 1\\}^n\\) to \\(\\{0, 1\\}^{n^2}\\)$?","text":"<ol> <li>The set \\(\\{0, 1\\}^n\\) has \\(2^n\\) elements (since there are \\(n\\) binary positions, each with 2 choices: 0 or 1).</li> <li>The set \\(\\{0, 1\\}^{n^2}\\) has \\(2^{n^2}\\) elements.</li> </ol> <p>Thus, the total number of functions from \\(\\{0, 1\\}^n\\) to \\(\\{0, 1\\}^{n^2}\\) is:</p> \\[ \\left(2^{n^2}\\right)^{2^n} = 2^{n^2 \\cdot 2^n} \\] <ul> <li>Explanation: Each of the \\(2^n\\) elements of the domain \\(\\{0, 1\\}^n\\) can be mapped to any of the \\(2^{n^2}\\) elements of the codomain \\(\\{0, 1\\}^{n^2}\\). Thus, the total number of functions is \\((2^{n^2})^{2^n}\\).</li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#c-how-many-functions-f-1-ldots-n-to-x-are-there-where-a-contains-all-even-numbers-b-contains-all-multiples-of-3-and-x-is-their-union","title":"(c) How many functions \\(f : \\{1, \\ldots, n\\} \\to X\\) are there, where \\(A\\) contains all even numbers, \\(B\\) contains all multiples of 3, and \\(X\\) is their union?","text":"<ol> <li>Determine \\(A\\) (even numbers in \\(\\{1, \\ldots, 100\\}\\)$):</li> <li>Even numbers are \\(2, 4, 6, \\ldots, 100\\).</li> <li>This is an arithmetic sequence with \\(a = 2\\)\\(, \\(d = 2\\)\\), and \\(l = 100\\).</li> <li> <p>The number of even numbers is:      $      |A| = \\frac{100 - 2}{2} + 1 = 50      $</p> </li> <li> <p>Determine \\(B\\) (multiples of 3 in \\(\\{1, \\ldots, 100\\}\\)$):</p> </li> <li>Multiples of 3 are \\(3, 6, 9, \\ldots, 99\\).</li> <li>This is an arithmetic sequence with \\(a = 3\\)\\(, \\(d = 3\\)\\), and \\(l = 99\\).</li> <li> <p>The number of multiples of 3 is:      $      |B| = \\frac{99 - 3}{3} + 1 = 33      $</p> </li> <li> <p>Determine \\(A \\cap B\\) (multiples of 6 in \\(\\{1, \\ldots, 100\\}\\)$):</p> </li> <li>Multiples of 6 are \\(6, 12, 18, \\ldots, 96\\).</li> <li>This is an arithmetic sequence with \\(a = 6\\)\\(, \\(d = 6\\)\\), and \\(l = 96\\).</li> <li> <p>The number of multiples of 6 is:      $      |A \\cap B| = \\frac{96 - 6}{6} + 1 = 16      $</p> </li> <li> <p>Find \\(|X|\\) (size of the union \\(A \\cup B\\)$):    By the principle of inclusion-exclusion: $$    |X| = |A| + |B| - |A \\cap B| = 50 + 33 - 16 = 67 $$</p> </li> <li> <p>Count the number of functions \\(f : \\{1, \\ldots, n\\} \\to X\\):    Each of the \\(n\\) elements in \\(\\{1, \\ldots, n\\}\\) can be mapped to any of the \\(|X| = 67\\) elements in \\(X\\). Thus, the total number of functions is: $$    67^n $$</p> </li> </ol>","tags":["Original"]},{"location":"probability/002_probability_problems/#final-answers_1","title":"Final Answers:","text":"<ol> <li>(a): \\(n^m\\) </li> <li>(b): \\(2^{n^2 \\cdot 2^n}\\) </li> <li>(c): \\(67^n\\) </li> </ol>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-3-football","title":"Problem 3: Football","text":"<p>A football coach wants to analyze the performance of his team. After every week he registers the outcome of the match (win or lose, there are no ties) and how his team played (good, fair or hopeless). Consider an experiment that consists of registering these two things.</p> <ul> <li> <p>(a) Give the sample space of this experiment.</p> </li> <li> <p>(b) Let \\(A\\) be the event that the team's performance was hopeless and \\(B\\) the event that the team won. Specify the outcomes in \\(A\\) and \\(B\\).</p> </li> <li> <p>(c) Paraphrase the event \\((\u03a9 \\backslash A) \u222a B\\) and give all its outcomes.</p> </li> <li> <p>(d) After a couple of weeks, the coach analysed the data and came to the following conclusions: 1) His team is equally likely to win or loose; 2) his team is equally likely to play a good or a hopeless match, but 3) fair performance is half times as likely as good performance. Finally, 4) they never win when they play a hopeless match and 5) never loose when they play a good match. Give a table describing the full probability function.</p> </li> <li> <p>(e) Last week's match has been hopeless. What is the probability that they've won? (If you didn't solve part (d), use a fancy probability function of your choice, but make sure to include it in your solution.)</p> </li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#solution-problem-4-football","title":"Solution - Problem 4: Football","text":"<p>Let\u2019s solve this step by step. </p>","tags":["Original"]},{"location":"probability/002_probability_problems/#a-give-the-sample-space-of-this-experiment","title":"(a) Give the sample space of this experiment.","text":"<p>The outcomes of the experiment consist of two attributes: 1. Match outcome: Either win or lose. 2. Performance: Either good, fair, or hopeless.</p> <p>Thus, the sample space is the Cartesian product of these two attributes:</p> \\[ \\Omega = \\{(w, g), (w, f), (w, h), (l, g), (l, f), (l, h)\\} \\] <p>Where: - \\(w\\) = win, \\(l\\) = lose - \\(g\\) = good, \\(f\\) = fair, \\(h\\) = hopeless</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#b-specify-the-outcomes-in-a-and-b","title":"(b) Specify the outcomes in \\(A\\) and \\(B\\).","text":"<p>1. Event \\(A\\): The team's performance was hopeless.    Outcomes in \\(A\\): $$    A = {(w, h), (l, h)} $$</p> <p>2. Event \\(B\\): The team won.    Outcomes in \\(B\\): $$    B = {(w, g), (w, f), (w, h)} $$</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#c-paraphrase-the-event-omega-setminus-a-cup-b-and-give-its-outcomes","title":"(c) Paraphrase the event \\((\\Omega \\setminus A) \\cup B\\) and give its outcomes.","text":"<ol> <li> <p>Complement \\(\\Omega \\setminus A\\): Outcomes where the performance was not hopeless (i.e., either good or fair): $$    \\Omega \\setminus A = {(w, g), (w, f), (l, g), (l, f)} $$</p> </li> <li> <p>Union \\((\\Omega \\setminus A) \\cup B\\): Outcomes where the performance was not hopeless or the team won.    Combining \\(\\Omega \\setminus A\\) and \\(B\\)$, we get: $$    (\\Omega \\setminus A) \\cup B = {(w, g), (w, f), (l, g), (l, f), (w, h)} $$</p> </li> </ol> <p>Paraphrase: The event \\((\\Omega \\setminus A) \\cup B\\) represents all cases where the performance was not hopeless or the team won.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#d-give-a-table-describing-the-full-probability-function","title":"(d) Give a table describing the full probability function.","text":"<p>Based on the coach\u2019s conclusions: 1. The team is equally likely to win or lose: $$    P(\\text{win}) = P(\\text{lose}) = 0.5 $$</p> <p>2. The team is equally likely to play a good or hopeless match, and fair performance is half as likely as good performance: $$    P(\\text{good}) = P(\\text{hopeless}) = \\frac{2}{5}, \\quad P(\\text{fair}) = \\frac{1}{5} $$</p> <p>3. The team never wins when they play a hopeless match: $$    P((w, h)) = 0 $$</p> <p>4. The team never loses when they play a good match: $$    P((l, g)) = 0 $$</p> <p>To compute the remaining probabilities, we distribute the probabilities based on the product of match outcome and performance likelihoods, ensuring that the constraints are satisfied.</p> Outcome Probability \\((w, g)\\) \\(0.5 \\times \\frac{2}{5} = 0.2\\) \\((w, f)\\) \\(0.5 \\times \\frac{1}{5} = 0.1\\) \\((w, h)\\) \\(0\\) \\((l, g)\\) \\(0\\) \\((l, f)\\) \\(0.5 \\times \\frac{1}{5} = 0.1\\) \\((l, h)\\) \\(0.5 \\times \\frac{2}{5} = 0.2\\)","tags":["Original"]},{"location":"probability/002_probability_problems/#e-what-is-the-probability-that-theyve-won-given-the-match-was-hopeless","title":"(e) What is the probability that they\u2019ve won, given the match was hopeless?","text":"<p>Using the definition of conditional probability:</p> \\[ P(\\text{win} \\mid \\text{hopeless}) = \\frac{P(\\text{win and hopeless})}{P(\\text{hopeless})} \\] <p>1. Compute \\(P(\\text{win and hopeless})\\): From the table: $$    P((w, h)) = 0 $$</p> <ol> <li> <p>Compute \\(P(\\text{hopeless})\\): Sum of probabilities for \\(\\text{hopeless}\\) outcomes: $$    P(\\text{hopeless}) = P((w, h)) + P((l, h)) = 0 + 0.2 = 0.2 $$</p> </li> <li> <p>Substitute into the formula: $$    P(\\text{win} \\mid \\text{hopeless}) = \\frac{0}{0.2} = 0 $$</p> </li> </ol> <p>Final Answer: If the match was hopeless, the probability that they\u2019ve won is 0.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-4-a-probability-urn","title":"Problem 4: A probability urn","text":"<p>An urn contains 3 red balls, 5 green balls, and one blue ball. You randomly draw a ball, don't put it back, but add two balls of the colors you did not draw. (For example: if you have drawn a red ball, add a green and a blue ball to the urn.) What is the probability that the second ball is red? </p> <p>Hint: Draw a tree!</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-5-probability-functions","title":"Problem 5: Probability functions","text":"<p>Let \\((\\Omega, A, P)\\) be a finite probability space and \\(A, B \\in A\\) two events.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#a-1pt","title":"(a) 1pt","text":"<p>Show that \\(P\\) is monotone: if \\(A \\subseteq B\\)$, then \\(P(A) \\leq P(B)\\).</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#b-1pt","title":"(b) 1pt","text":"<p>Show that if \\(A \\subset B\\)$, then \\(P(B \\setminus A) = P(B) - P(A)\\). Hint: Use (a).</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#c-1pt","title":"(c) 1pt","text":"<p>Now assume that \\(A\\) and \\(B\\) are independent and prove that \\(A^c = \\Omega \\setminus A\\) and \\(B\\) are also independent. Hint: Draw a Venn diagram and post a question to the forum if you need more hints.</p>","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-n-exercise-survey-problem","title":"Problem n: Exercise Survey Problem","text":"","tags":["Original"]},{"location":"probability/002_probability_problems/#problem-description","title":"Problem Description","text":"<ul> <li> <p>1000 people were asked about their preferred method of exercise.</p> </li> <li> <p>The following table shows the results, grouped by age: </p> </li> </ul> 18-22 23-27 28-32 33-37 Total Run 54 40 42 66 202 Bike 77 68 90 70 305 Swim 28 43 50 52 173 Other 90 78 71 81 320 Total 249 229 253 269 1000 <ul> <li> <p>You meet a 33 year old who took survey. </p> </li> <li> <p>Compute the probability (in fraction) she prefers swimming.</p> </li> </ul>","tags":["Original"]},{"location":"probability/002_probability_problems/#solution-problem-n-exercise","title":"Solution - Problem n: Exercise","text":"<ul> <li> <p>We know that the person is 33 years old, which places them in the 33-37 age group.</p> </li> <li> <p>To compute the probability that this person prefers swimming, we need to focus on the total number of people in the 33-37 age group and the number of people in that age group who prefer swimming.</p> </li> <li> <p>From the table - the total number of people in the 33-37 age group is 269.</p> </li> <li> <p>The number of people in the 33-37 age group who prefer swimming is 52.</p> </li> </ul> <p>The probability <code>P</code> that a randomly selected person from the 33-37 age group prefers swimming is given by the ratio of people who prefer swimming to the total number of people in that age group:</p> \\[ P = \\frac{52}{269} \\] <p>Thus, the probability that the 33-year-old prefers swimming is:</p> \\[ \\frac{52}{269} \\]","tags":["Original"]},{"location":"regression/001_linear_regression/","title":"Linear Regression","text":"","tags":["Original"]},{"location":"regression/002_polynomial_regression/","title":"Polynomial Regression","text":"","tags":["Original"]},{"location":"regression/003_ridge_regression_l2_regularization/","title":"Ridge Regression (L2 Regularization)","text":"","tags":["Original"]},{"location":"regression/004_lasso_regression_l1_regularization/","title":"Lasso Regression (L1 Regularization)","text":"","tags":["Original"]},{"location":"regression/005_logistic_regression/","title":"Logistic Regression","text":"","tags":["Original"]},{"location":"regression/006_elastic_net_regression/","title":"Elastic-Net Regression","text":"","tags":["Original"]},{"location":"tags/","title":"Tags","text":"<p>This file contains a global index of all tags used on the pages.</p>"},{"location":"tags/#original","title":"Original","text":"<ul> <li>Fundamentals</li> <li>Prime Numbers</li> <li>Number-Theoretic Functions</li> <li>Modular Arithmetic</li> <li>Number Systems</li> <li>Miscellaneous</li> <li>Two Pointers</li> <li>Binary Search</li> <li>Binary Search Tree</li> <li>Depth First Search</li> <li>Breadth First Search</li> <li>Backtracking</li> <li>Dynamic Programming</li> <li>Recursion</li> <li>Permutations</li> <li>Array</li> <li>String</li> <li>Linked List</li> <li>Stack</li> <li>Queue</li> <li>Binary Heap</li> <li>Tree</li> <li>Graph</li> <li>Hashtable</li> <li>Design</li> <li>Elementary Operations</li> <li>Polygons</li> <li>Convex Hull</li> <li>Sweep-Line</li> <li>Planar Graphs</li> <li>Miscellaeous</li> <li>NLP</li> <li>Word Embeddings</li> <li>RNNs, LSTMs &amp; GRUs</li> <li>Encoder-Decoder Architecture</li> <li>Attention Mechanism</li> <li>Transformers</li> <li>BERT</li> <li>GPT</li> <li>LLama</li> <li>Mistral</li> <li>Matrices</li> <li>Supervised Learning</li> <li>Unsupervised Learning</li> <li>Semi-supervised Learning</li> <li>Self-supervised Learning</li> <li>Reinforcement Learning</li> <li>Search</li> <li>Integration</li> <li>Probability Basics</li> <li>Probability Problems</li> <li>Linear Regression</li> <li>Polynomial Regression</li> <li>Ridge Regression (L2 Regularization)</li> <li>Lasso Regression (L1 Regularization)</li> <li>Logistic Regression</li> <li>ElasticNet Regression</li> </ul>"}]}